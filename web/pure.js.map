{
  "version": 3,
  "sources": ["output/Data.Functor/foreign.js", ".spago/p/prelude-6.0.1/src/Control/Semigroupoid.purs", ".spago/p/prelude-6.0.1/src/Control/Category.purs", ".spago/p/prelude-6.0.1/src/Data/Boolean.purs", ".spago/p/prelude-6.0.1/src/Data/Function.purs", ".spago/p/prelude-6.0.1/src/Data/Functor.purs", "output/Data.Semigroup/foreign.js", ".spago/p/prelude-6.0.1/src/Data/Semigroup.purs", ".spago/p/control-6.0.0/src/Control/Alt.purs", "output/Control.Apply/foreign.js", ".spago/p/prelude-6.0.1/src/Control/Apply.purs", ".spago/p/prelude-6.0.1/src/Control/Applicative.purs", "output/Control.Bind/foreign.js", ".spago/p/prelude-6.0.1/src/Control/Bind.purs", ".spago/p/prelude-6.0.1/src/Control/Monad.purs", "output/Unsafe.Coerce/foreign.js", ".spago/p/st-6.2.0/src/Control/Monad/ST/Global.purs", "output/Control.Monad.ST.Internal/foreign.js", "output/Data.Bounded/foreign.js", "output/Data.Ord/foreign.js", "output/Data.Eq/foreign.js", ".spago/p/prelude-6.0.1/src/Data/Eq.purs", ".spago/p/prelude-6.0.1/src/Data/Ordering.purs", "output/Data.Semiring/foreign.js", ".spago/p/prelude-6.0.1/src/Data/Semiring.purs", ".spago/p/prelude-6.0.1/src/Data/Ord.purs", "output/Data.Show/foreign.js", ".spago/p/prelude-6.0.1/src/Data/Show.purs", ".spago/p/maybe-6.0.0/src/Data/Maybe.purs", ".spago/p/either-6.1.0/src/Data/Either.purs", ".spago/p/prelude-6.0.1/src/Data/Monoid.purs", "output/Effect/foreign.js", ".spago/p/effect-4.0.0/src/Effect.purs", "output/Effect.Ref/foreign.js", ".spago/p/refs-6.0.0/src/Effect/Ref.purs", ".spago/p/tailrec-6.1.0/src/Control/Monad/Rec/Class.purs", ".spago/p/st-6.2.0/src/Control/Monad/ST/Internal.purs", ".spago/p/st-6.2.0/src/Control/Monad/ST/Class.purs", "output/Control.Monad.ST.Uncurried/foreign.js", ".spago/p/control-6.0.0/src/Control/Plus.purs", "output/Data.Array/foreign.js", "output/Data.Array.ST/foreign.js", ".spago/p/arrays-7.3.0/src/Data/Array/ST.purs", "output/Data.HeytingAlgebra/foreign.js", ".spago/p/prelude-6.0.1/src/Data/HeytingAlgebra.purs", ".spago/p/arrays-7.3.0/src/Data/Array/ST/Iterator.purs", "output/Data.Foldable/foreign.js", ".spago/p/tuples-7.0.0/src/Data/Tuple.purs", ".spago/p/safe-coerce-2.0.0/src/Safe/Coerce.purs", ".spago/p/newtype-5.0.0/src/Data/Newtype.purs", ".spago/p/foldable-traversable-6.0.0/src/Data/Foldable.purs", "output/Data.Function.Uncurried/foreign.js", ".spago/p/functors-5.0.0/src/Data/Functor/Compose.purs", ".spago/p/arrays-7.3.0/src/Data/Array.purs", ".spago/p/lists-7.0.0/src/Data/List/Types.purs", ".spago/p/lists-7.0.0/src/Data/List.purs", ".spago/p/filterable-5.0.0/src/Data/Compactable.purs", "output/Effect.Exception/foreign.js", "output/Data.String.CodeUnits/foreign.js", ".spago/p/strings-6.0.1/src/Data/String/CodeUnits.purs", "output/Foreign/foreign.js", ".spago/p/catenable-lists-7.0.0/src/Data/CatQueue.purs", ".spago/p/catenable-lists-7.0.0/src/Data/CatList.purs", ".spago/p/free-7.1.0/src/Control/Monad/Free.purs", "output/Data.Nullable/foreign.js", ".spago/p/nullable-6.0.0/src/Data/Nullable.purs", "output/Effect.Uncurried/foreign.js", ".spago/p/effect-4.0.0/src/Effect/Uncurried.purs", "output/Foreign.Object/foreign.js", ".spago/p/deku-core/6b7c392da7782fe0f2e34811e36b11e630e10b26/deku-core/src/Deku/Internal/Ancestry.purs", ".spago/p/deku-core/6b7c392da7782fe0f2e34811e36b11e630e10b26/deku-core/src/Deku/Internal/Entities.purs", "output/FRP.Event/foreign.js", ".spago/p/filterable-5.0.0/src/Data/Filterable.purs", ".spago/p/hyrule/f508363b9ad7e2389ea8b3433f7e2ee1b1f8fa25/src/FRP/Event/Class.purs", ".spago/p/hyrule/f508363b9ad7e2389ea8b3433f7e2ee1b1f8fa25/src/FRP/Event.purs", ".spago/p/profunctor-6.0.1/src/Data/Profunctor.purs", "output/Web.HTML/foreign.js", "output/Web.Internal.FFI/foreign.js", ".spago/p/web-events-4.0.0/src/Web/Internal/FFI.purs", "output/Web.HTML.HTMLButtonElement/foreign.js", ".spago/p/web-html-4.1.0/src/Web/HTML/HTMLButtonElement.purs", "output/Web.HTML.HTMLDocument/foreign.js", ".spago/p/web-html-4.1.0/src/Web/HTML/HTMLDocument.purs", ".spago/p/web-html-4.1.0/src/Web/HTML/HTMLElement.purs", "output/Web.HTML.HTMLFieldSetElement/foreign.js", ".spago/p/web-html-4.1.0/src/Web/HTML/HTMLFieldSetElement.purs", "output/Web.HTML.HTMLInputElement/foreign.js", ".spago/p/web-html-4.1.0/src/Web/HTML/HTMLInputElement.purs", "output/Web.HTML.HTMLKeygenElement/foreign.js", ".spago/p/web-html-4.1.0/src/Web/HTML/HTMLKeygenElement.purs", "output/Web.HTML.HTMLLinkElement/foreign.js", ".spago/p/web-html-4.1.0/src/Web/HTML/HTMLLinkElement.purs", "output/Web.HTML.HTMLOptGroupElement/foreign.js", ".spago/p/web-html-4.1.0/src/Web/HTML/HTMLOptGroupElement.purs", "output/Web.HTML.HTMLOptionElement/foreign.js", ".spago/p/web-html-4.1.0/src/Web/HTML/HTMLOptionElement.purs", "output/Web.HTML.HTMLSelectElement/foreign.js", ".spago/p/web-html-4.1.0/src/Web/HTML/HTMLSelectElement.purs", "output/Web.HTML.HTMLTextAreaElement/foreign.js", ".spago/p/web-html-4.1.0/src/Web/HTML/HTMLTextAreaElement.purs", "output/Web.HTML.Window/foreign.js", ".spago/p/hyrule/f508363b9ad7e2389ea8b3433f7e2ee1b1f8fa25/src/FRP/Poll/Unoptimized.purs", ".spago/p/hyrule/f508363b9ad7e2389ea8b3433f7e2ee1b1f8fa25/src/FRP/Poll.purs", ".spago/p/deku-core/6b7c392da7782fe0f2e34811e36b11e630e10b26/deku-core/src/Deku/Internal/Region.purs", ".spago/p/deku-core/6b7c392da7782fe0f2e34811e36b11e630e10b26/deku-core/src/Deku/Core.purs", ".spago/p/deku-dom/6b7c392da7782fe0f2e34811e36b11e630e10b26/deku-dom/src/Deku/DOM.purs", "output/Effect.Aff/foreign.js", ".spago/p/deku-dom/6b7c392da7782fe0f2e34811e36b11e630e10b26/deku-dom/src/Deku/DOM/Attributes.purs", "output/Deku.Interpret/foreign.js", ".spago/p/exists-6.0.0/src/Data/Exists.purs", "output/Deku.UnsafeDOM/foreign.js", "output/Unsafe.Reference/foreign.js", ".spago/p/unsafe-reference-5.0.0/src/Unsafe/Reference.purs", "output/Web.DOM.ChildNode/foreign.js", "output/Web.DOM.Element/foreign.js", "output/Web.DOM.ParentNode/foreign.js", "output/Web.DOM.Node/foreign.js", ".spago/p/web-dom-6.0.0/src/Web/DOM/Node.purs", ".spago/p/web-dom-6.0.0/src/Web/DOM/Text.purs", ".spago/p/deku-core/6b7c392da7782fe0f2e34811e36b11e630e10b26/deku-core/src/Deku/Interpret.purs", ".spago/p/deku-core/6b7c392da7782fe0f2e34811e36b11e630e10b26/deku-core/src/Deku/FullDOMInterpret.purs", ".spago/p/deku-core/6b7c392da7782fe0f2e34811e36b11e630e10b26/deku-core/src/Deku/Toplevel.purs", "output/Effect.Console/foreign.js", "src/Main.purs"],
  "sourcesContent": ["export const arrayMap = function (f) {\n  return function (arr) {\n    var l = arr.length;\n    var result = new Array(l);\n    for (var i = 0; i < l; i++) {\n      result[i] = f(arr[i]);\n    }\n    return result;\n  };\n};\n", "module Control.Semigroupoid where\n\n-- | A `Semigroupoid` is similar to a [`Category`](#category) but does not\n-- | require an identity element `identity`, just composable morphisms.\n-- |\n-- | `Semigroupoid`s must satisfy the following law:\n-- |\n-- | - Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`\n-- |\n-- | One example of a `Semigroupoid` is the function type constructor `(->)`,\n-- | with `(<<<)` defined as function composition.\nclass Semigroupoid :: forall k. (k -> k -> Type) -> Constraint\nclass Semigroupoid a where\n  compose :: forall b c d. a c d -> a b c -> a b d\n\ninstance semigroupoidFn :: Semigroupoid (->) where\n  compose f g x = f (g x)\n\ninfixr 9 compose as <<<\n\n-- | Forwards composition, or `compose` with its arguments reversed.\ncomposeFlipped :: forall a b c d. Semigroupoid a => a b c -> a c d -> a b d\ncomposeFlipped f g = compose g f\n\ninfixr 9 composeFlipped as >>>\n", "module Control.Category\n  ( class Category\n  , identity\n  , module Control.Semigroupoid\n  ) where\n\nimport Control.Semigroupoid (class Semigroupoid, compose, (<<<), (>>>))\n\n-- | `Category`s consist of objects and composable morphisms between them, and\n-- | as such are [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids`\n-- | must have an identity element.\n-- |\n-- | Instances must satisfy the following law in addition to the\n-- | `Semigroupoid` law:\n-- |\n-- | - Identity: `identity <<< p = p <<< identity = p`\nclass Category :: forall k. (k -> k -> Type) -> Constraint\nclass Semigroupoid a <= Category a where\n  identity :: forall t. a t t\n\ninstance categoryFn :: Category (->) where\n  identity x = x\n", "module Data.Boolean where\n\n-- | An alias for `true`, which can be useful in guard clauses:\n-- |\n-- | ```purescript\n-- | max x y | x >= y    = x\n-- |         | otherwise = y\n-- | ```\notherwise :: Boolean\notherwise = true\n", "module Data.Function\n  ( flip\n  , const\n  , apply\n  , ($)\n  , applyFlipped\n  , (#)\n  , applyN\n  , on\n  , module Control.Category\n  ) where\n\nimport Control.Category (identity, compose, (<<<), (>>>))\nimport Data.Boolean (otherwise)\nimport Data.Ord ((<=))\nimport Data.Ring ((-))\n\n-- | Given a function that takes two arguments, applies the arguments\n-- | to the function in a swapped order.\n-- |\n-- | ```purescript\n-- | flip append \"1\" \"2\" == append \"2\" \"1\" == \"21\"\n-- |\n-- | const 1 \"two\" == 1\n-- |\n-- | flip const 1 \"two\" == const \"two\" 1 == \"two\"\n-- | ```\nflip :: forall a b c. (a -> b -> c) -> b -> a -> c\nflip f b a = f a b\n\n-- | Returns its first argument and ignores its second.\n-- |\n-- | ```purescript\n-- | const 1 \"hello\" = 1\n-- | ```\n-- |\n-- | It can also be thought of as creating a function that ignores its argument:\n-- |\n-- | ```purescript\n-- | const 1 = \\_ -> 1\n-- | ```\nconst :: forall a b. a -> b -> a\nconst a _ = a\n\n-- | Applies a function to an argument. This is primarily used as the operator\n-- | `($)` which allows parentheses to be omitted in some cases, or as a\n-- | natural way to apply a chain of composed functions to a value.\napply :: forall a b. (a -> b) -> a -> b\napply f x = f x\n\n-- | Applies a function to an argument: the reverse of `(#)`.\n-- |\n-- | ```purescript\n-- | length $ groupBy productCategory $ filter isInStock $ products\n-- | ```\n-- |\n-- | is equivalent to:\n-- |\n-- | ```purescript\n-- | length (groupBy productCategory (filter isInStock products))\n-- | ```\n-- |\n-- | Or another alternative equivalent, applying chain of composed functions to\n-- | a value:\n-- |\n-- | ```purescript\n-- | length <<< groupBy productCategory <<< filter isInStock $ products\n-- | ```\ninfixr 0 apply as $\n\n-- | Applies an argument to a function. This is primarily used as the `(#)`\n-- | operator, which allows parentheses to be omitted in some cases, or as a\n-- | natural way to apply a value to a chain of composed functions.\napplyFlipped :: forall a b. a -> (a -> b) -> b\napplyFlipped x f = f x\n\n-- | Applies an argument to a function: the reverse of `($)`.\n-- |\n-- | ```purescript\n-- | products # filter isInStock # groupBy productCategory # length\n-- | ```\n-- |\n-- | is equivalent to:\n-- |\n-- | ```purescript\n-- | length (groupBy productCategory (filter isInStock products))\n-- | ```\n-- |\n-- | Or another alternative equivalent, applying a value to a chain of composed\n-- | functions:\n-- |\n-- | ```purescript\n-- | products # filter isInStock >>> groupBy productCategory >>> length\n-- | ```\ninfixl 1 applyFlipped as #\n\n-- | `applyN f n` applies the function `f` to its argument `n` times.\n-- |\n-- | If n is less than or equal to 0, the function is not applied.\n-- |\n-- | ```purescript\n-- | applyN (_ + 1) 10 0 == 10\n-- | ```\napplyN :: forall a. (a -> a) -> Int -> a -> a\napplyN f = go\n  where\n  go n acc\n    | n <= 0 = acc\n    | otherwise = go (n - 1) (f acc)\n\n-- | The `on` function is used to change the domain of a binary operator.\n-- |\n-- | For example, we can create a function which compares two records based on the values of their `x` properties:\n-- |\n-- | ```purescript\n-- | compareX :: forall r. { x :: Number | r } -> { x :: Number | r } -> Ordering\n-- | compareX = compare `on` _.x\n-- | ```\non :: forall a b c. (b -> b -> c) -> (a -> b) -> a -> a -> c\non f g x y = g x `f` g y\n", "module Data.Functor\n  ( class Functor\n  , map\n  , (<$>)\n  , mapFlipped\n  , (<#>)\n  , void\n  , voidRight\n  , (<$)\n  , voidLeft\n  , ($>)\n  , flap\n  , (<@>)\n  ) where\n\nimport Data.Function (const, compose)\nimport Data.Unit (Unit, unit)\nimport Type.Proxy (Proxy(..))\n\n-- | A `Functor` is a type constructor which supports a mapping operation\n-- | `map`.\n-- |\n-- | `map` can be used to turn functions `a -> b` into functions\n-- | `f a -> f b` whose argument and return types use the type constructor `f`\n-- | to represent some computational context.\n-- |\n-- | Instances must satisfy the following laws:\n-- |\n-- | - Identity: `map identity = identity`\n-- | - Composition: `map (f <<< g) = map f <<< map g`\nclass Functor f where\n  map :: forall a b. (a -> b) -> f a -> f b\n\ninfixl 4 map as <$>\n\n-- | `mapFlipped` is `map` with its arguments reversed. For example:\n-- |\n-- | ```purescript\n-- | [1, 2, 3] <#> \\n -> n * n\n-- | ```\nmapFlipped :: forall f a b. Functor f => f a -> (a -> b) -> f b\nmapFlipped fa f = f <$> fa\n\ninfixl 1 mapFlipped as <#>\n\ninstance functorFn :: Functor ((->) r) where\n  map = compose\n\ninstance functorArray :: Functor Array where\n  map = arrayMap\n\ninstance functorProxy :: Functor Proxy where\n  map _ _ = Proxy\n\nforeign import arrayMap :: forall a b. (a -> b) -> Array a -> Array b\n\n-- | The `void` function is used to ignore the type wrapped by a\n-- | [`Functor`](#functor), replacing it with `Unit` and keeping only the type\n-- | information provided by the type constructor itself.\n-- |\n-- | `void` is often useful when using `do` notation to change the return type\n-- | of a monadic computation:\n-- |\n-- | ```purescript\n-- | main = forE 1 10 \\n -> void do\n-- |   print n\n-- |   print (n * n)\n-- | ```\nvoid :: forall f a. Functor f => f a -> f Unit\nvoid = map (const unit)\n\n-- | Ignore the return value of a computation, using the specified return value\n-- | instead.\nvoidRight :: forall f a b. Functor f => a -> f b -> f a\nvoidRight x = map (const x)\n\ninfixl 4 voidRight as <$\n\n-- | A version of `voidRight` with its arguments flipped.\nvoidLeft :: forall f a b. Functor f => f a -> b -> f b\nvoidLeft f x = const x <$> f\n\ninfixl 4 voidLeft as $>\n\n-- | Apply a value in a computational context to a value in no context.\n-- |\n-- | Generalizes `flip`.\n-- |\n-- | ```purescript\n-- | longEnough :: String -> Bool\n-- | hasSymbol :: String -> Bool\n-- | hasDigit :: String -> Bool\n-- | password :: String\n-- |\n-- | validate :: String -> Array Bool\n-- | validate = flap [longEnough, hasSymbol, hasDigit]\n-- | ```\n-- |\n-- | ```purescript\n-- | flap (-) 3 4 == 1\n-- | threeve <$> Just 1 <@> 'a' <*> Just true == Just (threeve 1 'a' true)\n-- | ```\nflap :: forall f a b. Functor f => f (a -> b) -> a -> f b\nflap ff x = map (\\f -> f x) ff\n\ninfixl 4 flap as <@>\n", "export const concatString = function (s1) {\n  return function (s2) {\n    return s1 + s2;\n  };\n};\n\nexport const concatArray = function (xs) {\n  return function (ys) {\n    if (xs.length === 0) return ys;\n    if (ys.length === 0) return xs;\n    return xs.concat(ys);\n  };\n};\n", "module Data.Semigroup\n  ( class Semigroup\n  , append\n  , (<>)\n  , class SemigroupRecord\n  , appendRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Data.Void (Void, absurd)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Semigroup` type class identifies an associative operation on a type.\n-- |\n-- | Instances are required to satisfy the following law:\n-- |\n-- | - Associativity: `(x <> y) <> z = x <> (y <> z)`\n-- |\n-- | One example of a `Semigroup` is `String`, with `(<>)` defined as string\n-- | concatenation. Another example is `List a`, with `(<>)` defined as\n-- | list concatenation.\n-- |\n-- | ### Newtypes for Semigroup\n-- |\n-- | There are two other ways to implement an instance for this type class\n-- | regardless of which type is used. These instances can be used by\n-- | wrapping the values in one of the two newtypes below:\n-- | 1. `First` - Use the first argument every time: `append first _ = first`.\n-- | 2. `Last` - Use the last argument every time: `append _ last = last`.\nclass Semigroup a where\n  append :: a -> a -> a\n\ninfixr 5 append as <>\n\ninstance semigroupString :: Semigroup String where\n  append = concatString\n\ninstance semigroupUnit :: Semigroup Unit where\n  append _ _ = unit\n\ninstance semigroupVoid :: Semigroup Void where\n  append _ = absurd\n\ninstance semigroupFn :: Semigroup s' => Semigroup (s -> s') where\n  append f g x = f x <> g x\n\ninstance semigroupArray :: Semigroup (Array a) where\n  append = concatArray\n\ninstance semigroupProxy :: Semigroup (Proxy a) where\n  append _ _ = Proxy\n\ninstance semigroupRecord :: (RL.RowToList row list, SemigroupRecord list row row) => Semigroup (Record row) where\n  append = appendRecord (Proxy :: Proxy list)\n\nforeign import concatString :: String -> String -> String\nforeign import concatArray :: forall a. Array a -> Array a -> Array a\n\n-- | A class for records where all fields have `Semigroup` instances, used to\n-- | implement the `Semigroup` instance for records.\nclass SemigroupRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemigroupRecord rowlist row subrow | rowlist -> subrow where\n  appendRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n\ninstance semigroupRecordNil :: SemigroupRecord RL.Nil row () where\n  appendRecord _ _ _ = {}\n\ninstance semigroupRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , SemigroupRecord rowlistTail row subrowTail\n  , Semigroup focus\n  ) =>\n  SemigroupRecord (RL.Cons key focus rowlistTail) row subrow where\n  appendRecord _ ra rb = insert (get ra <> get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = appendRecord (Proxy :: Proxy rowlistTail) ra rb\n", "module Control.Alt\n  ( class Alt, alt, (<|>)\n  , module Data.Functor\n  ) where\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Semigroup (append)\n\n-- | The `Alt` type class identifies an associative operation on a type\n-- | constructor.  It is similar to `Semigroup`, except that it applies to\n-- | types of kind `* -> *`, like `Array` or `List`, rather than concrete types\n-- | `String` or `Number`.\n-- |\n-- | `Alt` instances are required to satisfy the following laws:\n-- |\n-- | - Associativity: `(x <|> y) <|> z == x <|> (y <|> z)`\n-- | - Distributivity: `f <$> (x <|> y) == (f <$> x) <|> (f <$> y)`\n-- |\n-- | For example, the `Array` (`[]`) type is an instance of `Alt`, where\n-- | `(<|>)` is defined to be concatenation.\n-- |\n-- | A common use case is to select the first \"valid\" item, or, if all items\n-- | are \"invalid\", the last \"invalid\" item.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Control.Alt ((<|>))\n-- | import Data.Maybe (Maybe(..)\n-- | import Data.Either (Either(..))\n-- |\n-- | Nothing <|> Just 1 <|> Just 2 == Just 1\n-- | Left \"err\" <|> Right 1 <|> Right 2 == Right 1\n-- | Left \"err 1\" <|> Left \"err 2\" <|> Left \"err 3\" == Left \"err 3\"\n-- | ```\nclass Functor f <= Alt f where\n  alt :: forall a. f a -> f a -> f a\n\ninfixr 3 alt as <|>\n\ninstance altArray :: Alt Array where\n  alt = append\n", "export const arrayApply = function (fs) {\n  return function (xs) {\n    var l = fs.length;\n    var k = xs.length;\n    var result = new Array(l*k);\n    var n = 0;\n    for (var i = 0; i < l; i++) {\n      var f = fs[i];\n      for (var j = 0; j < k; j++) {\n        result[n++] = f(xs[j]);\n      }\n    }\n    return result;\n  };\n};\n", "module Control.Apply\n  ( class Apply\n  , apply\n  , (<*>)\n  , applyFirst\n  , (<*)\n  , applySecond\n  , (*>)\n  , lift2\n  , lift3\n  , lift4\n  , lift5\n  , module Data.Functor\n  ) where\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Function (const)\nimport Control.Category (identity)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Apply` class provides the `(<*>)` which is used to apply a function\n-- | to an argument under a type constructor.\n-- |\n-- | `Apply` can be used to lift functions of two or more arguments to work on\n-- | values wrapped with the type constructor `f`. It might also be understood\n-- | in terms of the `lift2` function:\n-- |\n-- | ```purescript\n-- | lift2 :: forall f a b c. Apply f => (a -> b -> c) -> f a -> f b -> f c\n-- | lift2 f a b = f <$> a <*> b\n-- | ```\n-- |\n-- | `(<*>)` is recovered from `lift2` as `lift2 ($)`. That is, `(<*>)` lifts\n-- | the function application operator `($)` to arguments wrapped with the\n-- | type constructor `f`.\n-- |\n-- | Put differently...\n-- | ```\n-- | foo =\n-- |   functionTakingNArguments <$> computationProducingArg1\n-- |                            <*> computationProducingArg2\n-- |                            <*> ...\n-- |                            <*> computationProducingArgN\n-- | ```\n-- |\n-- | Instances must satisfy the following law in addition to the `Functor`\n-- | laws:\n-- |\n-- | - Associative composition: `(<<<) <$> f <*> g <*> h = f <*> (g <*> h)`\n-- |\n-- | Formally, `Apply` represents a strong lax semi-monoidal endofunctor.\nclass Functor f <= Apply f where\n  apply :: forall a b. f (a -> b) -> f a -> f b\n\ninfixl 4 apply as <*>\n\ninstance applyFn :: Apply ((->) r) where\n  apply f g x = f x (g x)\n\ninstance applyArray :: Apply Array where\n  apply = arrayApply\n\nforeign import arrayApply :: forall a b. Array (a -> b) -> Array a -> Array b\n\ninstance applyProxy :: Apply Proxy where\n  apply _ _ = Proxy\n\n-- | Combine two effectful actions, keeping only the result of the first.\napplyFirst :: forall a b f. Apply f => f a -> f b -> f a\napplyFirst a b = const <$> a <*> b\n\ninfixl 4 applyFirst as <*\n\n-- | Combine two effectful actions, keeping only the result of the second.\napplySecond :: forall a b f. Apply f => f a -> f b -> f b\napplySecond a b = const identity <$> a <*> b\n\ninfixl 4 applySecond as *>\n\n-- | Lift a function of two arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\n-- |\n-- | ```purescript\n-- | lift2 add (Just 1) (Just 2) == Just 3\n-- | lift2 add Nothing (Just 2) == Nothing\n-- |```\n-- |\nlift2 :: forall a b c f. Apply f => (a -> b -> c) -> f a -> f b -> f c\nlift2 f a b = f <$> a <*> b\n\n-- | Lift a function of three arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift3 :: forall a b c d f. Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\nlift3 f a b c = f <$> a <*> b <*> c\n\n-- | Lift a function of four arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift4 :: forall a b c d e f. Apply f => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e\nlift4 f a b c d = f <$> a <*> b <*> c <*> d\n\n-- | Lift a function of five arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift5 :: forall a b c d e f g. Apply f => (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g\nlift5 f a b c d e = f <$> a <*> b <*> c <*> d <*> e\n", "module Control.Applicative\n  ( class Applicative\n  , pure\n  , liftA1\n  , unless\n  , when\n  , module Control.Apply\n  , module Data.Functor\n  ) where\n\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit, unit)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Applicative` type class extends the [`Apply`](#apply) type class\n-- | with a `pure` function, which can be used to create values of type `f a`\n-- | from values of type `a`.\n-- |\n-- | Where [`Apply`](#apply) provides the ability to lift functions of two or\n-- | more arguments to functions whose arguments are wrapped using `f`, and\n-- | [`Functor`](#functor) provides the ability to lift functions of one\n-- | argument, `pure` can be seen as the function which lifts functions of\n-- | _zero_ arguments. That is, `Applicative` functors support a lifting\n-- | operation for any number of function arguments.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Apply`\n-- | laws:\n-- |\n-- | - Identity: `(pure identity) <*> v = v`\n-- | - Composition: `pure (<<<) <*> f <*> g <*> h = f <*> (g <*> h)`\n-- | - Homomorphism: `(pure f) <*> (pure x) = pure (f x)`\n-- | - Interchange: `u <*> (pure y) = (pure (_ $ y)) <*> u`\nclass Apply f <= Applicative f where\n  pure :: forall a. a -> f a\n\ninstance applicativeFn :: Applicative ((->) r) where\n  pure x _ = x\n\ninstance applicativeArray :: Applicative Array where\n  pure x = [ x ]\n\ninstance applicativeProxy :: Applicative Proxy where\n  pure _ = Proxy\n\n-- | `liftA1` provides a default implementation of `(<$>)` for any\n-- | [`Applicative`](#applicative) functor, without using `(<$>)` as provided\n-- | by the [`Functor`](#functor)-[`Applicative`](#applicative) superclass\n-- | relationship.\n-- |\n-- | `liftA1` can therefore be used to write [`Functor`](#functor) instances\n-- | as follows:\n-- |\n-- | ```purescript\n-- | instance functorF :: Functor F where\n-- |   map = liftA1\n-- | ```\nliftA1 :: forall f a b. Applicative f => (a -> b) -> f a -> f b\nliftA1 f a = pure f <*> a\n\n-- | Perform an applicative action when a condition is true.\nwhen :: forall m. Applicative m => Boolean -> m Unit -> m Unit\nwhen true m = m\nwhen false _ = pure unit\n\n-- | Perform an applicative action unless a condition is true.\nunless :: forall m. Applicative m => Boolean -> m Unit -> m Unit\nunless false m = m\nunless true _ = pure unit\n", "export const arrayBind = function (arr) {\n  return function (f) {\n    var result = [];\n    for (var i = 0, l = arr.length; i < l; i++) {\n      Array.prototype.push.apply(result, f(arr[i]));\n    }\n    return result;\n  };\n};\n", "module Control.Bind\n  ( class Bind\n  , bind\n  , (>>=)\n  , bindFlipped\n  , (=<<)\n  , class Discard\n  , discard\n  , join\n  , composeKleisli\n  , (>=>)\n  , composeKleisliFlipped\n  , (<=<)\n  , ifM\n  , module Data.Functor\n  , module Control.Apply\n  , module Control.Applicative\n  ) where\n\nimport Control.Applicative (class Applicative, liftA1, pure, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Category (identity)\n\nimport Data.Function (flip)\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Bind` type class extends the [`Apply`](#apply) type class with a\n-- | \"bind\" operation `(>>=)` which composes computations in sequence, using\n-- | the return value of one computation to determine the next computation.\n-- |\n-- | The `>>=` operator can also be expressed using `do` notation, as follows:\n-- |\n-- | ```purescript\n-- | x >>= f = do y <- x\n-- |              f y\n-- | ```\n-- |\n-- | where the function argument of `f` is given the name `y`.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Apply`\n-- | laws:\n-- |\n-- | - Associativity: `(x >>= f) >>= g = x >>= (\\k -> f k >>= g)`\n-- | - Apply Superclass: `apply f x = f >>= \\f\u2019 -> map f\u2019 x`\n-- |\n-- | Associativity tells us that we can regroup operations which use `do`\n-- | notation so that we can unambiguously write, for example:\n-- |\n-- | ```purescript\n-- | do x <- m1\n-- |    y <- m2 x\n-- |    m3 x y\n-- | ```\nclass Apply m <= Bind m where\n  bind :: forall a b. m a -> (a -> m b) -> m b\n\ninfixl 1 bind as >>=\n\n-- | `bindFlipped` is `bind` with its arguments reversed. For example:\n-- |\n-- | ```purescript\n-- | print =<< random\n-- | ```\nbindFlipped :: forall m a b. Bind m => (a -> m b) -> m a -> m b\nbindFlipped = flip bind\n\ninfixr 1 bindFlipped as =<<\n\ninstance bindFn :: Bind ((->) r) where\n  bind m f x = f (m x) x\n\n-- | The `bind`/`>>=` function for `Array` works by applying a function to\n-- | each element in the array, and flattening the results into a single,\n-- | new array.\n-- |\n-- | Array's `bind`/`>>=` works like a nested for loop. Each `bind` adds\n-- | another level of nesting in the loop. For example:\n-- | ```\n-- | foo :: Array String\n-- | foo =\n-- |   [\"a\", \"b\"] >>= \\eachElementInArray1 ->\n-- |     [\"c\", \"d\"] >>= \\eachElementInArray2\n-- |       pure (eachElementInArray1 <> eachElementInArray2)\n-- |\n-- | -- In other words...\n-- | foo\n-- | -- ... is the same as...\n-- | [ (\"a\" <> \"c\"), (\"a\" <> \"d\"), (\"b\" <> \"c\"), (\"b\" <> \"d\") ]\n-- | -- which simplifies to...\n-- | [ \"ac\", \"ad\", \"bc\", \"bd\" ]\n-- | ```\ninstance bindArray :: Bind Array where\n  bind = arrayBind\n\nforeign import arrayBind :: forall a b. Array a -> (a -> Array b) -> Array b\n\ninstance bindProxy :: Bind Proxy where\n  bind _ _ = Proxy\n\n-- | A class for types whose values can safely be discarded\n-- | in a `do` notation block.\n-- |\n-- | An example is the `Unit` type, since there is only one\n-- | possible value which can be returned.\nclass Discard a where\n  discard :: forall f b. Bind f => f a -> (a -> f b) -> f b\n\ninstance discardUnit :: Discard Unit where\n  discard = bind\n\ninstance discardProxy :: Discard (Proxy a) where\n  discard = bind\n\n-- | Collapse two applications of a monadic type constructor into one.\njoin :: forall a m. Bind m => m (m a) -> m a\njoin m = m >>= identity\n\n-- | Forwards Kleisli composition.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Data.Array (head, tail)\n-- |\n-- | third = tail >=> tail >=> head\n-- | ```\ncomposeKleisli :: forall a b c m. Bind m => (a -> m b) -> (b -> m c) -> a -> m c\ncomposeKleisli f g a = f a >>= g\n\ninfixr 1 composeKleisli as >=>\n\n-- | Backwards Kleisli composition.\ncomposeKleisliFlipped :: forall a b c m. Bind m => (b -> m c) -> (a -> m b) -> a -> m c\ncomposeKleisliFlipped f g a = f =<< g a\n\ninfixr 1 composeKleisliFlipped as <=<\n\n-- | Execute a monadic action if a condition holds.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = ifM ((< 0.5) <$> random)\n-- |          (trace \"Heads\")\n-- |          (trace \"Tails\")\n-- | ```\nifM :: forall a m. Bind m => m Boolean -> m a -> m a -> m a\nifM cond t f = cond >>= \\cond' -> if cond' then t else f\n", "module Control.Monad\n  ( class Monad\n  , liftM1\n  , whenM\n  , unlessM\n  , ap\n  , module Data.Functor\n  , module Control.Apply\n  , module Control.Applicative\n  , module Control.Bind\n  ) where\n\nimport Control.Applicative (class Applicative, liftA1, pure, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Bind (class Bind, bind, ifM, join, (<=<), (=<<), (>=>), (>>=))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit)\nimport Type.Proxy (Proxy)\n\n-- | The `Monad` type class combines the operations of the `Bind` and\n-- | `Applicative` type classes. Therefore, `Monad` instances represent type\n-- | constructors which support sequential composition, and also lifting of\n-- | functions of arbitrary arity.\n-- |\n-- | Instances must satisfy the following laws in addition to the\n-- | `Applicative` and `Bind` laws:\n-- |\n-- | - Left Identity: `pure x >>= f = f x`\n-- | - Right Identity: `x >>= pure = x`\nclass (Applicative m, Bind m) <= Monad m\n\ninstance monadFn :: Monad ((->) r)\n\ninstance monadArray :: Monad Array\n\ninstance monadProxy :: Monad Proxy\n\n-- | `liftM1` provides a default implementation of `(<$>)` for any\n-- | [`Monad`](#monad), without using `(<$>)` as provided by the\n-- | [`Functor`](#functor)-[`Monad`](#monad) superclass relationship.\n-- |\n-- | `liftM1` can therefore be used to write [`Functor`](#functor) instances\n-- | as follows:\n-- |\n-- | ```purescript\n-- | instance functorF :: Functor F where\n-- |   map = liftM1\n-- | ```\nliftM1 :: forall m a b. Monad m => (a -> b) -> m a -> m b\nliftM1 f a = do\n  a' <- a\n  pure (f a')\n\n-- | Perform a monadic action when a condition is true, where the conditional\n-- | value is also in a monadic context.\nwhenM :: forall m. Monad m => m Boolean -> m Unit -> m Unit\nwhenM mb m = do\n  b <- mb\n  when b m\n\n-- | Perform a monadic action unless a condition is true, where the conditional\n-- | value is also in a monadic context.\nunlessM :: forall m. Monad m => m Boolean -> m Unit -> m Unit\nunlessM mb m = do\n  b <- mb\n  unless b m\n\n-- | `ap` provides a default implementation of `(<*>)` for any `Monad`, without\n-- | using `(<*>)` as provided by the `Apply`-`Monad` superclass relationship.\n-- |\n-- | `ap` can therefore be used to write `Apply` instances as follows:\n-- |\n-- | ```purescript\n-- | instance applyF :: Apply F where\n-- |   apply = ap\n-- | ```\n-- Note: Only a `Bind` constraint is needed, but this can\n-- produce loops when used with other default implementations\n-- (i.e. `liftA1`).\n-- See https://github.com/purescript/purescript-prelude/issues/232\nap :: forall m a b. Monad m => m (a -> b) -> m a -> m b\nap f a = do\n  f' <- f\n  a' <- a\n  pure (f' a')\n", "// module Unsafe.Coerce\n\nexport const unsafeCoerce = function (x) {\n  return x;\n};\n", "module Control.Monad.ST.Global\n  ( Global\n  , toEffect\n  ) where\n\nimport Prelude\n\nimport Control.Monad.ST (ST, Region)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | This region allows `ST` computations to be converted into `Effect`\n-- | computations so they can be run in a global context.\nforeign import data Global :: Region\n\n-- | Converts an `ST` computation into an `Effect` computation.\ntoEffect :: ST Global ~> Effect\ntoEffect = unsafeCoerce\n", "export const map_ = function (f) {\n  return function (a) {\n    return function () {\n      return f(a());\n    };\n  };\n};\n\nexport const pure_ = function (a) {\n  return function () {\n    return a;\n  };\n};\n\nexport const bind_ = function (a) {\n  return function (f) {\n    return function () {\n      return f(a())();\n    };\n  };\n};\n\nexport const run = function (f) {\n  return f();\n};\n\nfunction whileST(f) {\n  return function (a) {\n    return function () {\n      while (f()) {\n        a();\n      }\n    };\n  };\n}\nexport { whileST as while };\n\nfunction forST(lo) {\n  return function (hi) {\n    return function (f) {\n      return function () {\n        for (var i = lo; i < hi; i++) {\n          f(i)();\n        }\n      };\n    };\n  };\n}\nexport { forST as for };\n\nexport const foreach = function (as) {\n  return function (f) {\n    return function () {\n      for (var i = 0, l = as.length; i < l; i++) {\n        f(as[i])();\n      }\n    };\n  };\n};\n\nfunction newSTRef(val) {\n  return function () {\n    return { value: val };\n  };\n}\nexport { newSTRef as new };\n\nexport const read = function (ref) {\n  return function () {\n    return ref.value;\n  };\n};\n\nexport const modifyImpl = function (f) {\n  return function (ref) {\n    return function () {\n      var t = f(ref.value);\n      ref.value = t.state;\n      return t.value;\n    };\n  };\n};\n\nexport const write = function (a) {\n  return function (ref) {\n    return function () {\n      return ref.value = a; // eslint-disable-line no-return-assign\n    };\n  };\n};\n", "export const topInt = 2147483647;\nexport const bottomInt = -2147483648;\n\nexport const topChar = String.fromCharCode(65535);\nexport const bottomChar = String.fromCharCode(0);\n\nexport const topNumber = Number.POSITIVE_INFINITY;\nexport const bottomNumber = Number.NEGATIVE_INFINITY;\n", "var unsafeCompareImpl = function (lt) {\n  return function (eq) {\n    return function (gt) {\n      return function (x) {\n        return function (y) {\n          return x < y ? lt : x === y ? eq : gt;\n        };\n      };\n    };\n  };\n};\n\nexport const ordBooleanImpl = unsafeCompareImpl;\nexport const ordIntImpl = unsafeCompareImpl;\nexport const ordNumberImpl = unsafeCompareImpl;\nexport const ordStringImpl = unsafeCompareImpl;\nexport const ordCharImpl = unsafeCompareImpl;\n\nexport const ordArrayImpl = function (f) {\n  return function (xs) {\n    return function (ys) {\n      var i = 0;\n      var xlen = xs.length;\n      var ylen = ys.length;\n      while (i < xlen && i < ylen) {\n        var x = xs[i];\n        var y = ys[i];\n        var o = f(x)(y);\n        if (o !== 0) {\n          return o;\n        }\n        i++;\n      }\n      if (xlen === ylen) {\n        return 0;\n      } else if (xlen > ylen) {\n        return -1;\n      } else {\n        return 1;\n      }\n    };\n  };\n};\n", "var refEq = function (r1) {\n  return function (r2) {\n    return r1 === r2;\n  };\n};\n\nexport const eqBooleanImpl = refEq;\nexport const eqIntImpl = refEq;\nexport const eqNumberImpl = refEq;\nexport const eqCharImpl = refEq;\nexport const eqStringImpl = refEq;\n\nexport const eqArrayImpl = function (f) {\n  return function (xs) {\n    return function (ys) {\n      if (xs.length !== ys.length) return false;\n      for (var i = 0; i < xs.length; i++) {\n        if (!f(xs[i])(ys[i])) return false;\n      }\n      return true;\n    };\n  };\n};\n", "module Data.Eq\n  ( class Eq\n  , eq\n  , (==)\n  , notEq\n  , (/=)\n  , class Eq1\n  , eq1\n  , notEq1\n  , class EqRecord\n  , eqRecord\n  ) where\n\nimport Data.HeytingAlgebra ((&&))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit)\nimport Data.Void (Void)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Eq` type class represents types which support decidable equality.\n-- |\n-- | `Eq` instances should satisfy the following laws:\n-- |\n-- | - Reflexivity: `x == x = true`\n-- | - Symmetry: `x == y = y == x`\n-- | - Transitivity: if `x == y` and `y == z` then `x == z`\n-- |\n-- | **Note:** The `Number` type is not an entirely law abiding member of this\n-- | class due to the presence of `NaN`, since `NaN /= NaN`. Additionally,\n-- | computing with `Number` can result in a loss of precision, so sometimes\n-- | values that should be equivalent are not.\nclass Eq a where\n  eq :: a -> a -> Boolean\n\ninfix 4 eq as ==\n\n-- | `notEq` tests whether one value is _not equal_ to another. Shorthand for\n-- | `not (eq x y)`.\nnotEq :: forall a. Eq a => a -> a -> Boolean\nnotEq x y = (x == y) == false\n\ninfix 4 notEq as /=\n\ninstance eqBoolean :: Eq Boolean where\n  eq = eqBooleanImpl\n\ninstance eqInt :: Eq Int where\n  eq = eqIntImpl\n\ninstance eqNumber :: Eq Number where\n  eq = eqNumberImpl\n\ninstance eqChar :: Eq Char where\n  eq = eqCharImpl\n\ninstance eqString :: Eq String where\n  eq = eqStringImpl\n\ninstance eqUnit :: Eq Unit where\n  eq _ _ = true\n\ninstance eqVoid :: Eq Void where\n  eq _ _ = true\n\ninstance eqArray :: Eq a => Eq (Array a) where\n  eq = eqArrayImpl eq\n\ninstance eqRec :: (RL.RowToList row list, EqRecord list row) => Eq (Record row) where\n  eq = eqRecord (Proxy :: Proxy list)\n\ninstance eqProxy :: Eq (Proxy a) where\n  eq _ _ = true\n\nforeign import eqBooleanImpl :: Boolean -> Boolean -> Boolean\nforeign import eqIntImpl :: Int -> Int -> Boolean\nforeign import eqNumberImpl :: Number -> Number -> Boolean\nforeign import eqCharImpl :: Char -> Char -> Boolean\nforeign import eqStringImpl :: String -> String -> Boolean\n\nforeign import eqArrayImpl :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Boolean\n\n-- | The `Eq1` type class represents type constructors with decidable equality.\nclass Eq1 f where\n  eq1 :: forall a. Eq a => f a -> f a -> Boolean\n\ninstance eq1Array :: Eq1 Array where\n  eq1 = eq\n\nnotEq1 :: forall f a. Eq1 f => Eq a => f a -> f a -> Boolean\nnotEq1 x y = (x `eq1` y) == false\n\n-- | A class for records where all fields have `Eq` instances, used to implement\n-- | the `Eq` instance for records.\nclass EqRecord :: RL.RowList Type -> Row Type -> Constraint\nclass EqRecord rowlist row where\n  eqRecord :: Proxy rowlist -> Record row -> Record row -> Boolean\n\ninstance eqRowNil :: EqRecord RL.Nil row where\n  eqRecord _ _ _ = true\n\ninstance eqRowCons ::\n  ( EqRecord rowlistTail row\n  , Row.Cons key focus rowTail row\n  , IsSymbol key\n  , Eq focus\n  ) =>\n  EqRecord (RL.Cons key focus rowlistTail) row where\n  eqRecord _ ra rb = (get ra == get rb) && tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = eqRecord (Proxy :: Proxy rowlistTail) ra rb\n", "module Data.Ordering (Ordering(..), invert) where\n\nimport Data.Eq (class Eq)\nimport Data.Semigroup (class Semigroup)\nimport Data.Show (class Show)\n\n-- | The `Ordering` data type represents the three possible outcomes of\n-- | comparing two values:\n-- |\n-- | `LT` - The first value is _less than_ the second.\n-- | `GT` - The first value is _greater than_ the second.\n-- | `EQ` - The first value is _equal to_ the second.\ndata Ordering = LT | GT | EQ\n\ninstance eqOrdering :: Eq Ordering where\n  eq LT LT = true\n  eq GT GT = true\n  eq EQ EQ = true\n  eq _ _ = false\n\ninstance semigroupOrdering :: Semigroup Ordering where\n  append LT _ = LT\n  append GT _ = GT\n  append EQ y = y\n\ninstance showOrdering :: Show Ordering where\n  show LT = \"LT\"\n  show GT = \"GT\"\n  show EQ = \"EQ\"\n\n-- | Reverses an `Ordering` value, flipping greater than for less than while\n-- | preserving equality.\ninvert :: Ordering -> Ordering\ninvert GT = LT\ninvert EQ = EQ\ninvert LT = GT\n", "export const intAdd = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x + y | 0;\n  };\n};\n\nexport const intMul = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x * y | 0;\n  };\n};\n\nexport const numAdd = function (n1) {\n  return function (n2) {\n    return n1 + n2;\n  };\n};\n\nexport const numMul = function (n1) {\n  return function (n2) {\n    return n1 * n2;\n  };\n};\n", "module Data.Semiring\n  ( class Semiring\n  , add\n  , (+)\n  , zero\n  , mul\n  , (*)\n  , one\n  , class SemiringRecord\n  , addRecord\n  , mulRecord\n  , oneRecord\n  , zeroRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Semiring` class is for types that support an addition and\n-- | multiplication operation.\n-- |\n-- | Instances must satisfy the following laws:\n-- |\n-- | - Commutative monoid under addition:\n-- |   - Associativity: `(a + b) + c = a + (b + c)`\n-- |   - Identity: `zero + a = a + zero = a`\n-- |   - Commutative: `a + b = b + a`\n-- | - Monoid under multiplication:\n-- |   - Associativity: `(a * b) * c = a * (b * c)`\n-- |   - Identity: `one * a = a * one = a`\n-- | - Multiplication distributes over addition:\n-- |   - Left distributivity: `a * (b + c) = (a * b) + (a * c)`\n-- |   - Right distributivity: `(a + b) * c = (a * c) + (b * c)`\n-- | - Annihilation: `zero * a = a * zero = zero`\n-- |\n-- | **Note:** The `Number` and `Int` types are not fully law abiding\n-- | members of this class hierarchy due to the potential for arithmetic\n-- | overflows, and in the case of `Number`, the presence of `NaN` and\n-- | `Infinity` values. The behaviour is unspecified in these cases.\nclass Semiring a where\n  add :: a -> a -> a\n  zero :: a\n  mul :: a -> a -> a\n  one :: a\n\ninfixl 6 add as +\ninfixl 7 mul as *\n\ninstance semiringInt :: Semiring Int where\n  add = intAdd\n  zero = 0\n  mul = intMul\n  one = 1\n\ninstance semiringNumber :: Semiring Number where\n  add = numAdd\n  zero = 0.0\n  mul = numMul\n  one = 1.0\n\ninstance semiringFn :: Semiring b => Semiring (a -> b) where\n  add f g x = f x + g x\n  zero = \\_ -> zero\n  mul f g x = f x * g x\n  one = \\_ -> one\n\ninstance semiringUnit :: Semiring Unit where\n  add _ _ = unit\n  zero = unit\n  mul _ _ = unit\n  one = unit\n\ninstance semiringProxy :: Semiring (Proxy a) where\n  add _ _ = Proxy\n  mul _ _ = Proxy\n  one = Proxy\n  zero = Proxy\n\ninstance semiringRecord :: (RL.RowToList row list, SemiringRecord list row row) => Semiring (Record row) where\n  add = addRecord (Proxy :: Proxy list)\n  mul = mulRecord (Proxy :: Proxy list)\n  one = oneRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  zero = zeroRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n\nforeign import intAdd :: Int -> Int -> Int\nforeign import intMul :: Int -> Int -> Int\nforeign import numAdd :: Number -> Number -> Number\nforeign import numMul :: Number -> Number -> Number\n\n-- | A class for records where all fields have `Semiring` instances, used to\n-- | implement the `Semiring` instance for records.\nclass SemiringRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemiringRecord rowlist row subrow | rowlist -> subrow where\n  addRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  mulRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  oneRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  zeroRecord :: Proxy rowlist -> Proxy row -> Record subrow\n\ninstance semiringRecordNil :: SemiringRecord RL.Nil row () where\n  addRecord _ _ _ = {}\n  mulRecord _ _ _ = {}\n  oneRecord _ _ = {}\n  zeroRecord _ _ = {}\n\ninstance semiringRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , SemiringRecord rowlistTail row subrowTail\n  , Semiring focus\n  ) =>\n  SemiringRecord (RL.Cons key focus rowlistTail) row subrow where\n  addRecord _ ra rb = insert (get ra + get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = addRecord (Proxy :: Proxy rowlistTail) ra rb\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  mulRecord _ ra rb = insert (get ra * get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = mulRecord (Proxy :: Proxy rowlistTail) ra rb\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  oneRecord _ _ = insert one tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    tail = oneRecord (Proxy :: Proxy rowlistTail) (Proxy :: Proxy row)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  zeroRecord _ _ = insert zero tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    tail = zeroRecord (Proxy :: Proxy rowlistTail) (Proxy :: Proxy row)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n", "module Data.Ord\n  ( class Ord\n  , compare\n  , class Ord1\n  , compare1\n  , lessThan\n  , (<)\n  , lessThanOrEq\n  , (<=)\n  , greaterThan\n  , (>)\n  , greaterThanOrEq\n  , (>=)\n  , comparing\n  , min\n  , max\n  , clamp\n  , between\n  , abs\n  , signum\n  , module Data.Ordering\n  , class OrdRecord\n  , compareRecord\n  ) where\n\nimport Data.Eq (class Eq, class Eq1, class EqRecord, (/=))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Ordering (Ordering(..))\nimport Data.Ring (class Ring, zero, one, negate)\nimport Data.Unit (Unit)\nimport Data.Void (Void)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Ord` type class represents types which support comparisons with a\n-- | _total order_.\n-- |\n-- | `Ord` instances should satisfy the laws of total orderings:\n-- |\n-- | - Reflexivity: `a <= a`\n-- | - Antisymmetry: if `a <= b` and `b <= a` then `a == b`\n-- | - Transitivity: if `a <= b` and `b <= c` then `a <= c`\n-- |\n-- | **Note:** The `Number` type is not an entirely law abiding member of this\n-- | class due to the presence of `NaN`, since `NaN <= NaN` evaluates to `false`\nclass Eq a <= Ord a where\n  compare :: a -> a -> Ordering\n\ninstance ordBoolean :: Ord Boolean where\n  compare = ordBooleanImpl LT EQ GT\n\ninstance ordInt :: Ord Int where\n  compare = ordIntImpl LT EQ GT\n\ninstance ordNumber :: Ord Number where\n  compare = ordNumberImpl LT EQ GT\n\ninstance ordString :: Ord String where\n  compare = ordStringImpl LT EQ GT\n\ninstance ordChar :: Ord Char where\n  compare = ordCharImpl LT EQ GT\n\ninstance ordUnit :: Ord Unit where\n  compare _ _ = EQ\n\ninstance ordVoid :: Ord Void where\n  compare _ _ = EQ\n\ninstance ordProxy :: Ord (Proxy a) where\n  compare _ _ = EQ\n\ninstance ordArray :: Ord a => Ord (Array a) where\n  compare = \\xs ys -> compare 0 (ordArrayImpl toDelta xs ys)\n    where\n    toDelta x y =\n      case compare x y of\n        EQ -> 0\n        LT -> 1\n        GT -> -1\n\nforeign import ordBooleanImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Boolean\n  -> Boolean\n  -> Ordering\n\nforeign import ordIntImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Int\n  -> Int\n  -> Ordering\n\nforeign import ordNumberImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Number\n  -> Number\n  -> Ordering\n\nforeign import ordStringImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> String\n  -> String\n  -> Ordering\n\nforeign import ordCharImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Char\n  -> Char\n  -> Ordering\n\nforeign import ordArrayImpl :: forall a. (a -> a -> Int) -> Array a -> Array a -> Int\n\ninstance ordOrdering :: Ord Ordering where\n  compare LT LT = EQ\n  compare EQ EQ = EQ\n  compare GT GT = EQ\n  compare LT _ = LT\n  compare EQ LT = GT\n  compare EQ GT = LT\n  compare GT _ = GT\n\n-- | Test whether one value is _strictly less than_ another.\nlessThan :: forall a. Ord a => a -> a -> Boolean\nlessThan a1 a2 = case a1 `compare` a2 of\n  LT -> true\n  _ -> false\n\n-- | Test whether one value is _strictly greater than_ another.\ngreaterThan :: forall a. Ord a => a -> a -> Boolean\ngreaterThan a1 a2 = case a1 `compare` a2 of\n  GT -> true\n  _ -> false\n\n-- | Test whether one value is _non-strictly less than_ another.\nlessThanOrEq :: forall a. Ord a => a -> a -> Boolean\nlessThanOrEq a1 a2 = case a1 `compare` a2 of\n  GT -> false\n  _ -> true\n\n-- | Test whether one value is _non-strictly greater than_ another.\ngreaterThanOrEq :: forall a. Ord a => a -> a -> Boolean\ngreaterThanOrEq a1 a2 = case a1 `compare` a2 of\n  LT -> false\n  _ -> true\n\ninfixl 4 lessThan as <\ninfixl 4 lessThanOrEq as <=\ninfixl 4 greaterThan as >\ninfixl 4 greaterThanOrEq as >=\n\n-- | Compares two values by mapping them to a type with an `Ord` instance.\ncomparing :: forall a b. Ord b => (a -> b) -> (a -> a -> Ordering)\ncomparing f x y = compare (f x) (f y)\n\n-- | Take the minimum of two values. If they are considered equal, the first\n-- | argument is chosen.\nmin :: forall a. Ord a => a -> a -> a\nmin x y =\n  case compare x y of\n    LT -> x\n    EQ -> x\n    GT -> y\n\n-- | Take the maximum of two values. If they are considered equal, the first\n-- | argument is chosen.\nmax :: forall a. Ord a => a -> a -> a\nmax x y =\n  case compare x y of\n    LT -> y\n    EQ -> x\n    GT -> x\n\n-- | Clamp a value between a minimum and a maximum. For example:\n-- |\n-- | ``` purescript\n-- | let f = clamp 0 10\n-- | f (-5) == 0\n-- | f 5    == 5\n-- | f 15   == 10\n-- | ```\nclamp :: forall a. Ord a => a -> a -> a -> a\nclamp low hi x = min hi (max low x)\n\n-- | Test whether a value is between a minimum and a maximum (inclusive).\n-- | For example:\n-- |\n-- | ``` purescript\n-- | let f = between 0 10\n-- | f 0    == true\n-- | f (-5) == false\n-- | f 5    == true\n-- | f 10   == true\n-- | f 15   == false\n-- | ```\nbetween :: forall a. Ord a => a -> a -> a -> Boolean\nbetween low hi x\n  | x < low = false\n  | x > hi = false\n  | true = true\n\n-- | The absolute value function. `abs x` is defined as `if x >= zero then x\n-- | else negate x`.\nabs :: forall a. Ord a => Ring a => a -> a\nabs x = if x >= zero then x else negate x\n\n-- | The sign function; returns `one` if the argument is positive,\n-- | `negate one` if the argument is negative, or `zero` if the argument is `zero`.\n-- | For floating point numbers with signed zeroes, when called with a zero,\n-- | this function returns the argument in order to preserve the sign.\n-- | For any `x`, we should have `signum x * abs x == x`.\nsignum :: forall a. Ord a => Ring a => a -> a\nsignum x =\n  if x < zero then negate one\n  else if x > zero then one\n  else x\n\n-- | The `Ord1` type class represents totally ordered type constructors.\nclass Eq1 f <= Ord1 f where\n  compare1 :: forall a. Ord a => f a -> f a -> Ordering\n\ninstance ord1Array :: Ord1 Array where\n  compare1 = compare\n\nclass OrdRecord :: RL.RowList Type -> Row Type -> Constraint\nclass EqRecord rowlist row <= OrdRecord rowlist row where\n  compareRecord :: Proxy rowlist -> Record row -> Record row -> Ordering\n\ninstance ordRecordNil :: OrdRecord RL.Nil row where\n  compareRecord _ _ _ = EQ\n\ninstance ordRecordCons ::\n  ( OrdRecord rowlistTail row\n  , Row.Cons key focus rowTail row\n  , IsSymbol key\n  , Ord focus\n  ) =>\n  OrdRecord (RL.Cons key focus rowlistTail) row where\n  compareRecord _ ra rb =\n    if left /= EQ then left\n    else compareRecord (Proxy :: Proxy rowlistTail) ra rb\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    unsafeGet' = unsafeGet :: String -> Record row -> focus\n    left = unsafeGet' key ra `compare` unsafeGet' key rb\n\ninstance ordRecord ::\n  ( RL.RowToList row list\n  , OrdRecord list row\n  ) =>\n  Ord (Record row) where\n  compare = compareRecord (Proxy :: Proxy list)\n", "export const showIntImpl = function (n) {\n  return n.toString();\n};\n\nexport const showNumberImpl = function (n) {\n  var str = n.toString();\n  return isNaN(str + \".0\") ? str : str + \".0\";\n};\n\nexport const showCharImpl = function (c) {\n  var code = c.charCodeAt(0);\n  if (code < 0x20 || code === 0x7F) {\n    switch (c) {\n      case \"\\x07\": return \"'\\\\a'\";\n      case \"\\b\": return \"'\\\\b'\";\n      case \"\\f\": return \"'\\\\f'\";\n      case \"\\n\": return \"'\\\\n'\";\n      case \"\\r\": return \"'\\\\r'\";\n      case \"\\t\": return \"'\\\\t'\";\n      case \"\\v\": return \"'\\\\v'\";\n    }\n    return \"'\\\\\" + code.toString(10) + \"'\";\n  }\n  return c === \"'\" || c === \"\\\\\" ? \"'\\\\\" + c + \"'\" : \"'\" + c + \"'\";\n};\n\nexport const showStringImpl = function (s) {\n  var l = s.length;\n  return \"\\\"\" + s.replace(\n    /[\\0-\\x1F\\x7F\"\\\\]/g, // eslint-disable-line no-control-regex\n    function (c, i) {\n      switch (c) {\n        case \"\\\"\":\n        case \"\\\\\":\n          return \"\\\\\" + c;\n        case \"\\x07\": return \"\\\\a\";\n        case \"\\b\": return \"\\\\b\";\n        case \"\\f\": return \"\\\\f\";\n        case \"\\n\": return \"\\\\n\";\n        case \"\\r\": return \"\\\\r\";\n        case \"\\t\": return \"\\\\t\";\n        case \"\\v\": return \"\\\\v\";\n      }\n      var k = i + 1;\n      var empty = k < l && s[k] >= \"0\" && s[k] <= \"9\" ? \"\\\\&\" : \"\";\n      return \"\\\\\" + c.charCodeAt(0).toString(10) + empty;\n    }\n  ) + \"\\\"\";\n};\n\nexport const showArrayImpl = function (f) {\n  return function (xs) {\n    var ss = [];\n    for (var i = 0, l = xs.length; i < l; i++) {\n      ss[i] = f(xs[i]);\n    }\n    return \"[\" + ss.join(\",\") + \"]\";\n  };\n};\n", "module Data.Show\n  ( class Show\n  , show\n  , class ShowRecordFields\n  , showRecordFields\n  ) where\n\nimport Data.Semigroup ((<>))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit)\nimport Data.Void (Void, absurd)\nimport Prim.Row (class Nub)\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Show` type class represents those types which can be converted into\n-- | a human-readable `String` representation.\n-- |\n-- | While not required, it is recommended that for any expression `x`, the\n-- | string `show x` be executable PureScript code which evaluates to the same\n-- | value as the expression `x`.\nclass Show a where\n  show :: a -> String\n\ninstance showUnit :: Show Unit where\n  show _ = \"unit\"\n\ninstance showBoolean :: Show Boolean where\n  show true = \"true\"\n  show false = \"false\"\n\ninstance showInt :: Show Int where\n  show = showIntImpl\n\ninstance showNumber :: Show Number where\n  show = showNumberImpl\n\ninstance showChar :: Show Char where\n  show = showCharImpl\n\ninstance showString :: Show String where\n  show = showStringImpl\n\ninstance showArray :: Show a => Show (Array a) where\n  show = showArrayImpl show\n\ninstance showProxy :: Show (Proxy a) where\n  show _ = \"Proxy\"\n\ninstance showVoid :: Show Void where\n  show = absurd\n\ninstance showRecord ::\n  ( Nub rs rs\n  , RL.RowToList rs ls\n  , ShowRecordFields ls rs\n  ) =>\n  Show (Record rs) where\n  show record = \"{\" <> showRecordFields (Proxy :: Proxy ls) record <> \"}\"\n\n-- | A class for records where all fields have `Show` instances, used to\n-- | implement the `Show` instance for records.\nclass ShowRecordFields :: RL.RowList Type -> Row Type -> Constraint\nclass ShowRecordFields rowlist row where\n  showRecordFields :: Proxy rowlist -> Record row -> String\n\ninstance showRecordFieldsNil :: ShowRecordFields RL.Nil row where\n  showRecordFields _ _ = \"\"\nelse\ninstance showRecordFieldsConsNil ::\n  ( IsSymbol key\n  , Show focus\n  ) =>\n  ShowRecordFields (RL.Cons key focus RL.Nil) row where\n  showRecordFields _ record = \" \" <> key <> \": \" <> show focus <> \" \"\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    focus = unsafeGet key record :: focus\nelse\ninstance showRecordFieldsCons ::\n  ( IsSymbol key\n  , ShowRecordFields rowlistTail row\n  , Show focus\n  ) =>\n  ShowRecordFields (RL.Cons key focus rowlistTail) row where\n  showRecordFields _ record = \" \" <> key <> \": \" <> show focus <> \",\" <> tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    focus = unsafeGet key record :: focus\n    tail = showRecordFields (Proxy :: Proxy rowlistTail) record\n\nforeign import showIntImpl :: Int -> String\nforeign import showNumberImpl :: Number -> String\nforeign import showCharImpl :: Char -> String\nforeign import showStringImpl :: String -> String\nforeign import showArrayImpl :: forall a. (a -> String) -> Array a -> String\n", "module Data.Maybe where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Extend (class Extend)\nimport Control.Plus (class Plus)\n\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.Ord (class Ord1)\n\n-- | The `Maybe` type is used to represent optional values and can be seen as\n-- | something like a type-safe `null`, where `Nothing` is `null` and `Just x`\n-- | is the non-null value `x`.\ndata Maybe a = Nothing | Just a\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Just` with the `<$>` operator:\n-- |\n-- | ``` purescript\n-- | f <$> Just x == Just (f x)\n-- | ```\n-- |\n-- | `Nothing` values are left untouched:\n-- |\n-- | ``` purescript\n-- | f <$> Nothing == Nothing\n-- | ```\ninstance functorMaybe :: Functor Maybe where\n  map fn (Just x) = Just (fn x)\n  map _  _        = Nothing\n\n-- | The `Apply` instance allows functions contained within a `Just` to\n-- | transform a value contained within a `Just` using the `apply` operator:\n-- |\n-- | ``` purescript\n-- | Just f <*> Just x == Just (f x)\n-- | ```\n-- |\n-- | `Nothing` values are left untouched:\n-- |\n-- | ``` purescript\n-- | Just f <*> Nothing == Nothing\n-- | Nothing <*> Just x == Nothing\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used transform a\n-- | pure function to take `Maybe`-typed arguments so `f :: a -> b -> c`\n-- | becomes `f :: Maybe a -> Maybe b -> Maybe c`:\n-- |\n-- | ``` purescript\n-- | f <$> Just x <*> Just y == Just (f x y)\n-- | ```\n-- |\n-- | The `Nothing`-preserving behaviour of both operators means the result of\n-- | an expression like the above but where any one of the values is `Nothing`\n-- | means the whole result becomes `Nothing` also:\n-- |\n-- | ``` purescript\n-- | f <$> Nothing <*> Just y == Nothing\n-- | f <$> Just x <*> Nothing == Nothing\n-- | f <$> Nothing <*> Nothing == Nothing\n-- | ```\ninstance applyMaybe :: Apply Maybe where\n  apply (Just fn) x = fn <$> x\n  apply Nothing   _ = Nothing\n\n-- | The `Applicative` instance enables lifting of values into `Maybe` with the\n-- | `pure` function:\n-- |\n-- | ``` purescript\n-- | pure x :: Maybe _ == Just x\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s\n-- | `pure` can be used to pass a mixture of `Maybe` and non-`Maybe` typed\n-- | values to a function that does not usually expect them, by using `pure`\n-- | for any value that is not already `Maybe` typed:\n-- |\n-- | ``` purescript\n-- | f <$> Just x <*> pure y == Just (f x y)\n-- | ```\n-- |\n-- | Even though `pure = Just` it is recommended to use `pure` in situations\n-- | like this as it allows the choice of `Applicative` to be changed later\n-- | without having to go through and replace `Just` with a new constructor.\ninstance applicativeMaybe :: Applicative Maybe where\n  pure = Just\n\n-- | The `Alt` instance allows for a choice to be made between two `Maybe`\n-- | values with the `<|>` operator, where the first `Just` encountered\n-- | is taken.\n-- |\n-- | ``` purescript\n-- | Just x <|> Just y == Just x\n-- | Nothing <|> Just y == Just y\n-- | Nothing <|> Nothing == Nothing\n-- | ```\ninstance altMaybe :: Alt Maybe where\n  alt Nothing r = r\n  alt l       _ = l\n\n-- | The `Plus` instance provides a default `Maybe` value:\n-- |\n-- | ``` purescript\n-- | empty :: Maybe _ == Nothing\n-- | ```\ninstance plusMaybe :: Plus Maybe where\n  empty = Nothing\n\n-- | The `Alternative` instance guarantees that there are both `Applicative` and\n-- | `Plus` instances for `Maybe`.\ninstance alternativeMaybe :: Alternative Maybe\n\n-- | The `Bind` instance allows sequencing of `Maybe` values and functions that\n-- | return a `Maybe` by using the `>>=` operator:\n-- |\n-- | ``` purescript\n-- | Just x >>= f = f x\n-- | Nothing >>= f = Nothing\n-- | ```\ninstance bindMaybe :: Bind Maybe where\n  bind (Just x) k = k x\n  bind Nothing  _ = Nothing\n\n-- | The `Monad` instance guarantees that there are both `Applicative` and\n-- | `Bind` instances for `Maybe`. This also enables the `do` syntactic sugar:\n-- |\n-- | ``` purescript\n-- | do\n-- |   x' <- x\n-- |   y' <- y\n-- |   pure (f x' y')\n-- | ```\n-- |\n-- | Which is equivalent to:\n-- |\n-- | ``` purescript\n-- | x >>= (\\x' -> y >>= (\\y' -> pure (f x' y')))\n-- | ```\n-- |\n-- | Which is equivalent to:\n-- |\n-- | ``` purescript\n-- | case x of\n-- |   Nothing -> Nothing\n-- |   Just x' -> case y of\n-- |     Nothing -> Nothing\n-- |     Just y' -> Just (f x' y')\n-- | ```\ninstance monadMaybe :: Monad Maybe\n\n-- | The `Extend` instance allows sequencing of `Maybe` values and functions\n-- | that accept a `Maybe a` and return a non-`Maybe` result using the\n-- | `<<=` operator.\n-- |\n-- | ``` purescript\n-- | f <<= Nothing = Nothing\n-- | f <<= x = Just (f x)\n-- | ```\ninstance extendMaybe :: Extend Maybe where\n  extend _ Nothing  = Nothing\n  extend f x        = Just (f x)\n\ninstance invariantMaybe :: Invariant Maybe where\n  imap = imapF\n\n-- | The `Semigroup` instance enables use of the operator `<>` on `Maybe` values\n-- | whenever there is a `Semigroup` instance for the type the `Maybe` contains.\n-- | The exact behaviour of `<>` depends on the \"inner\" `Semigroup` instance,\n-- | but generally captures the notion of appending or combining things.\n-- |\n-- | ``` purescript\n-- | Just x <> Just y = Just (x <> y)\n-- | Just x <> Nothing = Just x\n-- | Nothing <> Just y = Just y\n-- | Nothing <> Nothing = Nothing\n-- | ```\ninstance semigroupMaybe :: Semigroup a => Semigroup (Maybe a) where\n  append Nothing y = y\n  append x Nothing = x\n  append (Just x) (Just y) = Just (x <> y)\n\ninstance monoidMaybe :: Semigroup a => Monoid (Maybe a) where\n  mempty = Nothing\n\ninstance semiringMaybe :: Semiring a => Semiring (Maybe a) where\n  zero = Nothing\n  one = Just one\n\n  add Nothing y = y\n  add x Nothing = x\n  add (Just x) (Just y) = Just (add x y)\n\n  mul x y = mul <$> x <*> y\n\n-- | The `Eq` instance allows `Maybe` values to be checked for equality with\n-- | `==` and inequality with `/=` whenever there is an `Eq` instance for the\n-- | type the `Maybe` contains.\nderive instance eqMaybe :: Eq a => Eq (Maybe a)\n\ninstance eq1Maybe :: Eq1 Maybe where eq1 = eq\n\n-- | The `Ord` instance allows `Maybe` values to be compared with\n-- | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for\n-- | the type the `Maybe` contains.\n-- |\n-- | `Nothing` is considered to be less than any `Just` value.\nderive instance ordMaybe :: Ord a => Ord (Maybe a)\n\ninstance ord1Maybe :: Ord1 Maybe where compare1 = compare\n\ninstance boundedMaybe :: Bounded a => Bounded (Maybe a) where\n  top = Just top\n  bottom = Nothing\n\n-- | The `Show` instance allows `Maybe` values to be rendered as a string with\n-- | `show` whenever there is an `Show` instance for the type the `Maybe`\n-- | contains.\ninstance showMaybe :: Show a => Show (Maybe a) where\n  show (Just x) = \"(Just \" <> show x <> \")\"\n  show Nothing  = \"Nothing\"\n\nderive instance genericMaybe :: Generic (Maybe a) _\n\n-- | Takes a default value, a function, and a `Maybe` value. If the `Maybe`\n-- | value is `Nothing` the default value is returned, otherwise the function\n-- | is applied to the value inside the `Just` and the result is returned.\n-- |\n-- | ``` purescript\n-- | maybe x f Nothing == x\n-- | maybe x f (Just y) == f y\n-- | ```\nmaybe :: forall a b. b -> (a -> b) -> Maybe a -> b\nmaybe b _ Nothing = b\nmaybe _ f (Just a) = f a\n\n-- | Similar to `maybe` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `maybe` has\n-- | to evaluate the default value before returning the result, whereas here\n-- | the value is only computed when the `Maybe` is known to be `Nothing`.\n-- |\n-- | ``` purescript\n-- | maybe' (\\_ -> x) f Nothing == x\n-- | maybe' (\\_ -> x) f (Just y) == f y\n-- | ```\nmaybe' :: forall a b. (Unit -> b) -> (a -> b) -> Maybe a -> b\nmaybe' g _ Nothing = g unit\nmaybe' _ f (Just a) = f a\n\n-- | Takes a default value, and a `Maybe` value. If the `Maybe` value is\n-- | `Nothing` the default value is returned, otherwise the value inside the\n-- | `Just` is returned.\n-- |\n-- | ``` purescript\n-- | fromMaybe x Nothing == x\n-- | fromMaybe x (Just y) == y\n-- | ```\nfromMaybe :: forall a. a -> Maybe a -> a\nfromMaybe a = maybe a identity\n\n-- | Similar to `fromMaybe` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromMaybe`\n-- | has to evaluate the default value before returning the result, whereas here\n-- | the value is only computed when the `Maybe` is known to be `Nothing`.\n-- |\n-- | ``` purescript\n-- | fromMaybe' (\\_ -> x) Nothing == x\n-- | fromMaybe' (\\_ -> x) (Just y) == y\n-- | ```\nfromMaybe' :: forall a. (Unit -> a) -> Maybe a -> a\nfromMaybe' a = maybe' a identity\n\n-- | Returns `true` when the `Maybe` value was constructed with `Just`.\nisJust :: forall a. Maybe a -> Boolean\nisJust = maybe false (const true)\n\n-- | Returns `true` when the `Maybe` value is `Nothing`.\nisNothing :: forall a. Maybe a -> Boolean\nisNothing = maybe true (const false)\n\n-- | A partial function that extracts the value from the `Just` data\n-- | constructor. Passing `Nothing` to `fromJust` will throw an error at\n-- | runtime.\nfromJust :: forall a. Partial => Maybe a -> a\nfromJust (Just x) = x\n\n-- | One or none.\n-- |\n-- | ```purescript\n-- | optional empty = pure Nothing\n-- | ```\n-- |\n-- | The behaviour of `optional (pure x)` depends on whether the `Alt` instance\n-- | satisfy the left catch law (`pure a <|> b = pure a`).\n-- |\n-- | `Either e` does:\n-- |\n-- | ```purescript\n-- | optional (Right x) = Right (Just x)\n-- | ```\n-- |\n-- | But `Array` does not:\n-- |\n-- | ```purescript\n-- | optional [x] = [Just x, Nothing]\n-- | ```\noptional :: forall f a. Alt f => Applicative f => f a -> f (Maybe a)\noptional a = map Just a <|> pure Nothing\n", "module Data.Either where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Extend (class Extend)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.Maybe (Maybe(..), maybe, maybe')\nimport Data.Ord (class Ord1)\n\n-- | The `Either` type is used to represent a choice between two types of value.\n-- |\n-- | A common use case for `Either` is error handling, where `Left` is used to\n-- | carry an error value and `Right` is used to carry a success value.\ndata Either a b = Left a | Right b\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Right` with the `<$>` operator:\n-- |\n-- | ``` purescript\n-- | f <$> Right x == Right (f x)\n-- | ```\n-- |\n-- | `Left` values are untouched:\n-- |\n-- | ``` purescript\n-- | f <$> Left y == Left y\n-- | ```\nderive instance functorEither :: Functor (Either a)\n\nderive instance genericEither :: Generic (Either a b) _\n\ninstance invariantEither :: Invariant (Either a) where\n  imap = imapF\n\n-- | The `Apply` instance allows functions contained within a `Right` to\n-- | transform a value contained within a `Right` using the `(<*>)` operator:\n-- |\n-- | ``` purescript\n-- | Right f <*> Right x == Right (f x)\n-- | ```\n-- |\n-- | `Left` values are left untouched:\n-- |\n-- | ``` purescript\n-- | Left f <*> Right x == Left f\n-- | Right f <*> Left y == Left y\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used to transform a\n-- | pure function to take `Either`-typed arguments so `f :: a -> b -> c`\n-- | becomes `f :: Either l a -> Either l b -> Either l c`:\n-- |\n-- | ``` purescript\n-- | f <$> Right x <*> Right y == Right (f x y)\n-- | ```\n-- |\n-- | The `Left`-preserving behaviour of both operators means the result of\n-- | an expression like the above but where any one of the values is `Left`\n-- | means the whole result becomes `Left` also, taking the first `Left` value\n-- | found:\n-- |\n-- | ``` purescript\n-- | f <$> Left x <*> Right y == Left x\n-- | f <$> Right x <*> Left y == Left y\n-- | f <$> Left x <*> Left y == Left x\n-- | ```\ninstance applyEither :: Apply (Either e) where\n  apply (Left e) _ = Left e\n  apply (Right f) r = f <$> r\n\n-- | The `Applicative` instance enables lifting of values into `Either` with the\n-- | `pure` function:\n-- |\n-- | ``` purescript\n-- | pure x :: Either _ _ == Right x\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s\n-- | `pure` can be used to pass a mixture of `Either` and non-`Either` typed\n-- | values to a function that does not usually expect them, by using `pure`\n-- | for any value that is not already `Either` typed:\n-- |\n-- | ``` purescript\n-- | f <$> Right x <*> pure y == Right (f x y)\n-- | ```\n-- |\n-- | Even though `pure = Right` it is recommended to use `pure` in situations\n-- | like this as it allows the choice of `Applicative` to be changed later\n-- | without having to go through and replace `Right` with a new constructor.\ninstance applicativeEither :: Applicative (Either e) where\n  pure = Right\n\n-- | The `Alt` instance allows for a choice to be made between two `Either`\n-- | values with the `<|>` operator, where the first `Right` encountered\n-- | is taken.\n-- |\n-- | ``` purescript\n-- | Right x <|> Right y == Right x\n-- | Left x <|> Right y == Right y\n-- | Left x <|> Left y == Left y\n-- | ```\ninstance altEither :: Alt (Either e) where\n  alt (Left _) r = r\n  alt l        _ = l\n\n-- | The `Bind` instance allows sequencing of `Either` values and functions that\n-- | return an `Either` by using the `>>=` operator:\n-- |\n-- | ``` purescript\n-- | Left x >>= f = Left x\n-- | Right x >>= f = f x\n-- | ```\n-- |\n-- | `Either`'s \"do notation\" can be understood to work like this:\n-- | ``` purescript\n-- | x :: forall e a. Either e a\n-- | x = --\n-- |\n-- | y :: forall e b. Either e b\n-- | y = --\n-- |\n-- | foo :: forall e a. (a -> b -> c) -> Either e c\n-- | foo f = do\n-- |   x' <- x\n-- |   y' <- y\n-- |   pure (f x' y')\n-- | ```\n-- |\n-- | ...which is equivalent to...\n-- |\n-- | ``` purescript\n-- | x >>= (\\x' -> y >>= (\\y' -> pure (f x' y')))\n-- | ```\n-- |\n-- | ...and is the same as writing...\n-- |\n-- | ```\n-- | foo :: forall e a. (a -> b -> c) -> Either e c\n-- | foo f = case x of\n-- |   Left e ->\n-- |     Left e\n-- |   Right x -> case y of\n-- |     Left e ->\n-- |       Left e\n-- |     Right y ->\n-- |       Right (f x y)\n-- | ```\ninstance bindEither :: Bind (Either e) where\n  bind = either (\\e _ -> Left e) (\\a f -> f a)\n\n-- | The `Monad` instance guarantees that there are both `Applicative` and\n-- | `Bind` instances for `Either`.\ninstance monadEither :: Monad (Either e)\n\n-- | The `Extend` instance allows sequencing of `Either` values and functions\n-- | that accept an `Either` and return a non-`Either` result using the\n-- | `<<=` operator.\n-- |\n-- | ``` purescript\n-- | f <<= Left x = Left x\n-- | f <<= Right x = Right (f (Right x))\n-- | ```\ninstance extendEither :: Extend (Either e) where\n  extend _ (Left y)  = Left y\n  extend f x         = Right (f x)\n\n-- | The `Show` instance allows `Either` values to be rendered as a string with\n-- | `show` whenever there is an `Show` instance for both type the `Either` can\n-- | contain.\ninstance showEither :: (Show a, Show b) => Show (Either a b) where\n  show (Left x) = \"(Left \" <> show x <> \")\"\n  show (Right y) = \"(Right \" <> show y <> \")\"\n\n-- | The `Eq` instance allows `Either` values to be checked for equality with\n-- | `==` and inequality with `/=` whenever there is an `Eq` instance for both\n-- | types the `Either` can contain.\nderive instance eqEither :: (Eq a, Eq b) => Eq (Either a b)\n\nderive instance eq1Either :: Eq a => Eq1 (Either a)\n\n-- | The `Ord` instance allows `Either` values to be compared with\n-- | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for\n-- | both types the `Either` can contain.\n-- |\n-- | Any `Left` value is considered to be less than a `Right` value.\nderive instance ordEither :: (Ord a, Ord b) => Ord (Either a b)\n\nderive instance ord1Either :: Ord a => Ord1 (Either a)\n\ninstance boundedEither :: (Bounded a, Bounded b) => Bounded (Either a b) where\n  top = Right top\n  bottom = Left bottom\n\ninstance semigroupEither :: (Semigroup b) => Semigroup (Either a b) where\n  append x y = append <$> x <*> y\n\n-- | Takes two functions and an `Either` value, if the value is a `Left` the\n-- | inner value is applied to the first function, if the value is a `Right`\n-- | the inner value is applied to the second function.\n-- |\n-- | ``` purescript\n-- | either f g (Left x) == f x\n-- | either f g (Right y) == g y\n-- | ```\neither :: forall a b c. (a -> c) -> (b -> c) -> Either a b -> c\neither f _ (Left a) = f a\neither _ g (Right b) = g b\n\n-- | Combine two alternatives.\nchoose :: forall m a b. Alt m => m a -> m b -> m (Either a b)\nchoose a b = Left <$> a <|> Right <$> b\n\n-- | Returns `true` when the `Either` value was constructed with `Left`.\nisLeft :: forall a b. Either a b -> Boolean\nisLeft = either (const true) (const false)\n\n-- | Returns `true` when the `Either` value was constructed with `Right`.\nisRight :: forall a b. Either a b -> Boolean\nisRight = either (const false) (const true)\n\n-- | A function that extracts the value from the `Left` data constructor.\n-- | The first argument is a default value, which will be returned in the\n-- | case where a `Right` is passed to `fromLeft`.\nfromLeft :: forall a b. a -> Either a b -> a\nfromLeft _ (Left a) = a\nfromLeft default _ = default\n\n-- | Similar to `fromLeft` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromLeft`\n-- | has to evaluate the default value before returning the result,\n-- | whereas here the value is only computed when the `Either` is known\n-- | to be `Right`.\nfromLeft' :: forall a b. (Unit -> a) -> Either a b -> a\nfromLeft' _ (Left a) = a\nfromLeft' default _ = default unit\n\n-- | A function that extracts the value from the `Right` data constructor.\n-- | The first argument is a default value, which will be returned in the\n-- | case where a `Left` is passed to `fromRight`.\nfromRight :: forall a b. b -> Either a b -> b\nfromRight _ (Right b) = b\nfromRight default _ = default\n\n-- | Similar to `fromRight` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromRight`\n-- | has to evaluate the default value before returning the result,\n-- | whereas here the value is only computed when the `Either` is known\n-- | to be `Left`.\nfromRight' :: forall a b. (Unit -> b) -> Either a b -> b\nfromRight' _ (Right b) = b\nfromRight' default _ = default unit\n\n-- | Takes a default and a `Maybe` value, if the value is a `Just`, turn it into\n-- | a `Right`, if the value is a `Nothing` use the provided default as a `Left`\n-- |\n-- | ```purescript\n-- | note \"default\" Nothing = Left \"default\"\n-- | note \"default\" (Just 1) = Right 1\n-- | ```\nnote :: forall a b. a -> Maybe b -> Either a b\nnote a = maybe (Left a) Right\n\n-- | Similar to `note`, but for use in cases where the default value may be\n-- | expensive to compute.\n-- |\n-- | ```purescript\n-- | note' (\\_ -> \"default\") Nothing = Left \"default\"\n-- | note' (\\_ -> \"default\") (Just 1) = Right 1\n-- | ```\nnote' :: forall a b. (Unit -> a) -> Maybe b -> Either a b\nnote' f = maybe' (Left <<< f) Right\n\n-- | Turns an `Either` into a `Maybe`, by throwing potential `Left` values away and converting\n-- | them into `Nothing`. `Right` values get turned into `Just`s.\n-- |\n-- | ```purescript\n-- | hush (Left \"ParseError\") = Nothing\n-- | hush (Right 42) = Just 42\n-- | ```\nhush :: forall a b. Either a b -> Maybe b\nhush = either (const Nothing) Just\n\n-- | Turns an `Either` into a `Maybe`, by throwing potential `Right` values away and converting\n-- | them into `Nothing`. `Left` values get turned into `Just`s.\n-- |\n-- | ```purescript\n-- | blush (Left \"ParseError\") = Just \"Parse Error\"\n-- | blush (Right 42) = Nothing\n-- | ```\nblush :: forall a b. Either a b -> Maybe a\nblush = either Just (const Nothing)\n", "module Data.Monoid\n  ( class Monoid\n  , mempty\n  , power\n  , guard\n  , module Data.Semigroup\n  , class MonoidRecord\n  , memptyRecord\n  ) where\n\nimport Data.Boolean (otherwise)\nimport Data.Eq ((==))\nimport Data.EuclideanRing (mod, (/))\nimport Data.Ord ((<=))\nimport Data.Ordering (Ordering(..))\nimport Data.Semigroup (class Semigroup, class SemigroupRecord, (<>))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | A `Monoid` is a `Semigroup` with a value `mempty`, which is both a\n-- | left and right unit for the associative operation `<>`:\n-- |\n-- | - Left unit: `(mempty <> x) = x`\n-- | - Right unit: `(x <> mempty) = x`\n-- |\n-- | `Monoid`s are commonly used as the result of fold operations, where\n-- | `<>` is used to combine individual results, and `mempty` gives the result\n-- | of folding an empty collection of elements.\n-- |\n-- | ### Newtypes for Monoid\n-- |\n-- | Some types (e.g. `Int`, `Boolean`) can implement multiple law-abiding\n-- | instances for `Monoid`. Let's use `Int` as an example\n-- | 1. `<>` could be `+` and `mempty` could be `0`\n-- | 2. `<>` could be `*` and `mempty` could be `1`.\n-- |\n-- | To clarify these ambiguous situations, one should use the newtypes\n-- | defined in `Data.Monoid.<NewtypeName>` modules.\n-- |\n-- | In the above ambiguous situation, we could use `Additive`\n-- | for the first situation or `Multiplicative` for the second one.\nclass Semigroup m <= Monoid m where\n  mempty :: m\n\ninstance monoidUnit :: Monoid Unit where\n  mempty = unit\n\ninstance monoidOrdering :: Monoid Ordering where\n  mempty = EQ\n\ninstance monoidFn :: Monoid b => Monoid (a -> b) where\n  mempty _ = mempty\n\ninstance monoidString :: Monoid String where\n  mempty = \"\"\n\ninstance monoidArray :: Monoid (Array a) where\n  mempty = []\n\ninstance monoidRecord :: (RL.RowToList row list, MonoidRecord list row row) => Monoid (Record row) where\n  mempty = memptyRecord (Proxy :: Proxy list)\n\n-- | Append a value to itself a certain number of times. For the\n-- | `Multiplicative` type, and for a non-negative power, this is the same as\n-- | normal number exponentiation.\n-- |\n-- | If the second argument is negative this function will return `mempty`\n-- | (*unlike* normal number exponentiation). The `Monoid` constraint alone\n-- | is not enough to write a `power` function with the property that `power x\n-- | n` cancels with `power x (-n)`, i.e. `power x n <> power x (-n) = mempty`.\n-- | For that, we would additionally need the ability to invert elements, i.e.\n-- | a Group.\n-- |\n-- | ```purescript\n-- | power [1,2] 3    == [1,2,1,2,1,2]\n-- | power [1,2] 1    == [1,2]\n-- | power [1,2] 0    == []\n-- | power [1,2] (-3) == []\n-- | ```\n-- |\npower :: forall m. Monoid m => m -> Int -> m\npower x = go\n  where\n  go :: Int -> m\n  go p\n    | p <= 0 = mempty\n    | p == 1 = x\n    | p `mod` 2 == 0 = let x' = go (p / 2) in x' <> x'\n    | otherwise = let x' = go (p / 2) in x' <> x' <> x\n\n-- | Allow or \"truncate\" a Monoid to its `mempty` value based on a condition.\nguard :: forall m. Monoid m => Boolean -> m -> m\nguard true a = a\nguard false _ = mempty\n\n-- | A class for records where all fields have `Monoid` instances, used to\n-- | implement the `Monoid` instance for records.\nclass MonoidRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemigroupRecord rowlist row subrow <= MonoidRecord rowlist row subrow | rowlist -> row subrow where\n  memptyRecord :: Proxy rowlist -> Record subrow\n\ninstance monoidRecordNil :: MonoidRecord RL.Nil row () where\n  memptyRecord _ = {}\n\ninstance monoidRecordCons ::\n  ( IsSymbol key\n  , Monoid focus\n  , Row.Cons key focus subrowTail subrow\n  , MonoidRecord rowlistTail row subrowTail\n  ) =>\n  MonoidRecord (RL.Cons key focus rowlistTail) row subrow where\n  memptyRecord _ = insert mempty tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = memptyRecord (Proxy :: Proxy rowlistTail)\n", "export const pureE = function (a) {\n  return function () {\n    return a;\n  };\n};\n\nexport const bindE = function (a) {\n  return function (f) {\n    return function () {\n      return f(a())();\n    };\n  };\n};\n\nexport const untilE = function (f) {\n  return function () {\n    while (!f());\n  };\n};\n\nexport const whileE = function (f) {\n  return function (a) {\n    return function () {\n      while (f()) {\n        a();\n      }\n    };\n  };\n};\n\nexport const forE = function (lo) {\n  return function (hi) {\n    return function (f) {\n      return function () {\n        for (var i = lo; i < hi; i++) {\n          f(i)();\n        }\n      };\n    };\n  };\n};\n\nexport const foreachE = function (as) {\n  return function (f) {\n    return function () {\n      for (var i = 0, l = as.length; i < l; i++) {\n        f(as[i])();\n      }\n    };\n  };\n};\n", "-- | This module provides the `Effect` type, which is used to represent\n-- | _native_ effects. The `Effect` type provides a typed API for effectful\n-- | computations, while at the same time generating efficient JavaScript.\nmodule Effect\n  ( Effect\n  , untilE, whileE, forE, foreachE\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\n\n-- | A native effect. The type parameter denotes the return type of running the\n-- | effect, that is, an `Effect Int` is a possibly-effectful computation which\n-- | eventually produces a value of the type `Int` when it finishes.\nforeign import data Effect :: Type -> Type\n\ntype role Effect representational\n\ninstance functorEffect :: Functor Effect where\n  map = liftA1\n\ninstance applyEffect :: Apply Effect where\n  apply = ap\n\ninstance applicativeEffect :: Applicative Effect where\n  pure = pureE\n\nforeign import pureE :: forall a. a -> Effect a\n\ninstance bindEffect :: Bind Effect where\n  bind = bindE\n\nforeign import bindE :: forall a b. Effect a -> (a -> Effect b) -> Effect b\n\ninstance monadEffect :: Monad Effect\n\n-- | The `Semigroup` instance for effects allows you to run two effects, one\n-- | after the other, and then combine their results using the result type's\n-- | `Semigroup` instance.\ninstance semigroupEffect :: Semigroup a => Semigroup (Effect a) where\n  append = lift2 append\n\n-- | If you have a `Monoid a` instance, then `mempty :: Effect a` is defined as\n-- | `pure mempty`.\ninstance monoidEffect :: Monoid a => Monoid (Effect a) where\n  mempty = pureE mempty\n\n-- | Loop until a condition becomes `true`.\n-- |\n-- | `untilE b` is an effectful computation which repeatedly runs the effectful\n-- | computation `b`, until its return value is `true`.\nforeign import untilE :: Effect Boolean -> Effect Unit\n\n-- | Loop while a condition is `true`.\n-- |\n-- | `whileE b m` is effectful computation which runs the effectful computation\n-- | `b`. If its result is `true`, it runs the effectful computation `m` and\n-- | loops. If not, the computation ends.\nforeign import whileE :: forall a. Effect Boolean -> Effect a -> Effect Unit\n\n-- | Loop over a consecutive collection of numbers.\n-- |\n-- | `forE lo hi f` runs the computation returned by the function `f` for each\n-- | of the inputs between `lo` (inclusive) and `hi` (exclusive).\nforeign import forE :: Int -> Int -> (Int -> Effect Unit) -> Effect Unit\n\n-- | Loop over an array of values.\n-- |\n-- | `foreachE xs f` runs the computation returned by the function `f` for each\n-- | of the inputs `xs`.\nforeign import foreachE :: forall a. Array a -> (a -> Effect Unit) -> Effect Unit\n", "export const _new = function (val) {\n  return function () {\n    return { value: val };\n  };\n};\n\nexport const newWithSelf = function (f) {\n  return function () {\n    var ref = { value: null };\n    ref.value = f(ref);\n    return ref;\n  };\n};\n\nexport const read = function (ref) {\n  return function () {\n    return ref.value;\n  };\n};\n\nexport const modifyImpl = function (f) {\n  return function (ref) {\n    return function () {\n      var t = f(ref.value);\n      ref.value = t.state;\n      return t.value;\n    };\n  };\n};\n\nexport const write = function (val) {\n  return function (ref) {\n    return function () {\n      ref.value = val;\n    };\n  };\n};\n", "-- | This module defines the `Ref` type for mutable value references, as well\n-- | as actions for working with them.\n-- |\n-- | You'll notice that all of the functions that operate on a `Ref` (e.g.\n-- | `new`, `read`, `write`) return their result wrapped in an `Effect`.\n-- | Working with mutable references is considered effectful in PureScript\n-- | because of the principle of purity: functions should not have side\n-- | effects, and should return the same result when called with the same\n-- | arguments. If a `Ref` could be written to without using `Effect`, that\n-- | would cause a side effect (the effect of changing the result of subsequent\n-- | reads for that `Ref`). If there were a function for reading the current\n-- | value of a `Ref` without the result being wrapped in `Effect`, the result\n-- | of calling that function would change each time a new value was written to\n-- | the `Ref`. Even creating a new `Ref` is effectful: if there were a\n-- | function for creating a new `Ref` with the type `forall s. s -> Ref s`,\n-- | then calling that function twice with the same argument would not give the\n-- | same result in each case, since you'd end up with two distinct references\n-- | which could be updated independently of each other.\n-- |\n-- | _Note_: `Control.Monad.ST` provides a pure alternative to `Ref` when\n-- | mutation is restricted to a local scope.\nmodule Effect.Ref\n  ( Ref\n  , new\n  , newWithSelf\n  , read\n  , modify'\n  , modify\n  , modify_\n  , write\n  ) where\n\nimport Prelude\n\nimport Effect (Effect)\n\n-- | A value of type `Ref a` represents a mutable reference\n-- | which holds a value of type `a`.\nforeign import data Ref :: Type -> Type\n\ntype role Ref representational\n\n-- | Create a new mutable reference containing the specified value.\nforeign import _new :: forall s. s -> Effect (Ref s)\n\nnew :: forall s. s -> Effect (Ref s)\nnew = _new\n\n-- | Create a new mutable reference containing a value that can refer to the\n-- | `Ref` being created.\nforeign import newWithSelf :: forall s. (Ref s -> s) -> Effect (Ref s)\n\n-- | Read the current value of a mutable reference.\nforeign import read :: forall s. Ref s -> Effect s\n\n-- | Update the value of a mutable reference by applying a function\n-- | to the current value.\nmodify' :: forall s b. (s -> { state :: s, value :: b }) -> Ref s -> Effect b\nmodify' = modifyImpl\n\nforeign import modifyImpl :: forall s b. (s -> { state :: s, value :: b }) -> Ref s -> Effect b\n\n-- | Update the value of a mutable reference by applying a function\n-- | to the current value. The updated value is returned.\nmodify :: forall s. (s -> s) -> Ref s -> Effect s\nmodify f = modify' \\s -> let s' = f s in { state: s', value: s' }\n\n-- | A version of `modify` which does not return the updated value.\nmodify_ :: forall s. (s -> s) -> Ref s -> Effect Unit\nmodify_ f s = void $ modify f s\n\n-- | Update the value of a mutable reference to the specified value.\nforeign import write :: forall s. s -> Ref s -> Effect Unit\n", "module Control.Monad.Rec.Class\n  ( Step(..)\n  , class MonadRec\n  , tailRec\n  , tailRec2\n  , tailRec3\n  , tailRecM\n  , tailRecM2\n  , tailRecM3\n  , forever\n  , whileJust\n  , untilJust\n  , loop2\n  , loop3\n  ) where\n\nimport Prelude\n\nimport Data.Bifunctor (class Bifunctor)\nimport Data.Either (Either(..))\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect, untilE)\nimport Effect.Ref as Ref\nimport Partial.Unsafe (unsafePartial)\n\n-- | The result of a computation: either `Loop` containing the updated\n-- | accumulator, or `Done` containing the final result of the computation.\ndata Step a b = Loop a | Done b\n\nderive instance functorStep :: Functor (Step a)\n\ninstance bifunctorStep :: Bifunctor Step where\n  bimap f _ (Loop a) = Loop (f a)\n  bimap _ g (Done b) = Done (g b)\n\n-- | This type class captures those monads which support tail recursion in\n-- | constant stack space.\n-- |\n-- | The `tailRecM` function takes a step function, and applies that step\n-- | function recursively until a pure value of type `b` is found.\n-- |\n-- | Instances are provided for standard monad transformers.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | loopWriter :: Int -> WriterT (Additive Int) Effect Unit\n-- | loopWriter n = tailRecM go n\n-- |   where\n-- |   go 0 = do\n-- |     traceM \"Done!\"\n-- |     pure (Done unit)\n-- |   go i = do\n-- |     tell $ Additive i\n-- |     pure (Loop (i - 1))\n-- | ```\nclass Monad m <= MonadRec m where\n  tailRecM :: forall a b. (a -> m (Step a b)) -> a -> m b\n\n-- | Create a tail-recursive function of two arguments which uses constant stack space.\n-- |\n-- | The `loop2` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRecM2\n  :: forall m a b c\n   . MonadRec m\n  => (a -> b -> m (Step { a :: a, b :: b } c))\n  -> a\n  -> b\n  -> m c\ntailRecM2 f a b = tailRecM (\\o -> f o.a o.b) { a, b }\n\n-- | Create a tail-recursive function of three arguments which uses constant stack space.\n-- |\n-- | The `loop3` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRecM3\n  :: forall m a b c d\n   . MonadRec m\n  => (a -> b -> c -> m (Step { a :: a, b :: b, c :: c } d))\n  -> a\n  -> b\n  -> c\n  -> m d\ntailRecM3 f a b c = tailRecM (\\o -> f o.a o.b o.c) { a, b, c }\n\n-- | Create a pure tail-recursive function of one argument\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | pow :: Int -> Int -> Int\n-- | pow n p = tailRec go { accum: 1, power: p }\n-- |   where\n-- |   go :: _ -> Step _ Int\n-- |   go { accum: acc, power: 0 } = Done acc\n-- |   go { accum: acc, power: p } = Loop { accum: acc * n, power: p - 1 }\n-- | ```\ntailRec :: forall a b. (a -> Step a b) -> a -> b\ntailRec f = go <<< f\n  where\n  go (Loop a) = go (f a)\n  go (Done b) = b\n\n-- | Create a pure tail-recursive function of two arguments\n-- |\n-- | The `loop2` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRec2 :: forall a b c. (a -> b -> Step { a :: a, b :: b } c) -> a -> b -> c\ntailRec2 f a b = tailRec (\\o -> f o.a o.b) { a, b }\n\n-- | Create a pure tail-recursive function of three arguments\n-- |\n-- | The `loop3` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRec3 :: forall a b c d. (a -> b -> c -> Step { a :: a, b :: b, c :: c } d) -> a -> b -> c -> d\ntailRec3 f a b c = tailRec (\\o -> f o.a o.b o.c) { a, b, c }\n\ninstance monadRecIdentity :: MonadRec Identity where\n  tailRecM f = Identity <<< tailRec (runIdentity <<< f)\n    where runIdentity (Identity x) = x\n\ninstance monadRecEffect :: MonadRec Effect where\n  tailRecM f a = do\n    r <- Ref.new =<< f a\n    untilE do\n      Ref.read r >>= case _ of\n        Loop a' -> do\n          e <- f a'\n          _ <- Ref.write e r\n          pure false\n        Done _ -> pure true\n    fromDone <$> Ref.read r\n    where\n    fromDone :: forall a b. Step a b -> b\n    fromDone = unsafePartial \\(Done b) -> b\n\ninstance monadRecFunction :: MonadRec ((->) e) where\n  tailRecM f a0 e = tailRec (\\a -> f a e) a0\n\ninstance monadRecEither :: MonadRec (Either e) where\n  tailRecM f a0 =\n    let\n      g (Left e) = Done (Left e)\n      g (Right (Loop a)) = Loop (f a)\n      g (Right (Done b)) = Done (Right b)\n    in tailRec g (f a0)\n\ninstance monadRecMaybe :: MonadRec Maybe where\n  tailRecM f a0 =\n    let\n      g Nothing = Done Nothing\n      g (Just (Loop a)) = Loop (f a)\n      g (Just (Done b)) = Done (Just b)\n    in tailRec g (f a0)\n\n-- | `forever` runs an action indefinitely, using the `MonadRec` instance to\n-- | ensure constant stack usage.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = forever $ trace \"Hello, World!\"\n-- | ```\nforever :: forall m a b. MonadRec m => m a -> m b\nforever ma = tailRecM (\\u -> Loop u <$ ma) unit\n\n-- | While supplied computation evaluates to `Just _`, it will be\n-- | executed repeatedly and results will be combined using monoid instance.\nwhileJust :: forall a m. Monoid a => MonadRec m => m (Maybe a) -> m a\nwhileJust m = mempty # tailRecM \\v -> m <#> case _ of\n  Nothing -> Done v\n  Just x -> Loop $ v <> x\n\n-- | Supplied computation will be executed repeatedly until it evaluates\n-- | to `Just value` and then that `value` will be returned.\nuntilJust :: forall a m. MonadRec m => m (Maybe a) -> m a\nuntilJust m = unit # tailRecM \\_ -> m <#> case _ of\n  Nothing -> Loop unit\n  Just x -> Done x\n\n-- | A curried version of the `Loop` constructor, provided as a convenience for\n-- | use with `tailRec2` and `tailRecM2`.\nloop2 :: forall a b c. a -> b -> Step { a :: a, b :: b } c\nloop2 a b = Loop { a, b }\n\n-- | A curried version of the `Loop` constructor, provided as a convenience for\n-- | use with `tailRec3` and `tailRecM3`.\nloop3 :: forall a b c d. a -> b -> c -> Step { a :: a, b :: b, c :: c } d\nloop3 a b c = Loop { a, b, c }\n", "module Control.Monad.ST.Internal\n  ( Region\n  , ST\n  , run\n  , while\n  , for\n  , foreach\n  , STRef\n  , new\n  , read\n  , modify'\n  , modify\n  , write\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..))\nimport Partial.Unsafe (unsafePartial)\n\n-- | `ST` is concerned with _restricted_ mutation. Mutation is restricted to a\n-- | _region_ of mutable references. This kind is inhabited by phantom types\n-- | which represent regions in the type system.\nforeign import data Region :: Type\n\n-- | The `ST` type constructor allows _local mutation_, i.e. mutation which\n-- | does not \"escape\" into the surrounding computation.\n-- |\n-- | An `ST` computation is parameterized by a phantom type which is used to\n-- | restrict the set of reference cells it is allowed to access.\n-- |\n-- | The `run` function can be used to run a computation in the `ST` monad.\nforeign import data ST :: Region -> Type -> Type\n\ntype role ST nominal representational\n\nforeign import map_ :: forall r a b. (a -> b) -> ST r a -> ST r b\n\nforeign import pure_ :: forall r a. a -> ST r a\n\nforeign import bind_ :: forall r a b. ST r a -> (a -> ST r b) -> ST r b\n\ninstance functorST :: Functor (ST r) where\n  map = map_\n\ninstance applyST :: Apply (ST r) where\n  apply = ap\n\ninstance applicativeST :: Applicative (ST r) where\n  pure = pure_\n\ninstance bindST :: Bind (ST r) where\n  bind = bind_\n\ninstance monadST :: Monad (ST r)\n\ninstance monadRecST :: MonadRec (ST r) where\n  tailRecM f a = do\n    r <- new =<< f a\n    while (isLooping <$> read r) do\n      read r >>= case _ of\n        Loop a' -> do\n          e <- f a'\n          void (write e r)\n        Done _ -> pure unit\n    fromDone <$> read r\n    where\n      fromDone :: forall a b. Step a b -> b\n      fromDone = unsafePartial \\(Done b) -> b\n\n      isLooping = case _ of\n        Loop _ -> true\n        _ -> false\n\ninstance semigroupST :: Semigroup a => Semigroup (ST r a) where\n  append = lift2 append\n\ninstance monoidST :: Monoid a => Monoid (ST r a) where\n  mempty = pure mempty\n\n-- | Run an `ST` computation.\n-- |\n-- | Note: the type of `run` uses a rank-2 type to constrain the phantom\n-- | type `r`, such that the computation must not leak any mutable references\n-- | to the surrounding computation. It may cause problems to apply this\n-- | function using the `$` operator. The recommended approach is to use\n-- | parentheses instead.\nforeign import run :: forall a. (forall r. ST r a) -> a\n\n-- | Loop while a condition is `true`.\n-- |\n-- | `while b m` is ST computation which runs the ST computation `b`. If its\n-- | result is `true`, it runs the ST computation `m` and loops. If not, the\n-- | computation ends.\nforeign import while :: forall r a. ST r Boolean -> ST r a -> ST r Unit\n\n-- | Loop over a consecutive collection of numbers\n-- |\n-- | `ST.for lo hi f` runs the computation returned by the function `f` for each\n-- | of the inputs between `lo` (inclusive) and `hi` (exclusive).\nforeign import for :: forall r a. Int -> Int -> (Int -> ST r a) -> ST r Unit\n\n-- | Loop over an array of values.\n-- |\n-- | `ST.foreach xs f` runs the computation returned by the function `f` for each\n-- | of the inputs `xs`.\nforeign import foreach :: forall r a. Array a -> (a -> ST r Unit) -> ST r Unit\n\n-- | The type `STRef r a` represents a mutable reference holding a value of\n-- | type `a`, which can be used with the `ST r` effect.\nforeign import data STRef :: Region -> Type -> Type\n\ntype role STRef nominal representational\n\n-- | Create a new mutable reference.\nforeign import new :: forall a r. a -> ST r (STRef r a)\n\n-- | Read the current value of a mutable reference.\nforeign import read :: forall a r. STRef r a -> ST r a\n\n-- | Update the value of a mutable reference by applying a function\n-- | to the current value, computing a new state value for the reference and\n-- | a return value.\nmodify' :: forall r a b. (a -> { state :: a, value :: b }) -> STRef r a -> ST r b\nmodify' = modifyImpl\n\nforeign import modifyImpl :: forall r a b. (a -> { state :: a, value :: b }) -> STRef r a -> ST r b\n\n-- | Modify the value of a mutable reference by applying a function to the\n-- | current value. The modified value is returned.\nmodify :: forall r a. (a -> a) -> STRef r a -> ST r a\nmodify f = modify' \\s -> let s' = f s in { state: s', value: s' }\n\n-- | Set the value of a mutable reference.\nforeign import write :: forall a r. a -> STRef r a -> ST r a\n", "module Control.Monad.ST.Class where\n\nimport Prelude\n\nimport Control.Monad.ST (ST)\nimport Control.Monad.ST.Global (Global)\nimport Control.Monad.ST.Global as Global\nimport Effect (Effect)\n\nclass Monad m <= MonadST s m | m -> s where\n  liftST :: ST s ~> m\n\ninstance monadSTEffect :: MonadST Global Effect where\n  liftST = Global.toEffect\n\ninstance monadSTST :: MonadST s (ST s) where\n  liftST = identity\n", "export const mkSTFn1 = function mkSTFn1(fn) {\n  return function(x) {\n    return fn(x)();\n  };\n};\n  \nexport const mkSTFn2 = function mkSTFn2(fn) {\n  return function(a, b) {\n    return fn(a)(b)();\n  };\n};\n  \nexport const mkSTFn3 = function mkSTFn3(fn) {\n  return function(a, b, c) {\n    return fn(a)(b)(c)();\n  };\n};\n  \nexport const mkSTFn4 = function mkSTFn4(fn) {\n  return function(a, b, c, d) {\n    return fn(a)(b)(c)(d)();\n  };\n};\n  \nexport const mkSTFn5 = function mkSTFn5(fn) {\n  return function(a, b, c, d, e) {\n    return fn(a)(b)(c)(d)(e)();\n  };\n};\n  \nexport const mkSTFn6 = function mkSTFn6(fn) {\n  return function(a, b, c, d, e, f) {\n    return fn(a)(b)(c)(d)(e)(f)();\n  };\n};\n  \nexport const mkSTFn7 = function mkSTFn7(fn) {\n  return function(a, b, c, d, e, f, g) {\n    return fn(a)(b)(c)(d)(e)(f)(g)();\n  };\n};\n  \nexport const mkSTFn8 = function mkSTFn8(fn) {\n  return function(a, b, c, d, e, f, g, h) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)();\n  };\n};\n  \nexport const mkSTFn9 = function mkSTFn9(fn) {\n  return function(a, b, c, d, e, f, g, h, i) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)();\n  };\n};\n  \nexport const mkSTFn10 = function mkSTFn10(fn) {\n  return function(a, b, c, d, e, f, g, h, i, j) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)();\n  };\n};\n  \nexport const runSTFn1 = function runSTFn1(fn) {\n  return function(a) {\n    return function() {\n      return fn(a);\n    };\n  };\n};\n  \nexport const runSTFn2 = function runSTFn2(fn) {\n  return function(a) {\n    return function(b) {\n      return function() {\n        return fn(a, b);\n      };\n    };\n  };\n};\n  \nexport const runSTFn3 = function runSTFn3(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function() {\n          return fn(a, b, c);\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn4 = function runSTFn4(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function() {\n            return fn(a, b, c, d);\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn5 = function runSTFn5(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function() {\n              return fn(a, b, c, d, e);\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn6 = function runSTFn6(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function() {\n                return fn(a, b, c, d, e, f);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn7 = function runSTFn7(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function() {\n                  return fn(a, b, c, d, e, f, g);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn8 = function runSTFn8(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function() {\n                    return fn(a, b, c, d, e, f, g, h);\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn9 = function runSTFn9(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function(i) {\n                    return function() {\n                      return fn(a, b, c, d, e, f, g, h, i);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn10 = function runSTFn10(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function(i) {\n                    return function(j) {\n                      return function() {\n                        return fn(a, b, c, d, e, f, g, h, i, j);\n                      };\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};", "module Control.Plus\n  ( class Plus, empty\n  , module Control.Alt\n  , module Data.Functor\n  ) where\n\nimport Control.Alt (class Alt, alt, (<|>))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\n\n-- | The `Plus` type class extends the `Alt` type class with a value that\n-- | should be the left and right identity for `(<|>)`.\n-- |\n-- | It is similar to `Monoid`, except that it applies to types of\n-- | kind `* -> *`, like `Array` or `List`, rather than concrete types like\n-- | `String` or `Number`.\n-- |\n-- | `Plus` instances should satisfy the following laws:\n-- |\n-- | - Left identity: `empty <|> x == x`\n-- | - Right identity: `x <|> empty == x`\n-- | - Annihilation: `f <$> empty == empty`\nclass Alt f <= Plus f where\n  empty :: forall a. f a\n\ninstance plusArray :: Plus Array where\n  empty = []\n", "//------------------------------------------------------------------------------\n// Array creation --------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const rangeImpl = function (start, end) {\n  var step = start > end ? -1 : 1;\n  var result = new Array(step * (end - start) + 1);\n  var i = start, n = 0;\n  while (i !== end) {\n    result[n++] = i;\n    i += step;\n  }\n  result[n] = i;\n  return result;\n};\n\nvar replicateFill = function (count, value) {\n  if (count < 1) {\n    return [];\n  }\n  var result = new Array(count);\n  return result.fill(value);\n};\n\nvar replicatePolyfill = function (count, value) {\n  var result = [];\n  var n = 0;\n  for (var i = 0; i < count; i++) {\n    result[n++] = value;\n  }\n  return result;\n};\n\n// In browsers that have Array.prototype.fill we use it, as it's faster.\nexport const replicateImpl = typeof Array.prototype.fill === \"function\" ? replicateFill : replicatePolyfill;\n\nexport const fromFoldableImpl = (function () {\n  function Cons(head, tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n  var emptyList = {};\n\n  function curryCons(head) {\n    return function (tail) {\n      return new Cons(head, tail);\n    };\n  }\n\n  function listToArray(list) {\n    var result = [];\n    var count = 0;\n    var xs = list;\n    while (xs !== emptyList) {\n      result[count++] = xs.head;\n      xs = xs.tail;\n    }\n    return result;\n  }\n\n  return function (foldr, xs) {\n    return listToArray(foldr(curryCons)(emptyList)(xs));\n  };\n})();\n\n//------------------------------------------------------------------------------\n// Array size ------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const length = function (xs) {\n  return xs.length;\n};\n\n//------------------------------------------------------------------------------\n// Non-indexed reads -----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const unconsImpl = function (empty, next, xs) {\n  return xs.length === 0 ? empty({}) : next(xs[0])(xs.slice(1));\n};\n\n//------------------------------------------------------------------------------\n// Indexed operations ----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const indexImpl = function (just, nothing, xs, i) {\n  return i < 0 || i >= xs.length ? nothing :  just(xs[i]);\n};\n\nexport const findMapImpl = function (nothing, isJust, f, xs) {\n  for (var i = 0; i < xs.length; i++) {\n    var result = f(xs[i]);\n    if (isJust(result)) return result;\n  }\n  return nothing;\n};\n\nexport const findIndexImpl = function (just, nothing, f, xs) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (f(xs[i])) return just(i);\n  }\n  return nothing;\n};\n\nexport const findLastIndexImpl = function (just, nothing, f, xs) {\n  for (var i = xs.length - 1; i >= 0; i--) {\n    if (f(xs[i])) return just(i);\n  }\n  return nothing;\n};\n\nexport const _insertAt = function (just, nothing, i, a, l) {\n  if (i < 0 || i > l.length) return nothing;\n  var l1 = l.slice();\n  l1.splice(i, 0, a);\n  return just(l1);\n};\n\nexport const _deleteAt = function (just, nothing, i, l) {\n  if (i < 0 || i >= l.length) return nothing;\n  var l1 = l.slice();\n  l1.splice(i, 1);\n  return just(l1);\n};\n\nexport const _updateAt = function (just, nothing, i, a, l) {\n  if (i < 0 || i >= l.length) return nothing;\n  var l1 = l.slice();\n  l1[i] = a;\n  return just(l1);\n};\n\n//------------------------------------------------------------------------------\n// Transformations -------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const reverse = function (l) {\n  return l.slice().reverse();\n};\n\nexport const concat = function (xss) {\n  if (xss.length <= 10000) {\n    // This method is faster, but it crashes on big arrays.\n    // So we use it when can and fallback to simple variant otherwise.\n    return Array.prototype.concat.apply([], xss);\n  }\n\n  var result = [];\n  for (var i = 0, l = xss.length; i < l; i++) {\n    var xs = xss[i];\n    for (var j = 0, m = xs.length; j < m; j++) {\n      result.push(xs[j]);\n    }\n  }\n  return result;\n};\n\nexport const filterImpl = function (f, xs) {\n  return xs.filter(f);\n};\n\nexport const partitionImpl = function (f, xs) {\n  var yes = [];\n  var no  = [];\n  for (var i = 0; i < xs.length; i++) {\n    var x = xs[i];\n    if (f(x))\n      yes.push(x);\n    else\n      no.push(x);\n  }\n  return { yes: yes, no: no };\n};\n\nexport const scanlImpl = function (f, b, xs) {\n  var len = xs.length;\n  var acc = b;\n  var out = new Array(len);\n  for (var i = 0; i < len; i++) {\n    acc = f(acc)(xs[i]);\n    out[i] = acc;\n  }\n  return out;\n};\n\nexport const scanrImpl = function (f, b, xs) {\n  var len = xs.length;\n  var acc = b;\n  var out = new Array(len);\n  for (var i = len - 1; i >= 0; i--) {\n    acc = f(xs[i])(acc);\n    out[i] = acc;\n  }\n  return out;\n};\n\n//------------------------------------------------------------------------------\n// Sorting ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const sortByImpl = (function () {\n  function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {\n    var mid;\n    var i;\n    var j;\n    var k;\n    var x;\n    var y;\n    var c;\n\n    mid = from + ((to - from) >> 1);\n    if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);\n    if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);\n\n    i = from;\n    j = mid;\n    k = from;\n    while (i < mid && j < to) {\n      x = xs2[i];\n      y = xs2[j];\n      c = fromOrdering(compare(x)(y));\n      if (c > 0) {\n        xs1[k++] = y;\n        ++j;\n      }\n      else {\n        xs1[k++] = x;\n        ++i;\n      }\n    }\n    while (i < mid) {\n      xs1[k++] = xs2[i++];\n    }\n    while (j < to) {\n      xs1[k++] = xs2[j++];\n    }\n  }\n\n  return function (compare, fromOrdering, xs) {\n    var out;\n\n    if (xs.length < 2) return xs;\n\n    out = xs.slice(0);\n    mergeFromTo(compare, fromOrdering, out, xs.slice(0), 0, xs.length);\n\n    return out;\n  };\n})();\n\n//------------------------------------------------------------------------------\n// Subarrays -------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const sliceImpl = function (s, e, l) {\n  return l.slice(s, e);\n};\n\n//------------------------------------------------------------------------------\n// Zipping ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const zipWithImpl = function (f, xs, ys) {\n  var l = xs.length < ys.length ? xs.length : ys.length;\n  var result = new Array(l);\n  for (var i = 0; i < l; i++) {\n    result[i] = f(xs[i])(ys[i]);\n  }\n  return result;\n};\n\n//------------------------------------------------------------------------------\n// Folding ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const anyImpl = function (p, xs) {\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    if (p(xs[i])) return true;\n  }\n  return false;\n};\n\nexport const allImpl = function (p, xs) {\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    if (!p(xs[i])) return false;\n  }\n  return true;\n};\n\n//------------------------------------------------------------------------------\n// Partial ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const unsafeIndexImpl = function (xs, n) {\n  return xs[n];\n};\n", "function newSTArray() {\n  return [];\n}\nexport { newSTArray as new };\n\nexport const peekImpl = function (just, nothing, i, xs) {\n  return i >= 0 && i < xs.length ? just(xs[i]) : nothing;\n};\n\nexport const pokeImpl = function (i, a, xs) {\n  var ret = i >= 0 && i < xs.length;\n  if (ret) xs[i] = a;\n  return ret;\n};\n\nexport const lengthImpl = function (xs) {\n  return xs.length;\n};\n\nexport const popImpl = function (just, nothing, xs) {\n  return xs.length > 0 ? just(xs.pop()) : nothing;\n};\n\nexport const pushAllImpl = function (as, xs) {\n  return xs.push.apply(xs, as);\n};\n\nexport const shiftImpl = function (just, nothing, xs) {\n  return xs.length > 0 ? just(xs.shift()) : nothing;\n};\n\nexport const unshiftAllImpl = function (as, xs) {\n  return xs.unshift.apply(xs, as);\n};\n\nexport const spliceImpl = function (i, howMany, bs, xs) {\n  return xs.splice.apply(xs, [i, howMany].concat(bs));\n};\n\nfunction unsafeFreezeThawImpl(xs) {\n  return xs;\n}\n\nexport const unsafeFreezeImpl = unsafeFreezeThawImpl;\n\nexport const unsafeThawImpl = unsafeFreezeThawImpl;\n\nfunction copyImpl(xs) {\n  return xs.slice();\n}\n\nexport const freezeImpl = copyImpl;\n\nexport const thawImpl = copyImpl;\n\nexport const cloneImpl = copyImpl;\n\nexport const sortByImpl = (function () {\n  function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {\n    var mid;\n    var i;\n    var j;\n    var k;\n    var x;\n    var y;\n    var c;\n\n    mid = from + ((to - from) >> 1);\n    if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);\n    if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);\n\n    i = from;\n    j = mid;\n    k = from;\n    while (i < mid && j < to) {\n      x = xs2[i];\n      y = xs2[j];\n      c = fromOrdering(compare(x)(y));\n      if (c > 0) {\n        xs1[k++] = y;\n        ++j;\n      } else {\n        xs1[k++] = x;\n        ++i;\n      }\n    }\n    while (i < mid) {\n      xs1[k++] = xs2[i++];\n    }\n    while (j < to) {\n      xs1[k++] = xs2[j++];\n    }\n  }\n\n  return function (compare, fromOrdering, xs) {\n    if (xs.length < 2) return xs;\n\n    mergeFromTo(compare, fromOrdering, xs, xs.slice(0), 0, xs.length);\n\n    return xs;\n  };\n})();\n\nexport const toAssocArrayImpl = function (xs) {\n  var n = xs.length;\n  var as = new Array(n);\n  for (var i = 0; i < n; i++) as[i] = { value: xs[i], index: i };\n  return as;\n};\n\nexport const pushImpl = function (a, xs) {\n  return xs.push(a);\n};\n", "-- | Helper functions for working with mutable arrays using the `ST` effect.\n-- |\n-- | This module can be used when performance is important and mutation is a local effect.\n\nmodule Data.Array.ST\n  ( STArray(..)\n  , Assoc\n  , run\n  , withArray\n  , new\n  , peek\n  , poke\n  , modify\n  , length\n  , pop\n  , push\n  , pushAll\n  , shift\n  , unshift\n  , unshiftAll\n  , splice\n  , sort\n  , sortBy\n  , sortWith\n  , freeze\n  , thaw\n  , clone\n  , unsafeFreeze\n  , unsafeThaw\n  , toAssocArray\n  ) where\n\nimport Prelude\n\nimport Control.Monad.ST (ST, Region)\nimport Control.Monad.ST as ST\nimport Control.Monad.ST.Uncurried (STFn1, STFn2, STFn3, STFn4, runSTFn1, runSTFn2, runSTFn3, runSTFn4)\nimport Data.Maybe (Maybe(..))\n\n-- | A reference to a mutable array.\n-- |\n-- | The first type parameter represents the memory region which the array belongs to.\n-- | The second type parameter defines the type of elements of the mutable array.\n-- |\n-- | The runtime representation of a value of type `STArray h a` is the same as that of `Array a`,\n-- | except that mutation is allowed.\nforeign import data STArray :: Region -> Type -> Type\n\ntype role STArray nominal representational\n\n-- | An element and its index.\ntype Assoc a = { value :: a, index :: Int }\n\n-- | A safe way to create and work with a mutable array before returning an\n-- | immutable array for later perusal. This function avoids copying the array\n-- | before returning it - it uses unsafeFreeze internally, but this wrapper is\n-- | a safe interface to that function.\nrun :: forall a. (forall h. ST h (STArray h a)) -> Array a\nrun st = ST.run (st >>= unsafeFreeze)\n\n-- | Perform an effect requiring a mutable array on a copy of an immutable array,\n-- | safely returning the result as an immutable array.\nwithArray\n  :: forall h a b\n   . (STArray h a -> ST h b)\n  -> Array a\n  -> ST h (Array a)\nwithArray f xs = do\n  result <- thaw xs\n  _ <- f result\n  unsafeFreeze result\n\n-- | O(1). Convert a mutable array to an immutable array, without copying. The mutable\n-- | array must not be mutated afterwards.\nunsafeFreeze :: forall h a. STArray h a -> ST h (Array a)\nunsafeFreeze = runSTFn1 unsafeFreezeImpl\n\nforeign import unsafeFreezeImpl :: forall h a. STFn1 (STArray h a) h (Array a)\n\n-- | O(1) Convert an immutable array to a mutable array, without copying. The input\n-- | array must not be used afterward.\nunsafeThaw :: forall h a. Array a -> ST h (STArray h a)\nunsafeThaw = runSTFn1 unsafeThawImpl\n\nforeign import unsafeThawImpl :: forall h a. STFn1 (Array a) h (STArray h a)\n\n-- | Create a new, empty mutable array.\nforeign import new :: forall h a. ST h (STArray h a)\n\nthaw\n  :: forall h a\n   . Array a\n  -> ST h (STArray h a)\nthaw = runSTFn1 thawImpl\n\n-- | Create a mutable copy of an immutable array.\nforeign import thawImpl :: forall h a. STFn1 (Array a) h (STArray h a)\n\n-- | Make a mutable copy of a mutable array.\nclone\n  :: forall h a\n   . STArray h a\n  -> ST h (STArray h a)\nclone = runSTFn1 cloneImpl\n\nforeign import cloneImpl :: forall h a. STFn1 (STArray h a) h (STArray h a)\n\n-- | Sort a mutable array in place. Sorting is stable: the order of equal\n-- | elements is preserved.\nsort :: forall a h. Ord a => STArray h a -> ST h (STArray h a)\nsort = sortBy compare\n\n-- | Remove the first element from an array and return that element.\nshift :: forall h a. STArray h a -> ST h (Maybe a)\nshift = runSTFn3 shiftImpl Just Nothing\n\nforeign import shiftImpl\n  :: forall h a\n   . STFn3 (forall b. b -> Maybe b) (forall b. Maybe b) (STArray h a) h (Maybe a)\n\n-- | Sort a mutable array in place using a comparison function. Sorting is\n-- | stable: the order of elements is preserved if they are equal according to\n-- | the comparison function.\nsortBy\n  :: forall a h\n   . (a -> a -> Ordering)\n  -> STArray h a\n  -> ST h (STArray h a)\nsortBy comp = runSTFn3 sortByImpl comp case _ of\n  GT -> 1\n  EQ -> 0\n  LT -> -1\n\nforeign import sortByImpl\n  :: forall a h\n   . STFn3 (a -> a -> Ordering) (Ordering -> Int) (STArray h a) h (STArray h a)\n\n-- | Sort a mutable array in place based on a projection. Sorting is stable: the\n-- | order of elements is preserved if they are equal according to the projection.\nsortWith\n  :: forall a b h\n   . Ord b\n  => (a -> b)\n  -> STArray h a\n  -> ST h (STArray h a)\nsortWith f = sortBy (comparing f)\n\n-- | Create an immutable copy of a mutable array.\nfreeze\n  :: forall h a\n   . STArray h a\n  -> ST h (Array a)\nfreeze = runSTFn1 freezeImpl\n\nforeign import freezeImpl :: forall h a. STFn1 (STArray h a) h (Array a)\n\n-- | Read the value at the specified index in a mutable array.\npeek\n  :: forall h a\n   . Int\n  -> STArray h a\n  -> ST h (Maybe a)\npeek = runSTFn4 peekImpl Just Nothing\n\nforeign import peekImpl :: forall h a r. STFn4 (a -> r) r Int (STArray h a) h r\n\npoke\n  :: forall h a\n   . Int\n  -> a\n  -> STArray h a\n  -> ST h Boolean\npoke = runSTFn3 pokeImpl\n\n-- | Change the value at the specified index in a mutable array.\nforeign import pokeImpl :: forall h a. STFn3 Int a (STArray h a) h Boolean\n\nforeign import lengthImpl :: forall h a. STFn1 (STArray h a) h Int\n\n-- | Get the number of elements in a mutable array.\nlength :: forall h a. STArray h a -> ST h Int\nlength = runSTFn1 lengthImpl\n\n-- | Remove the last element from an array and return that element.\npop :: forall h a. STArray h a -> ST h (Maybe a)\npop = runSTFn3 popImpl Just Nothing\n\nforeign import popImpl\n  :: forall h a\n   . STFn3 (forall b. b -> Maybe b) (forall b. Maybe b) (STArray h a) h (Maybe a)\n\n-- | Append an element to the end of a mutable array. Returns the new length of\n-- | the array.\npush :: forall h a. a -> (STArray h a) -> ST h Int\npush = runSTFn2 pushImpl\n\nforeign import pushImpl :: forall h a. STFn2 a (STArray h a) h Int\n\n-- | Append the values in an immutable array to the end of a mutable array.\n-- | Returns the new length of the mutable array.\npushAll\n  :: forall h a\n   . Array a\n  -> STArray h a\n  -> ST h Int\npushAll = runSTFn2 pushAllImpl\n\nforeign import pushAllImpl\n  :: forall h a\n   . STFn2 (Array a) (STArray h a) h Int\n\n-- | Append an element to the front of a mutable array. Returns the new length of\n-- | the array.\nunshift :: forall h a. a -> STArray h a -> ST h Int\nunshift a = runSTFn2 unshiftAllImpl [ a ]\n\n-- | Append the values in an immutable array to the front of a mutable array.\n-- | Returns the new length of the mutable array.\nunshiftAll\n  :: forall h a\n   . Array a\n  -> STArray h a\n  -> ST h Int\nunshiftAll = runSTFn2 unshiftAllImpl\n\nforeign import unshiftAllImpl\n  :: forall h a\n   . STFn2 (Array a) (STArray h a) h Int\n\n-- | Mutate the element at the specified index using the supplied function.\nmodify :: forall h a. Int -> (a -> a) -> STArray h a -> ST h Boolean\nmodify i f xs = do\n  entry <- peek i xs\n  case entry of\n    Just x -> poke i (f x) xs\n    Nothing -> pure false\n\n-- | Remove and/or insert elements from/into a mutable array at the specified index.\nsplice\n  :: forall h a\n   . Int\n  -> Int\n  -> Array a\n  -> STArray h a\n  -> ST h (Array a)\nsplice = runSTFn4 spliceImpl\n\nforeign import spliceImpl\n  :: forall h a\n   . STFn4 Int Int (Array a) (STArray h a) h (Array a)\n\n-- | Create an immutable copy of a mutable array, where each element\n-- | is labelled with its index in the original array.\ntoAssocArray\n  :: forall h a\n   . STArray h a\n  -> ST h (Array (Assoc a))\ntoAssocArray = runSTFn1 toAssocArrayImpl\n\nforeign import toAssocArrayImpl\n  :: forall h a\n   . STFn1 (STArray h a) h (Array (Assoc a))\n", "export const boolConj = function (b1) {\n  return function (b2) {\n    return b1 && b2;\n  };\n};\n\nexport const boolDisj = function (b1) {\n  return function (b2) {\n    return b1 || b2;\n  };\n};\n\nexport const boolNot = function (b) {\n  return !b;\n};\n", "module Data.HeytingAlgebra\n  ( class HeytingAlgebra\n  , tt\n  , ff\n  , implies\n  , conj\n  , disj\n  , not\n  , (&&)\n  , (||)\n  , class HeytingAlgebraRecord\n  , ffRecord\n  , ttRecord\n  , impliesRecord\n  , conjRecord\n  , disjRecord\n  , notRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `HeytingAlgebra` type class represents types that are bounded lattices with\n-- | an implication operator such that the following laws hold:\n-- |\n-- | - Associativity:\n-- |   - `a || (b || c) = (a || b) || c`\n-- |   - `a && (b && c) = (a && b) && c`\n-- | - Commutativity:\n-- |   - `a || b = b || a`\n-- |   - `a && b = b && a`\n-- | - Absorption:\n-- |   - `a || (a && b) = a`\n-- |   - `a && (a || b) = a`\n-- | - Idempotent:\n-- |   - `a || a = a`\n-- |   - `a && a = a`\n-- | - Identity:\n-- |   - `a || ff = a`\n-- |   - `a && tt = a`\n-- | - Implication:\n-- |   - ``a `implies` a = tt``\n-- |   - ``a && (a `implies` b) = a && b``\n-- |   - ``b && (a `implies` b) = b``\n-- |   - ``a `implies` (b && c) = (a `implies` b) && (a `implies` c)``\n-- | - Complemented:\n-- |   - ``not a = a `implies` ff``\nclass HeytingAlgebra a where\n  ff :: a\n  tt :: a\n  implies :: a -> a -> a\n  conj :: a -> a -> a\n  disj :: a -> a -> a\n  not :: a -> a\n\ninfixr 3 conj as &&\ninfixr 2 disj as ||\n\ninstance heytingAlgebraBoolean :: HeytingAlgebra Boolean where\n  ff = false\n  tt = true\n  implies a b = not a || b\n  conj = boolConj\n  disj = boolDisj\n  not = boolNot\n\ninstance heytingAlgebraUnit :: HeytingAlgebra Unit where\n  ff = unit\n  tt = unit\n  implies _ _ = unit\n  conj _ _ = unit\n  disj _ _ = unit\n  not _ = unit\n\ninstance heytingAlgebraFunction :: HeytingAlgebra b => HeytingAlgebra (a -> b) where\n  ff _ = ff\n  tt _ = tt\n  implies f g a = f a `implies` g a\n  conj f g a = f a && g a\n  disj f g a = f a || g a\n  not f a = not (f a)\n\ninstance heytingAlgebraProxy :: HeytingAlgebra (Proxy a) where\n  conj _ _ = Proxy\n  disj _ _ = Proxy\n  implies _ _ = Proxy\n  ff = Proxy\n  not _ = Proxy\n  tt = Proxy\n\ninstance heytingAlgebraRecord :: (RL.RowToList row list, HeytingAlgebraRecord list row row) => HeytingAlgebra (Record row) where\n  ff = ffRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  tt = ttRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  conj = conjRecord (Proxy :: Proxy list)\n  disj = disjRecord (Proxy :: Proxy list)\n  implies = impliesRecord (Proxy :: Proxy list)\n  not = notRecord (Proxy :: Proxy list)\n\nforeign import boolConj :: Boolean -> Boolean -> Boolean\nforeign import boolDisj :: Boolean -> Boolean -> Boolean\nforeign import boolNot :: Boolean -> Boolean\n\n-- | A class for records where all fields have `HeytingAlgebra` instances, used\n-- | to implement the `HeytingAlgebra` instance for records.\nclass HeytingAlgebraRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass HeytingAlgebraRecord rowlist row subrow | rowlist -> subrow where\n  ffRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  ttRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  impliesRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  disjRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  conjRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  notRecord :: Proxy rowlist -> Record row -> Record subrow\n\ninstance heytingAlgebraRecordNil :: HeytingAlgebraRecord RL.Nil row () where\n  conjRecord _ _ _ = {}\n  disjRecord _ _ _ = {}\n  ffRecord _ _ = {}\n  impliesRecord _ _ _ = {}\n  notRecord _ _ = {}\n  ttRecord _ _ = {}\n\ninstance heytingAlgebraRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , HeytingAlgebraRecord rowlistTail row subrowTail\n  , HeytingAlgebra focus\n  ) =>\n  HeytingAlgebraRecord (RL.Cons key focus rowlistTail) row subrow where\n  conjRecord _ ra rb = insert (conj (get ra) (get rb)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = conjRecord (Proxy :: Proxy rowlistTail) ra rb\n\n  disjRecord _ ra rb = insert (disj (get ra) (get rb)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = disjRecord (Proxy :: Proxy rowlistTail) ra rb\n\n  impliesRecord _ ra rb = insert (implies (get ra) (get rb)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = impliesRecord (Proxy :: Proxy rowlistTail) ra rb\n\n  ffRecord _ row = insert ff tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = ffRecord (Proxy :: Proxy rowlistTail) row\n\n  notRecord _ row = insert (not (get row)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = notRecord (Proxy :: Proxy rowlistTail) row\n\n  ttRecord _ row = insert tt tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = ttRecord (Proxy :: Proxy rowlistTail) row\n", "module Data.Array.ST.Iterator\n  ( Iterator\n  , iterator\n  , iterate\n  , next\n  , peek\n  , exhausted\n  , pushWhile\n  , pushAll\n  ) where\n\nimport Prelude\nimport Control.Monad.ST (ST)\nimport Control.Monad.ST as ST\nimport Control.Monad.ST.Ref (STRef)\nimport Control.Monad.ST.Ref as STRef\nimport Data.Array.ST (STArray)\nimport Data.Array.ST as STA\n\nimport Data.Maybe (Maybe(..), isNothing)\n\n-- | This type provides a slightly easier way of iterating over an array's\n-- | elements in an STArray computation, without having to keep track of\n-- | indices.\ndata Iterator r a = Iterator (Int -> Maybe a) (STRef r Int)\n\n-- | Make an Iterator given an indexing function into an array (or anything\n-- | else). If `xs :: Array a`, the standard way to create an iterator over\n-- | `xs` is to use `iterator (xs !! _)`, where `(!!)` comes from `Data.Array`.\niterator :: forall r a. (Int -> Maybe a) -> ST r (Iterator r a)\niterator f =\n  Iterator f <$> STRef.new 0\n\n-- | Perform an action once for each item left in an iterator. If the action\n-- | itself also advances the same iterator, `iterate` will miss those items\n-- | out.\niterate :: forall r a. Iterator r a -> (a -> ST r Unit) -> ST r Unit\niterate iter f = do\n  break <- STRef.new false\n  ST.while (not <$> STRef.read break) do\n    mx <- next iter\n    case mx of\n      Just x -> f x\n      Nothing -> void $ STRef.write true break\n\n-- | Get the next item out of an iterator, advancing it. Returns Nothing if the\n-- | Iterator is exhausted.\nnext :: forall r a. Iterator r a -> ST r (Maybe a)\nnext (Iterator f currentIndex) = do\n  i <- STRef.read currentIndex\n  _ <- STRef.modify (_ + 1) currentIndex\n  pure (f i)\n\n-- | Get the next item out of an iterator without advancing it.\npeek :: forall r a. Iterator r a -> ST r (Maybe a)\npeek (Iterator f currentIndex) = do\n  i <- STRef.read currentIndex\n  pure (f i)\n\n-- | Check whether an iterator has been exhausted.\nexhausted :: forall r a. Iterator r a -> ST r Boolean\nexhausted = map isNothing <<< peek\n\n-- | Extract elements from an iterator and push them on to an STArray for as\n-- | long as those elements satisfy a given predicate.\npushWhile :: forall r a. (a -> Boolean) -> Iterator r a -> STArray r a -> ST r Unit\npushWhile p iter array = do\n  break <- STRef.new false\n  ST.while (not <$> STRef.read break) do\n    mx <- peek iter\n    case mx of\n      Just x | p x -> do\n        _ <- STA.push x array\n        void $ next iter\n      _ ->\n        void $ STRef.write true break\n\n-- | Push the entire remaining contents of an iterator onto an STArray.\npushAll :: forall r a. Iterator r a -> STArray r a -> ST r Unit\npushAll = pushWhile (const true)\n", "export const foldrArray = function (f) {\n  return function (init) {\n    return function (xs) {\n      var acc = init;\n      var len = xs.length;\n      for (var i = len - 1; i >= 0; i--) {\n        acc = f(xs[i])(acc);\n      }\n      return acc;\n    };\n  };\n};\n\nexport const foldlArray = function (f) {\n  return function (init) {\n    return function (xs) {\n      var acc = init;\n      var len = xs.length;\n      for (var i = 0; i < len; i++) {\n        acc = f(acc)(xs[i]);\n      }\n      return acc;\n    };\n  };\n};\n", "-- | A data type and functions for working with ordered pairs.\nmodule Data.Tuple where\n\nimport Prelude\n\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.Lazy (class Lazy, defer)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.HeytingAlgebra (implies, ff, tt)\nimport Data.Ord (class Ord1)\n\n-- | A simple product type for wrapping a pair of component values.\ndata Tuple a b = Tuple a b\n\n-- | Allows `Tuple`s to be rendered as a string with `show` whenever there are\n-- | `Show` instances for both component types.\ninstance showTuple :: (Show a, Show b) => Show (Tuple a b) where\n  show (Tuple a b) = \"(Tuple \" <> show a <> \" \" <> show b <> \")\"\n\n-- | Allows `Tuple`s to be checked for equality with `==` and `/=` whenever\n-- | there are `Eq` instances for both component types.\nderive instance eqTuple :: (Eq a, Eq b) => Eq (Tuple a b)\n\nderive instance eq1Tuple :: Eq a => Eq1 (Tuple a)\n\n-- | Allows `Tuple`s to be compared with `compare`, `>`, `>=`, `<` and `<=`\n-- | whenever there are `Ord` instances for both component types. To obtain\n-- | the result, the `fst`s are `compare`d, and if they are `EQ`ual, the\n-- | `snd`s are `compare`d.\nderive instance ordTuple :: (Ord a, Ord b) => Ord (Tuple a b)\n\nderive instance ord1Tuple :: Ord a => Ord1 (Tuple a)\n\ninstance boundedTuple :: (Bounded a, Bounded b) => Bounded (Tuple a b) where\n  top = Tuple top top\n  bottom = Tuple bottom bottom\n\ninstance semigroupoidTuple :: Semigroupoid Tuple where\n  compose (Tuple _ c) (Tuple a _) = Tuple a c\n\n-- | The `Semigroup` instance enables use of the associative operator `<>` on\n-- | `Tuple`s whenever there are `Semigroup` instances for the component\n-- | types. The `<>` operator is applied pairwise, so:\n-- | ```purescript\n-- | (Tuple a1 b1) <> (Tuple a2 b2) = Tuple (a1 <> a2) (b1 <> b2)\n-- | ```\ninstance semigroupTuple :: (Semigroup a, Semigroup b) => Semigroup (Tuple a b) where\n  append (Tuple a1 b1) (Tuple a2 b2) = Tuple (a1 <> a2) (b1 <> b2)\n\ninstance monoidTuple :: (Monoid a, Monoid b) => Monoid (Tuple a b) where\n  mempty = Tuple mempty mempty\n\ninstance semiringTuple :: (Semiring a, Semiring b) => Semiring (Tuple a b) where\n  add (Tuple x1 y1) (Tuple x2 y2) = Tuple (add x1 x2) (add y1 y2)\n  one = Tuple one one\n  mul (Tuple x1 y1) (Tuple x2 y2) = Tuple (mul x1 x2) (mul y1 y2)\n  zero = Tuple zero zero\n\ninstance ringTuple :: (Ring a, Ring b) => Ring (Tuple a b) where\n  sub (Tuple x1 y1) (Tuple x2 y2) = Tuple (sub x1 x2) (sub y1 y2)\n\ninstance commutativeRingTuple :: (CommutativeRing a, CommutativeRing b) => CommutativeRing (Tuple a b)\n\ninstance heytingAlgebraTuple :: (HeytingAlgebra a, HeytingAlgebra b) => HeytingAlgebra (Tuple a b) where\n  tt = Tuple tt tt\n  ff = Tuple ff ff\n  implies (Tuple x1 y1) (Tuple x2 y2) = Tuple (x1 `implies` x2) (y1 `implies` y2)\n  conj (Tuple x1 y1) (Tuple x2 y2) = Tuple (conj x1 x2) (conj y1 y2)\n  disj (Tuple x1 y1) (Tuple x2 y2) = Tuple (disj x1 x2) (disj y1 y2)\n  not (Tuple x y) = Tuple (not x) (not y)\n\ninstance booleanAlgebraTuple :: (BooleanAlgebra a, BooleanAlgebra b) => BooleanAlgebra (Tuple a b)\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Tuple` with the `<$>` operator, applying the function to the second\n-- | component, so:\n-- | ```purescript\n-- | f <$> (Tuple x y) = Tuple x (f y)\n-- | ````\nderive instance functorTuple :: Functor (Tuple a)\n\nderive instance genericTuple :: Generic (Tuple a b) _\n\ninstance invariantTuple :: Invariant (Tuple a) where\n  imap = imapF\n\n-- | The `Apply` instance allows functions to transform the contents of a\n-- | `Tuple` with the `<*>` operator whenever there is a `Semigroup` instance\n-- | for the `fst` component, so:\n-- | ```purescript\n-- | (Tuple a1 f) <*> (Tuple a2 x) == Tuple (a1 <> a2) (f x)\n-- | ```\ninstance applyTuple :: (Semigroup a) => Apply (Tuple a) where\n  apply (Tuple a1 f) (Tuple a2 x) = Tuple (a1 <> a2) (f x)\n\ninstance applicativeTuple :: (Monoid a) => Applicative (Tuple a) where\n  pure = Tuple mempty\n\ninstance bindTuple :: (Semigroup a) => Bind (Tuple a) where\n  bind (Tuple a1 b) f = case f b of\n    Tuple a2 c -> Tuple (a1 <> a2) c\n\ninstance monadTuple :: (Monoid a) => Monad (Tuple a)\n\ninstance extendTuple :: Extend (Tuple a) where\n  extend f t@(Tuple a _) = Tuple a (f t)\n\ninstance comonadTuple :: Comonad (Tuple a) where\n  extract = snd\n\ninstance lazyTuple :: (Lazy a, Lazy b) => Lazy (Tuple a b) where\n  defer f = Tuple (defer $ \\_ -> fst (f unit)) (defer $ \\_ -> snd (f unit))\n\n-- | Returns the first component of a tuple.\nfst :: forall a b. Tuple a b -> a\nfst (Tuple a _) = a\n\n-- | Returns the second component of a tuple.\nsnd :: forall a b. Tuple a b -> b\nsnd (Tuple _ b) = b\n\n-- | Turn a function that expects a tuple into a function of two arguments.\ncurry :: forall a b c. (Tuple a b -> c) -> a -> b -> c\ncurry f a b = f (Tuple a b)\n\n-- | Turn a function of two arguments into a function that expects a tuple.\nuncurry :: forall a b c. (a -> b -> c) -> Tuple a b -> c\nuncurry f (Tuple a b) = f a b\n\n-- | Exchange the first and second components of a tuple.\nswap :: forall a b. Tuple a b -> Tuple b a\nswap (Tuple a b) = Tuple b a\n", "module Safe.Coerce\n  ( module Prim.Coerce\n  , coerce\n  ) where\n\nimport Prim.Coerce (class Coercible)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | Coerce a value of one type to a value of some other type, without changing\n-- | its runtime representation. This function behaves identically to\n-- | `unsafeCoerce` at runtime. Unlike `unsafeCoerce`, it is safe, because the\n-- | `Coercible` constraint prevents any use of this function from compiling\n-- | unless the compiler can prove that the two types have the same runtime\n-- | representation.\n-- |\n-- | One application for this function is to avoid doing work that you know is a\n-- | no-op because of newtypes. For example, if you have an `Array (Conj a)` and you\n-- | want an `Array (Disj a)`, you could do `Data.Array.map (un Conj >>> Disj)`, but\n-- | this performs an unnecessary traversal of the array, with O(n) cost.\n-- | `coerce` accomplishes the same with only O(1) cost:\n-- |\n-- | ```purescript\n-- | mapConjToDisj :: forall a. Array (Conj a) -> Array (Disj a)\n-- | mapConjToDisj = coerce\n-- | ```\ncoerce :: forall a b. Coercible a b => a -> b\ncoerce = unsafeCoerce\n", "module Data.Newtype where\n\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Semigroup.First (First(..))\nimport Data.Semigroup.Last (Last(..))\nimport Safe.Coerce (class Coercible, coerce)\n\n-- | A type class for `newtype`s to enable convenient wrapping and unwrapping,\n-- | and the use of the other functions in this module.\n-- |\n-- | The compiler can derive instances of `Newtype` automatically:\n-- |\n-- | ``` purescript\n-- | newtype EmailAddress = EmailAddress String\n-- |\n-- | derive instance newtypeEmailAddress :: Newtype EmailAddress _\n-- | ```\n-- |\n-- | Note that deriving for `Newtype` instances requires that the type be\n-- | defined as `newtype` rather than `data` declaration (even if the `data`\n-- | structurally fits the rules of a `newtype`), and the use of a wildcard for\n-- | the wrapped type.\nclass Newtype :: Type -> Type -> Constraint\nclass Coercible t a <= Newtype t a | t -> a\n\nwrap :: forall t a. Newtype t a => a -> t\nwrap = coerce\n\nunwrap :: forall t a. Newtype t a => t -> a\nunwrap = coerce\n\ninstance newtypeAdditive :: Newtype (Additive a) a\n\ninstance newtypeMultiplicative :: Newtype (Multiplicative a) a\n\ninstance newtypeConj :: Newtype (Conj a) a\n\ninstance newtypeDisj :: Newtype (Disj a) a\n\ninstance newtypeDual :: Newtype (Dual a) a\n\ninstance newtypeEndo :: Newtype (Endo c a) (c a a)\n\ninstance newtypeFirst :: Newtype (First a) a\n\ninstance newtypeLast :: Newtype (Last a) a\n\n-- | Given a constructor for a `Newtype`, this returns the appropriate `unwrap`\n-- | function.\nun :: forall t a. Newtype t a => (a -> t) -> t -> a\nun _ = unwrap\n\n-- | This combinator unwraps the newtype, applies a monomorphic function to the \n-- | contained value and wraps the result back in the newtype\nmodify :: forall t a. Newtype t a => (a -> a) -> t -> t\nmodify fn t = wrap (fn (unwrap t))\n\n-- | This combinator is for when you have a higher order function that you want\n-- | to use in the context of some newtype - `foldMap` being a common example:\n-- |\n-- | ``` purescript\n-- | ala Additive foldMap [1,2,3,4] -- 10\n-- | ala Multiplicative foldMap [1,2,3,4] -- 24\n-- | ala Conj foldMap [true, false] -- false\n-- | ala Disj foldMap [true, false] -- true\n-- | ```\nala\n  :: forall f t a s b\n   . Coercible (f t) (f a)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> ((b -> s) -> f t)\n  -> f a\nala _ f = coerce (f wrap)\n\n-- | Similar to `ala` but useful for cases where you want to use an additional\n-- | projection with the higher order function:\n-- |\n-- | ``` purescript\n-- | alaF Additive foldMap String.length [\"hello\", \"world\"] -- 10\n-- | alaF Multiplicative foldMap Math.abs [1.0, -2.0, 3.0, -4.0] -- 24.0\n-- | ```\n-- |\n-- | The type admits other possibilities due to the polymorphic `Functor`\n-- | constraints, but the case described above works because ((->) a) is a\n-- | `Functor`.\nalaF\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> g s)\n  -> f a\n  -> g b\nalaF _ = coerce\n\n-- | Lifts a function operate over newtypes. This can be used to lift a\n-- | function to manipulate the contents of a single newtype, somewhat like\n-- | `map` does for a `Functor`:\n-- |\n-- | ``` purescript\n-- | newtype Label = Label String\n-- | derive instance newtypeLabel :: Newtype Label _\n-- |\n-- | toUpperLabel :: Label -> Label\n-- | toUpperLabel = over Label String.toUpper\n-- | ```\n-- |\n-- | But the result newtype is polymorphic, meaning the result can be returned\n-- | as an alternative newtype:\n-- |\n-- | ``` purescript\n-- | newtype UppercaseLabel = UppercaseLabel String\n-- | derive instance newtypeUppercaseLabel :: Newtype UppercaseLabel _\n-- |\n-- | toUpperLabel' :: Label -> UppercaseLabel\n-- | toUpperLabel' = over Label String.toUpper\n-- | ```\nover\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (a -> b)\n  -> t\n  -> s\nover _ = coerce\n\n-- | Much like `over`, but where the lifted function operates on values in a\n-- | `Functor`:\n-- |\n-- | ``` purescript\n-- | findLabel :: String -> Array Label -> Maybe Label\n-- | findLabel s = overF Label (Foldable.find (_ == s))\n-- | ```\n-- |\n-- | The above example also demonstrates that the functor type is polymorphic\n-- | here too, the input is an `Array` but the result is a `Maybe`.\noverF\n  :: forall f g t a s b\n   . Coercible (f a) (f t)\n  => Coercible (g b) (g s)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f a -> g b)\n  -> f t\n  -> g s\noverF _ = coerce\n\n-- | The opposite of `over`: lowers a function that operates on `Newtype`d\n-- | values to operate on the wrapped value instead.\n-- |\n-- | ``` purescript\n-- | newtype Degrees = Degrees Number\n-- | derive instance newtypeDegrees :: Newtype Degrees _\n-- |\n-- | newtype NormalDegrees = NormalDegrees Number\n-- | derive instance newtypeNormalDegrees :: Newtype NormalDegrees _\n-- |\n-- | normaliseDegrees :: Degrees -> NormalDegrees\n-- | normaliseDegrees (Degrees deg) = NormalDegrees (deg % 360.0)\n-- |\n-- | asNormalDegrees :: Number -> Number\n-- | asNormalDegrees = under Degrees normaliseDegrees\n-- | ```\n-- |\n-- | As with `over` the `Newtype` is polymorphic, as illustrated in the example\n-- | above - both `Degrees` and `NormalDegrees` are instances of `Newtype`,\n-- | so even though `normaliseDegrees` changes the result type we can still put\n-- | a `Number` in and get a `Number` out via `under`.\nunder\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (t -> s)\n  -> a\n  -> b\nunder _ = coerce\n\n-- | Much like `under`, but where the lifted function operates on values in a\n-- | `Functor`:\n-- |\n-- | ``` purescript\n-- | newtype EmailAddress = EmailAddress String\n-- | derive instance newtypeEmailAddress :: Newtype EmailAddress _\n-- |\n-- | isValid :: EmailAddress -> Boolean\n-- | isValid x = false -- imagine a slightly less strict predicate here\n-- |\n-- | findValidEmailString :: Array String -> Maybe String\n-- | findValidEmailString = underF EmailAddress (Foldable.find isValid)\n-- | ```\n-- |\n-- | The above example also demonstrates that the functor type is polymorphic\n-- | here too, the input is an `Array` but the result is a `Maybe`.\nunderF\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> g s)\n  -> f a\n  -> g b\nunderF _ = coerce\n\n-- | Lifts a binary function to operate over newtypes.\n-- |\n-- | ``` purescript\n-- | newtype Meter = Meter Int\n-- | derive newtype instance newtypeMeter :: Newtype Meter _\n-- | newtype SquareMeter = SquareMeter Int\n-- | derive newtype instance newtypeSquareMeter :: Newtype SquareMeter _\n-- |\n-- | area :: Meter -> Meter -> SquareMeter\n-- | area = over2 Meter (*)\n-- | ```\n-- |\n-- | The above example also demonstrates that the return type is polymorphic\n-- | here too.\nover2\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (a -> a -> b)\n  -> t\n  -> t\n  -> s\nover2 _ = coerce\n\n-- | Much like `over2`, but where the lifted binary function operates on\n-- | values in a `Functor`.\noverF2\n  :: forall f g t a s b\n   . Coercible (f a) (f t)\n  => Coercible (g b) (g s)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f a -> f a -> g b)\n  -> f t\n  -> f t\n  -> g s\noverF2 _ = coerce\n\n-- | The opposite of `over2`: lowers a binary function that operates on `Newtype`d\n-- | values to operate on the wrapped value instead.\nunder2\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (t -> t -> s)\n  -> a\n  -> a\n  -> b\nunder2 _ = coerce\n\n-- | Much like `under2`, but where the lifted binary function operates on\n-- | values in a `Functor`.\nunderF2\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> f t -> g s)\n  -> f a\n  -> f a\n  -> g b\nunderF2 _ = coerce\n\n-- | Similar to the function from the `Traversable` class, but operating within\n-- | a newtype instead.\ntraverse\n  :: forall f t a\n   . Coercible (f a) (f t)\n  => Newtype t a\n  => (a -> t)\n  -> (a -> f a)\n  -> t\n  -> f t\ntraverse _ = coerce\n\n-- | Similar to the function from the `Distributive` class, but operating within\n-- | a newtype instead.\ncollect\n  :: forall f t a\n   . Coercible (f a) (f t)\n  => Newtype t a\n  => (a -> t)\n  -> (f a -> a)\n  -> f t\n  -> t\ncollect _ = coerce\n", "module Data.Foldable\n  ( class Foldable, foldr, foldl, foldMap\n  , foldrDefault, foldlDefault, foldMapDefaultL, foldMapDefaultR\n  , fold\n  , foldM\n  , traverse_\n  , for_\n  , sequence_\n  , oneOf\n  , oneOfMap\n  , intercalate\n  , surroundMap\n  , surround\n  , and\n  , or\n  , all\n  , any\n  , sum\n  , product\n  , elem\n  , notElem\n  , indexl\n  , indexr\n  , find\n  , findMap\n  , maximum\n  , maximumBy\n  , minimum\n  , minimumBy\n  , null\n  , length\n  , lookup\n  ) where\n\nimport Prelude\n\nimport Control.Plus (class Plus, alt, empty)\nimport Data.Const (Const)\nimport Data.Either (Either(..))\nimport Data.Functor.App (App(..))\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Coproduct (Coproduct, coproduct)\nimport Data.Functor.Product (Product(..))\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Maybe.First (First(..))\nimport Data.Maybe.Last (Last(..))\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Newtype (alaF, unwrap)\nimport Data.Tuple (Tuple(..))\n\n-- | `Foldable` represents data structures which can be _folded_.\n-- |\n-- | - `foldr` folds a structure from the right\n-- | - `foldl` folds a structure from the left\n-- | - `foldMap` folds a structure by accumulating values in a `Monoid`\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `foldrDefault`\n-- | - `foldlDefault`\n-- | - `foldMapDefaultR`\n-- | - `foldMapDefaultL`\n-- |\n-- | Note: some combinations of the default implementations are unsafe to\n-- | use together - causing a non-terminating mutually recursive cycle.\n-- | These combinations are documented per function.\nclass Foldable f where\n  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b\n  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b\n  foldMap :: forall a m. Monoid m => (a -> m) -> f a -> m\n\n-- | A default implementation of `foldr` using `foldMap`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldMapDefaultR`.\nfoldrDefault\n  :: forall f a b\n   . Foldable f\n  => (a -> b -> b)\n  -> b\n  -> f a\n  -> b\nfoldrDefault c u xs = unwrap (foldMap (Endo <<< c) xs) u\n\n-- | A default implementation of `foldl` using `foldMap`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldMapDefaultL`.\nfoldlDefault\n  :: forall f a b\n   . Foldable f\n  => (b -> a -> b)\n  -> b\n  -> f a\n  -> b\nfoldlDefault c u xs = unwrap (unwrap (foldMap (Dual <<< Endo <<< flip c) xs)) u\n\n-- | A default implementation of `foldMap` using `foldr`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldrDefault`.\nfoldMapDefaultR\n  :: forall f a m\n   . Foldable f\n  => Monoid m\n  => (a -> m)\n  -> f a\n  -> m\nfoldMapDefaultR f = foldr (\\x acc -> f x <> acc) mempty\n\n-- | A default implementation of `foldMap` using `foldl`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldlDefault`.\nfoldMapDefaultL\n  :: forall f a m\n   . Foldable f\n  => Monoid m\n  => (a -> m)\n  -> f a\n  -> m\nfoldMapDefaultL f = foldl (\\acc x -> acc <> f x) mempty\n\ninstance foldableArray :: Foldable Array where\n  foldr = foldrArray\n  foldl = foldlArray\n  foldMap = foldMapDefaultR\n\nforeign import foldrArray :: forall a b. (a -> b -> b) -> b -> Array a -> b\nforeign import foldlArray :: forall a b. (b -> a -> b) -> b -> Array a -> b\n\ninstance foldableMaybe :: Foldable Maybe where\n  foldr _ z Nothing  = z\n  foldr f z (Just x) = x `f` z\n  foldl _ z Nothing  = z\n  foldl f z (Just x) = z `f` x\n  foldMap _ Nothing  = mempty\n  foldMap f (Just x) = f x\n\ninstance foldableFirst :: Foldable First where\n  foldr f z (First x) = foldr f z x\n  foldl f z (First x) = foldl f z x\n  foldMap f (First x) = foldMap f x\n\ninstance foldableLast :: Foldable Last where\n  foldr f z (Last x) = foldr f z x\n  foldl f z (Last x) = foldl f z x\n  foldMap f (Last x) = foldMap f x\n\ninstance foldableAdditive :: Foldable Additive where\n  foldr f z (Additive x) = x `f` z\n  foldl f z (Additive x) = z `f` x\n  foldMap f (Additive x) = f x\n\ninstance foldableDual :: Foldable Dual where\n  foldr f z (Dual x) = x `f` z\n  foldl f z (Dual x) = z `f` x\n  foldMap f (Dual x) = f x\n\ninstance foldableDisj :: Foldable Disj where\n  foldr f z (Disj x) = f x z\n  foldl f z (Disj x) = f z x\n  foldMap f (Disj x) = f x\n\ninstance foldableConj :: Foldable Conj where\n  foldr f z (Conj x) = f x z\n  foldl f z (Conj x) = f z x\n  foldMap f (Conj x) = f x\n\ninstance foldableMultiplicative :: Foldable Multiplicative where\n  foldr f z (Multiplicative x) = x `f` z\n  foldl f z (Multiplicative x) = z `f` x\n  foldMap f (Multiplicative x) = f x\n\ninstance foldableEither :: Foldable (Either a) where\n  foldr _ z (Left _)  = z\n  foldr f z (Right x) = f x z\n  foldl _ z (Left _)  = z\n  foldl f z (Right x) = f z x\n  foldMap _ (Left _)  = mempty\n  foldMap f (Right x) = f x\n\ninstance foldableTuple :: Foldable (Tuple a) where\n  foldr f z (Tuple _ x) = f x z\n  foldl f z (Tuple _ x) = f z x\n  foldMap f (Tuple _ x) = f x\n\ninstance foldableIdentity :: Foldable Identity where\n  foldr f z (Identity x) = f x z\n  foldl f z (Identity x) = f z x\n  foldMap f (Identity x) = f x\n\ninstance foldableConst :: Foldable (Const a) where\n  foldr _ z _ = z\n  foldl _ z _ = z\n  foldMap _ _ = mempty\n\ninstance foldableProduct :: (Foldable f, Foldable g) => Foldable (Product f g) where\n  foldr f z (Product (Tuple fa ga)) = foldr f (foldr f z ga) fa\n  foldl f z (Product (Tuple fa ga)) = foldl f (foldl f z fa) ga\n  foldMap f (Product (Tuple fa ga)) = foldMap f fa <> foldMap f ga\n\ninstance foldableCoproduct :: (Foldable f, Foldable g) => Foldable (Coproduct f g) where\n  foldr f z = coproduct (foldr f z) (foldr f z)\n  foldl f z = coproduct (foldl f z) (foldl f z)\n  foldMap f = coproduct (foldMap f) (foldMap f)\n\ninstance foldableCompose :: (Foldable f, Foldable g) => Foldable (Compose f g) where\n  foldr f i (Compose fga) = foldr (flip (foldr f)) i fga\n  foldl f i (Compose fga) = foldl (foldl f) i fga\n  foldMap f (Compose fga) = foldMap (foldMap f) fga\n\ninstance foldableApp :: Foldable f => Foldable (App f) where\n  foldr f i (App x) = foldr f i x\n  foldl f i (App x) = foldl f i x\n  foldMap f (App x) = foldMap f x\n\n-- | Fold a data structure, accumulating values in some `Monoid`.\nfold :: forall f m. Foldable f => Monoid m => f m -> m\nfold = foldMap identity\n\n-- | Similar to 'foldl', but the result is encapsulated in a monad.\n-- |\n-- | Note: this function is not generally stack-safe, e.g., for monads which\n-- | build up thunks a la `Eff`.\nfoldM :: forall f m a b. Foldable f => Monad m => (b -> a -> m b) -> b -> f a -> m b\nfoldM f b0 = foldl (\\b a -> b >>= flip f a) (pure b0)\n\n-- | Traverse a data structure, performing some effects encoded by an\n-- | `Applicative` functor at each value, ignoring the final result.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | traverse_ print [1, 2, 3]\n-- | ```\ntraverse_\n  :: forall a b f m\n   . Applicative m\n  => Foldable f\n  => (a -> m b)\n  -> f a\n  -> m Unit\ntraverse_ f = foldr ((*>) <<< f) (pure unit)\n\n-- | A version of `traverse_` with its arguments flipped.\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | for_ [1, 2, 3] \\n -> do\n-- |   print n\n-- |   trace \"squared is\"\n-- |   print (n * n)\n-- | ```\nfor_\n  :: forall a b f m\n   . Applicative m\n  => Foldable f\n  => f a\n  -> (a -> m b)\n  -> m Unit\nfor_ = flip traverse_\n\n-- | Perform all of the effects in some data structure in the order\n-- | given by the `Foldable` instance, ignoring the final result.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | sequence_ [ trace \"Hello, \", trace \" world!\" ]\n-- | ```\nsequence_ :: forall a f m. Applicative m => Foldable f => f (m a) -> m Unit\nsequence_ = traverse_ identity\n\n-- | Combines a collection of elements using the `Alt` operation.\noneOf :: forall f g a. Foldable f => Plus g => f (g a) -> g a\noneOf = foldr alt empty\n\n-- | Folds a structure into some `Plus`.\noneOfMap :: forall f g a b. Foldable f => Plus g => (a -> g b) -> f a -> g b\noneOfMap f = foldr (alt <<< f) empty\n\n-- | Fold a data structure, accumulating values in some `Monoid`,\n-- | combining adjacent elements using the specified separator.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > intercalate \", \" [\"Lorem\", \"ipsum\", \"dolor\"]\n-- | = \"Lorem, ipsum, dolor\"\n-- |\n-- | > intercalate \"*\" [\"a\", \"b\", \"c\"]\n-- | = \"a*b*c\"\n-- |\n-- | > intercalate [1] [[2, 3], [4, 5], [6, 7]]\n-- | = [2, 3, 1, 4, 5, 1, 6, 7]\n-- | ```\nintercalate :: forall f m. Foldable f => Monoid m => m -> f m -> m\nintercalate sep xs = (foldl go { init: true, acc: mempty } xs).acc\n  where\n  go { init: true } x = { init: false, acc: x }\n  go { acc: acc }   x = { init: false, acc: acc <> sep <> x }\n\n-- | `foldMap` but with each element surrounded by some fixed value.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > surroundMap \"*\" show []\n-- | = \"*\"\n-- |\n-- | > surroundMap \"*\" show [1]\n-- | = \"*1*\"\n-- |\n-- | > surroundMap \"*\" show [1, 2]\n-- | = \"*1*2*\"\n-- |\n-- | > surroundMap \"*\" show [1, 2, 3]\n-- | = \"*1*2*3*\"\n-- | ```\nsurroundMap :: forall f a m. Foldable f => Semigroup m => m -> (a -> m) -> f a -> m\nsurroundMap d t f = unwrap (foldMap joined f) d\n  where joined a = Endo \\m -> d <> t a <> m\n\n-- | `fold` but with each element surrounded by some fixed value.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > surround \"*\" []\n-- | = \"*\"\n-- |\n-- | > surround \"*\" [\"1\"]\n-- | = \"*1*\"\n-- |\n-- | > surround \"*\" [\"1\", \"2\"]\n-- | = \"*1*2*\"\n-- |\n-- | > surround \"*\" [\"1\", \"2\", \"3\"]\n-- | = \"*1*2*3*\"\n-- | ```\nsurround :: forall f m. Foldable f => Semigroup m => m -> f m -> m\nsurround d = surroundMap d identity\n\n-- | The conjunction of all the values in a data structure. When specialized\n-- | to `Boolean`, this function will test whether all of the values in a data\n-- | structure are `true`.\nand :: forall a f. Foldable f => HeytingAlgebra a => f a -> a\nand = all identity\n\n-- | The disjunction of all the values in a data structure. When specialized\n-- | to `Boolean`, this function will test whether any of the values in a data\n-- | structure is `true`.\nor :: forall a f. Foldable f => HeytingAlgebra a => f a -> a\nor = any identity\n\n-- | `all f` is the same as `and <<< map f`; map a function over the structure,\n-- | and then get the conjunction of the results.\nall :: forall a b f. Foldable f => HeytingAlgebra b => (a -> b) -> f a -> b\nall  = alaF Conj foldMap\n\n-- | `any f` is the same as `or <<< map f`; map a function over the structure,\n-- | and then get the disjunction of the results.\nany :: forall a b f. Foldable f => HeytingAlgebra b => (a -> b) -> f a -> b\nany = alaF Disj foldMap\n\n-- | Find the sum of the numeric values in a data structure.\nsum :: forall a f. Foldable f => Semiring a => f a -> a\nsum = foldl (+) zero\n\n-- | Find the product of the numeric values in a data structure.\nproduct :: forall a f. Foldable f => Semiring a => f a -> a\nproduct = foldl (*) one\n\n-- | Test whether a value is an element of a data structure.\nelem :: forall a f. Foldable f => Eq a => a -> f a -> Boolean\nelem = any <<< (==)\n\n-- | Test whether a value is not an element of a data structure.\nnotElem :: forall a f. Foldable f => Eq a => a -> f a -> Boolean\nnotElem x = not <<< elem x\n\n-- | Try to get nth element from the left in a data structure\nindexl :: forall a f. Foldable f => Int -> f a -> Maybe a\nindexl idx = _.elem <<< foldl go { elem: Nothing, pos: 0 }\n  where\n  go cursor a =\n    case cursor.elem of\n      Just _ -> cursor\n      _ ->\n        if cursor.pos == idx\n          then { elem: Just a, pos: cursor.pos }\n          else { pos: cursor.pos + 1, elem: cursor.elem }\n\n-- | Try to get nth element from the right in a data structure\nindexr :: forall a f. Foldable f => Int -> f a -> Maybe a\nindexr idx = _.elem <<< foldr go { elem: Nothing, pos: 0 }\n  where\n  go a cursor =\n    case cursor.elem of\n      Just _ -> cursor\n      _ ->\n        if cursor.pos == idx\n          then { elem: Just a, pos: cursor.pos }\n          else { pos: cursor.pos + 1, elem: cursor.elem }\n\n-- | Try to find an element in a data structure which satisfies a predicate.\nfind :: forall a f. Foldable f => (a -> Boolean) -> f a -> Maybe a\nfind p = foldl go Nothing\n  where\n  go Nothing x | p x = Just x\n  go r _ = r\n\n-- | Try to find an element in a data structure which satisfies a predicate mapping.\nfindMap :: forall a b f. Foldable f => (a -> Maybe b) -> f a -> Maybe b\nfindMap p = foldl go Nothing\n  where\n  go Nothing x = p x\n  go r _ = r\n\n-- | Find the largest element of a structure, according to its `Ord` instance.\nmaximum :: forall a f. Ord a => Foldable f => f a -> Maybe a\nmaximum = maximumBy compare\n\n-- | Find the largest element of a structure, according to a given comparison\n-- | function. The comparison function should represent a total ordering (see\n-- | the `Ord` type class laws); if it does not, the behaviour is undefined.\nmaximumBy :: forall a f. Foldable f => (a -> a -> Ordering) -> f a -> Maybe a\nmaximumBy cmp = foldl max' Nothing\n  where\n  max' Nothing x  = Just x\n  max' (Just x) y = Just (if cmp x y == GT then x else y)\n\n-- | Find the smallest element of a structure, according to its `Ord` instance.\nminimum :: forall a f. Ord a => Foldable f => f a -> Maybe a\nminimum = minimumBy compare\n\n-- | Find the smallest element of a structure, according to a given comparison\n-- | function. The comparison function should represent a total ordering (see\n-- | the `Ord` type class laws); if it does not, the behaviour is undefined.\nminimumBy :: forall a f. Foldable f => (a -> a -> Ordering) -> f a -> Maybe a\nminimumBy cmp = foldl min' Nothing\n  where\n  min' Nothing x  = Just x\n  min' (Just x) y = Just (if cmp x y == LT then x else y)\n\n-- | Test whether the structure is empty.\n-- | Optimized for structures that are similar to cons-lists, because there\n-- | is no general way to do better.\nnull :: forall a f. Foldable f => f a -> Boolean\nnull = foldr (\\_ _ -> false) true\n\n-- | Returns the size/length of a finite structure.\n-- | Optimized for structures that are similar to cons-lists, because there\n-- | is no general way to do better.\nlength :: forall a b f. Foldable f => Semiring b => f a -> b\nlength = foldl (\\c _ -> add one c) zero\n\n-- | Lookup a value in a data structure of `Tuple`s, generalizing association lists.\nlookup :: forall a b f. Foldable f => Eq a => a -> f (Tuple a b) -> Maybe b\nlookup a = unwrap <<< foldMap \\(Tuple a' b) -> First (if a == a' then Just b else Nothing)\n", "// module Data.Function.Uncurried\n\nexport const mkFn0 = function (fn) {\n  return function () {\n    return fn();\n  };\n};\n\nexport const mkFn2 = function (fn) {\n  /* jshint maxparams: 2 */\n  return function (a, b) {\n    return fn(a)(b);\n  };\n};\n\nexport const mkFn3 = function (fn) {\n  /* jshint maxparams: 3 */\n  return function (a, b, c) {\n    return fn(a)(b)(c);\n  };\n};\n\nexport const mkFn4 = function (fn) {\n  /* jshint maxparams: 4 */\n  return function (a, b, c, d) {\n    return fn(a)(b)(c)(d);\n  };\n};\n\nexport const mkFn5 = function (fn) {\n  /* jshint maxparams: 5 */\n  return function (a, b, c, d, e) {\n    return fn(a)(b)(c)(d)(e);\n  };\n};\n\nexport const mkFn6 = function (fn) {\n  /* jshint maxparams: 6 */\n  return function (a, b, c, d, e, f) {\n    return fn(a)(b)(c)(d)(e)(f);\n  };\n};\n\nexport const mkFn7 = function (fn) {\n  /* jshint maxparams: 7 */\n  return function (a, b, c, d, e, f, g) {\n    return fn(a)(b)(c)(d)(e)(f)(g);\n  };\n};\n\nexport const mkFn8 = function (fn) {\n  /* jshint maxparams: 8 */\n  return function (a, b, c, d, e, f, g, h) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h);\n  };\n};\n\nexport const mkFn9 = function (fn) {\n  /* jshint maxparams: 9 */\n  return function (a, b, c, d, e, f, g, h, i) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i);\n  };\n};\n\nexport const mkFn10 = function (fn) {\n  /* jshint maxparams: 10 */\n  return function (a, b, c, d, e, f, g, h, i, j) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)(j);\n  };\n};\n\nexport const runFn0 = function (fn) {\n  return fn();\n};\n\nexport const runFn2 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return fn(a, b);\n    };\n  };\n};\n\nexport const runFn3 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return fn(a, b, c);\n      };\n    };\n  };\n};\n\nexport const runFn4 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return fn(a, b, c, d);\n        };\n      };\n    };\n  };\n};\n\nexport const runFn5 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return fn(a, b, c, d, e);\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn6 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return fn(a, b, c, d, e, f);\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn7 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return fn(a, b, c, d, e, f, g);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn8 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return fn(a, b, c, d, e, f, g, h);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn9 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return function (i) {\n                    return fn(a, b, c, d, e, f, g, h, i);\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn10 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return function (i) {\n                    return function (j) {\n                      return fn(a, b, c, d, e, f, g, h, i, j);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n", "module Data.Functor.Compose where\n\nimport Prelude\n\nimport Control.Alt (class Alt, alt)\nimport Control.Alternative (class Alternative)\nimport Control.Plus (class Plus, empty)\nimport Data.Eq (class Eq1, eq1)\nimport Data.Functor.App (hoistLiftApp)\nimport Data.Newtype (class Newtype)\nimport Data.Ord (class Ord1, compare1)\n\n-- | `Compose f g` is the composition of the two functors `f` and `g`.\nnewtype Compose :: forall k1 k2. (k2 -> Type) -> (k1 -> k2) -> k1 -> Type\nnewtype Compose f g a = Compose (f (g a))\n\nbihoistCompose\n  :: forall f g h i\n   . Functor f\n  => (f ~> h)\n  -> (g ~> i)\n  -> Compose f g\n  ~> Compose h i\nbihoistCompose natF natG (Compose fga) = Compose (natF (map natG fga))\n\nderive instance newtypeCompose :: Newtype (Compose f g a) _\n\ninstance eqCompose :: (Eq1 f, Eq1 g, Eq a) => Eq (Compose f g a) where\n  eq (Compose fga1) (Compose fga2) =\n    eq1 (hoistLiftApp fga1) (hoistLiftApp fga2)\n\nderive instance eq1Compose :: (Eq1 f, Eq1 g) => Eq1 (Compose f g)\n\ninstance ordCompose :: (Ord1 f, Ord1 g, Ord a) => Ord (Compose f g a) where\n  compare (Compose fga1) (Compose fga2) =\n    compare1 (hoistLiftApp fga1) (hoistLiftApp fga2)\n\nderive instance ord1Compose :: (Ord1 f, Ord1 g) => Ord1 (Compose f g)\n\ninstance showCompose :: Show (f (g a)) => Show (Compose f g a) where\n  show (Compose fga) = \"(Compose \" <> show fga <> \")\"\n\ninstance functorCompose :: (Functor f, Functor g) => Functor (Compose f g) where\n  map f (Compose fga) = Compose $ map f <$> fga\n\ninstance applyCompose :: (Apply f, Apply g) => Apply (Compose f g) where\n  apply (Compose f) (Compose x) = Compose $ apply <$> f <*> x\n\ninstance applicativeCompose :: (Applicative f, Applicative g) => Applicative (Compose f g) where\n  pure = Compose <<< pure <<< pure\n\ninstance altCompose :: (Alt f, Functor g) => Alt (Compose f g) where\n  alt (Compose a) (Compose b) = Compose $ alt a b\n\ninstance plusCompose :: (Plus f, Functor g) => Plus (Compose f g) where\n  empty = Compose empty\n\ninstance alternativeCompose :: (Alternative f, Applicative g) => Alternative (Compose f g)\n", "-- | Helper functions for working with immutable Javascript arrays.\n-- |\n-- | _Note_: Depending on your use-case, you may prefer to use `Data.List` or\n-- | `Data.Sequence` instead, which might give better performance for certain\n-- | use cases. This module is useful when integrating with JavaScript libraries\n-- | which use arrays, but immutable arrays are not a practical data structure\n-- | for many use cases due to their poor asymptotics.\n-- |\n-- | In addition to the functions in this module, Arrays have a number of\n-- | useful instances:\n-- |\n-- | * `Functor`, which provides `map :: forall a b. (a -> b) -> Array a ->\n-- |   Array b`\n-- | * `Apply`, which provides `(<*>) :: forall a b. Array (a -> b) -> Array a\n-- |   -> Array b`. This function works a bit like a Cartesian product; the\n-- |   result array is constructed by applying each function in the first\n-- |   array to each value in the second, so that the result array ends up with\n-- |   a length equal to the product of the two arguments' lengths.\n-- | * `Bind`, which provides `(>>=) :: forall a b. (a -> Array b) -> Array a\n-- |   -> Array b` (this is the same as `concatMap`).\n-- | * `Semigroup`, which provides `(<>) :: forall a. Array a -> Array a ->\n-- |   Array a`, for concatenating arrays.\n-- | * `Foldable`, which provides a slew of functions for *folding* (also known\n-- |   as *reducing*) arrays down to one value. For example,\n-- |   `Data.Foldable.or` tests whether an array of `Boolean` values contains\n-- |   at least one `true` value.\n-- | * `Traversable`, which provides the PureScript version of a for-loop,\n-- |   allowing you to STAI.iterate over an array and accumulate effects.\n-- |\nmodule Data.Array\n  ( fromFoldable\n  , toUnfoldable\n  , singleton\n  , (..)\n  , range\n  , replicate\n  , some\n  , many\n\n  , null\n  , length\n\n  , (:)\n  , cons\n  , snoc\n  , insert\n  , insertBy\n\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n\n  , (!!)\n  , index\n  , elem\n  , notElem\n  , elemIndex\n  , elemLastIndex\n  , find\n  , findMap\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , deleteAt\n  , updateAt\n  , updateAtIndices\n  , modifyAt\n  , modifyAtIndices\n  , alterAt\n\n  , intersperse\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , partition\n  , splitAt\n  , filterA\n  , mapMaybe\n  , catMaybes\n  , mapWithIndex\n  , foldl\n  , foldr\n  , foldMap\n  , fold\n  , intercalate\n  , transpose\n  , scanl\n  , scanr\n\n  , sort\n  , sortBy\n  , sortWith\n  , slice\n  , take\n  , takeEnd\n  , takeWhile\n  , drop\n  , dropEnd\n  , dropWhile\n  , span\n  , group\n  , groupAll\n  , groupBy\n  , groupAllBy\n\n  , nub\n  , nubEq\n  , nubBy\n  , nubByEq\n  , union\n  , unionBy\n  , delete\n  , deleteBy\n\n  , (\\\\)\n  , difference\n  , intersect\n  , intersectBy\n\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n\n  , any\n  , all\n\n  , foldM\n  , foldRecM\n\n  , unsafeIndex\n  ) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Lazy (class Lazy, defer)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..), tailRecM2)\nimport Control.Monad.ST as ST\nimport Data.Array.NonEmpty.Internal (NonEmptyArray(..))\nimport Data.Array.ST as STA\nimport Data.Array.ST.Iterator as STAI\nimport Data.Foldable (class Foldable, traverse_)\nimport Data.Foldable as F\nimport Data.Function.Uncurried (Fn2, Fn3, Fn4, Fn5, runFn2, runFn3, runFn4, runFn5)\nimport Data.FunctorWithIndex as FWI\nimport Data.Maybe (Maybe(..), maybe, isJust, fromJust, isNothing)\nimport Data.Traversable (sequence, traverse)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Data.Unfoldable (class Unfoldable, unfoldr)\nimport Partial.Unsafe (unsafePartial)\n\n-- | Convert an `Array` into an `Unfoldable` structure.\ntoUnfoldable :: forall f. Unfoldable f => Array ~> f\ntoUnfoldable xs = unfoldr f 0\n  where\n  len = length xs\n  f i\n    | i < len = Just (Tuple (unsafePartial (unsafeIndex xs i)) (i + 1))\n    | otherwise = Nothing\n\n-- | Convert a `Foldable` structure into an `Array`.\n-- |\n-- | ```purescript\n-- | fromFoldable (Just 1) = [1]\n-- | fromFoldable (Nothing) = []\n-- | ```\n-- |\nfromFoldable :: forall f. Foldable f => f ~> Array\nfromFoldable = runFn2 fromFoldableImpl F.foldr\n\nforeign import fromFoldableImpl\n  :: forall f a\n   . Fn2 (forall b. (a -> b -> b) -> b -> f a -> b) (f a) (Array a)\n\n-- | Create an array of one element\n-- | ```purescript\n-- | singleton 2 = [2]\n-- | ```\nsingleton :: forall a. a -> Array a\nsingleton a = [ a ]\n\n-- | Create an array containing a range of integers, including both endpoints.\n-- | ```purescript\n-- | range 2 5 = [2, 3, 4, 5]\n-- | ```\nrange :: Int -> Int -> Array Int\nrange = runFn2 rangeImpl\n\nforeign import rangeImpl :: Fn2 Int Int (Array Int)\n\n-- | Create an array containing a value repeated the specified number of times.\n-- | ```purescript\n-- | replicate 2 \"Hi\" = [\"Hi\", \"Hi\"]\n-- | ```\nreplicate :: forall a. Int -> a -> Array a\nreplicate = runFn2 replicateImpl\n\nforeign import replicateImpl :: forall a. Fn2 Int a (Array a)\n\n-- | An infix synonym for `range`.\n-- | ```purescript\n-- | 2 .. 5 = [2, 3, 4, 5]\n-- | ```\ninfix 8 range as ..\n\n-- | Attempt a computation multiple times, requiring at least one success.\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nsome :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\nsome v = (:) <$> v <*> defer (\\_ -> many v)\n\n-- | Attempt a computation multiple times, returning as many successful results\n-- | as possible (possibly zero).\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nmany :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\nmany v = some v <|> pure []\n\n--------------------------------------------------------------------------------\n-- Array size ------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Test whether an array is empty.\n-- | ```purescript\n-- | null [] = true\n-- | null [1, 2] = false\n-- | ```\nnull :: forall a. Array a -> Boolean\nnull xs = length xs == 0\n\n-- | Get the number of elements in an array.\n-- | ```purescript\n-- | length [\"Hello\", \"World\"] = 2\n-- | ```\nforeign import length :: forall a. Array a -> Int\n\n--------------------------------------------------------------------------------\n-- Extending arrays ------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Attaches an element to the front of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | cons 1 [2, 3, 4] = [1, 2, 3, 4]\n-- | ```\n-- |\n-- | Note, the running time of this function is `O(n)`.\ncons :: forall a. a -> Array a -> Array a\ncons x xs = [ x ] <> xs\n\n-- | An infix alias for `cons`.\n-- |\n-- | ```purescript\n-- | 1 : [2, 3, 4] = [1, 2, 3, 4]\n-- | ```\n-- |\n-- | Note, the running time of this function is `O(n)`.\ninfixr 6 cons as :\n\n-- | Append an element to the end of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | snoc [1, 2, 3] 4 = [1, 2, 3, 4]\n-- | ```\n-- |\nsnoc :: forall a. Array a -> a -> Array a\nsnoc xs x = ST.run (STA.withArray (STA.push x) xs)\n\n-- | Insert an element into a sorted array.\n-- |\n-- | ```purescript\n-- | insert 10 [1, 2, 20, 21] = [1, 2, 10, 20, 21]\n-- | ```\n-- |\ninsert :: forall a. Ord a => a -> Array a -> Array a\ninsert = insertBy compare\n\n-- | Insert an element into a sorted array, using the specified function to\n-- | determine the ordering of elements.\n-- |\n-- | ```purescript\n-- | invertCompare a b = invert $ compare a b\n-- |\n-- | insertBy invertCompare 10 [21, 20, 2, 1] = [21, 20, 10, 2, 1]\n-- | ```\n-- |\ninsertBy :: forall a. (a -> a -> Ordering) -> a -> Array a -> Array a\ninsertBy cmp x ys =\n  let\n    i = maybe 0 (_ + 1) (findLastIndex (\\y -> cmp x y == GT) ys)\n  in\n    unsafePartial (fromJust (insertAt i x ys))\n\n--------------------------------------------------------------------------------\n-- Non-indexed reads -----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Get the first element in an array, or `Nothing` if the array is empty\n-- |\n-- | Running time: `O(1)`.\n-- |\n-- | ```purescript\n-- | head [1, 2] = Just 1\n-- | head [] = Nothing\n-- | ```\n-- |\nhead :: forall a. Array a -> Maybe a\nhead xs = xs !! 0\n\n-- | Get the last element in an array, or `Nothing` if the array is empty\n-- |\n-- | Running time: `O(1)`.\n-- |\n-- | ```purescript\n-- | last [1, 2] = Just 2\n-- | last [] = Nothing\n-- | ```\n-- |\nlast :: forall a. Array a -> Maybe a\nlast xs = xs !! (length xs - 1)\n\n-- | Get all but the first element of an array, creating a new array, or\n-- | `Nothing` if the array is empty\n-- |\n-- | ```purescript\n-- | tail [1, 2, 3, 4] = Just [2, 3, 4]\n-- | tail [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\ntail :: forall a. Array a -> Maybe (Array a)\ntail = runFn3 unconsImpl (const Nothing) (\\_ xs -> Just xs)\n\n-- | Get all but the last element of an array, creating a new array, or\n-- | `Nothing` if the array is empty.\n-- |\n-- | ```purescript\n-- | init [1, 2, 3, 4] = Just [1, 2, 3]\n-- | init [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\ninit :: forall a. Array a -> Maybe (Array a)\ninit xs\n  | null xs = Nothing\n  | otherwise = Just (slice zero (length xs - one) xs)\n\n-- | Break an array into its first element and remaining elements.\n-- |\n-- | Using `uncons` provides a way of writing code that would use cons patterns\n-- | in Haskell or pre-PureScript 0.7:\n-- | ``` purescript\n-- | f (x : xs) = something\n-- | f [] = somethingElse\n-- | ```\n-- | Becomes:\n-- | ``` purescript\n-- | f arr = case uncons arr of\n-- |   Just { head: x, tail: xs } -> something\n-- |   Nothing -> somethingElse\n-- | ```\nuncons :: forall a. Array a -> Maybe { head :: a, tail :: Array a }\nuncons = runFn3 unconsImpl (const Nothing) \\x xs -> Just { head: x, tail: xs }\n\nforeign import unconsImpl\n  :: forall a b\n   . Fn3 (Unit -> b) (a -> Array a -> b) (Array a) b\n\n-- | Break an array into its last element and all preceding elements.\n-- |\n-- | ```purescript\n-- | unsnoc [1, 2, 3] = Just {init: [1, 2], last: 3}\n-- | unsnoc [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\nunsnoc :: forall a. Array a -> Maybe { init :: Array a, last :: a }\nunsnoc xs = { init: _, last: _ } <$> init xs <*> last xs\n\n--------------------------------------------------------------------------------\n-- Indexed operations ----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | This function provides a safe way to read a value at a particular index\n-- | from an array.\n-- |\n-- | ```purescript\n-- | sentence = [\"Hello\", \"World\", \"!\"]\n-- |\n-- | index sentence 0 = Just \"Hello\"\n-- | index sentence 7 = Nothing\n-- | ```\n-- |\nindex :: forall a. Array a -> Int -> Maybe a\nindex = runFn4 indexImpl Just Nothing\n\nforeign import indexImpl\n  :: forall a\n   . Fn4 (forall r. r -> Maybe r) (forall r. Maybe r) (Array a) Int (Maybe a)\n\n-- | An infix version of `index`.\n-- |\n-- | ```purescript\n-- | sentence = [\"Hello\", \"World\", \"!\"]\n-- |\n-- | sentence !! 0 = Just \"Hello\"\n-- | sentence !! 7 = Nothing\n-- | ```\n-- |\ninfixl 8 index as !!\n\n-- | Returns true if the array has the given element.\nelem :: forall a. Eq a => a -> Array a -> Boolean\nelem a arr = isJust $ elemIndex a arr\n\n-- | Returns true if the array does not have the given element.\nnotElem :: forall a. Eq a => a -> Array a -> Boolean\nnotElem a arr = isNothing $ elemIndex a arr\n\n-- | Find the index of the first element equal to the specified element.\n-- |\n-- | ```purescript\n-- | elemIndex \"a\" [\"a\", \"b\", \"a\", \"c\"] = Just 0\n-- | elemIndex \"Earth\" [\"Hello\", \"World\", \"!\"] = Nothing\n-- | ```\n-- |\nelemIndex :: forall a. Eq a => a -> Array a -> Maybe Int\nelemIndex x = findIndex (_ == x)\n\n-- | Find the index of the last element equal to the specified element.\n-- |\n-- | ```purescript\n-- | elemLastIndex \"a\" [\"a\", \"b\", \"a\", \"c\"] = Just 2\n-- | elemLastIndex \"Earth\" [\"Hello\", \"World\", \"!\"] = Nothing\n-- | ```\n-- |\nelemLastIndex :: forall a. Eq a => a -> Array a -> Maybe Int\nelemLastIndex x = findLastIndex (_ == x)\n\n-- | Find the first element for which a predicate holds.\n-- |\n-- | ```purescript\n-- | find (contains $ Pattern \"b\") [\"a\", \"bb\", \"b\", \"d\"] = Just \"bb\"\n-- | find (contains $ Pattern \"x\") [\"a\", \"bb\", \"b\", \"d\"] = Nothing\n-- | ```\nfind :: forall a. (a -> Boolean) -> Array a -> Maybe a\nfind f xs = unsafePartial (unsafeIndex xs) <$> findIndex f xs\n\n-- | Find the first element in a data structure which satisfies\n-- | a predicate mapping.\nfindMap :: forall a b. (a -> Maybe b) -> Array a -> Maybe b\nfindMap = runFn4 findMapImpl Nothing isJust\n\nforeign import findMapImpl\n  :: forall a b\n   . Fn4\n       (forall c. Maybe c)\n       (forall c. Maybe c -> Boolean)\n       (a -> Maybe b)\n       (Array a)\n       (Maybe b)\n\n-- | Find the first index for which a predicate holds.\n-- |\n-- | ```purescript\n-- | findIndex (contains $ Pattern \"b\") [\"a\", \"bb\", \"b\", \"d\"] = Just 1\n-- | findIndex (contains $ Pattern \"x\") [\"a\", \"bb\", \"b\", \"d\"] = Nothing\n-- | ```\n-- |\nfindIndex :: forall a. (a -> Boolean) -> Array a -> Maybe Int\nfindIndex = runFn4 findIndexImpl Just Nothing\n\nforeign import findIndexImpl\n  :: forall a\n   . Fn4\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       (a -> Boolean)\n       (Array a)\n       (Maybe Int)\n\n-- | Find the last index for which a predicate holds.\n-- |\n-- | ```purescript\n-- | findLastIndex (contains $ Pattern \"b\") [\"a\", \"bb\", \"b\", \"d\"] = Just 2\n-- | findLastIndex (contains $ Pattern \"x\") [\"a\", \"bb\", \"b\", \"d\"] = Nothing\n-- | ```\n-- |\nfindLastIndex :: forall a. (a -> Boolean) -> Array a -> Maybe Int\nfindLastIndex = runFn4 findLastIndexImpl Just Nothing\n\nforeign import findLastIndexImpl\n  :: forall a\n   . Fn4\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       (a -> Boolean)\n       (Array a)\n       (Maybe Int)\n\n-- | Insert an element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | insertAt 2 \"!\" [\"Hello\", \"World\"] = Just [\"Hello\", \"World\", \"!\"]\n-- | insertAt 10 \"!\" [\"Hello\"] = Nothing\n-- | ```\n-- |\ninsertAt :: forall a. Int -> a -> Array a -> Maybe (Array a)\ninsertAt = runFn5 _insertAt Just Nothing\n\nforeign import _insertAt\n  :: forall a\n   . Fn5\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       Int\n       a\n       (Array a)\n       (Maybe (Array a))\n\n-- | Delete the element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | deleteAt 0 [\"Hello\", \"World\"] = Just [\"World\"]\n-- | deleteAt 10 [\"Hello\", \"World\"] = Nothing\n-- | ```\n-- |\ndeleteAt :: forall a. Int -> Array a -> Maybe (Array a)\ndeleteAt = runFn4 _deleteAt Just Nothing\n\nforeign import _deleteAt\n  :: forall a\n   . Fn4\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       Int\n       (Array a)\n       (Maybe (Array a))\n\n-- | Change the element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | updateAt 1 \"World\" [\"Hello\", \"Earth\"] = Just [\"Hello\", \"World\"]\n-- | updateAt 10 \"World\" [\"Hello\", \"Earth\"] = Nothing\n-- | ```\n-- |\nupdateAt :: forall a. Int -> a -> Array a -> Maybe (Array a)\nupdateAt = runFn5 _updateAt Just Nothing\n\nforeign import _updateAt\n  :: forall a\n   . Fn5\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       Int\n       a\n       (Array a)\n       (Maybe (Array a))\n\n-- | Apply a function to the element at the specified index, creating a new\n-- | array, or returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | modifyAt 1 toUpper [\"Hello\", \"World\"] = Just [\"Hello\", \"WORLD\"]\n-- | modifyAt 10 toUpper [\"Hello\", \"World\"] = Nothing\n-- | ```\n-- |\nmodifyAt :: forall a. Int -> (a -> a) -> Array a -> Maybe (Array a)\nmodifyAt i f xs = maybe Nothing go (xs !! i)\n  where\n  go x = updateAt i (f x) xs\n\n-- | Update or delete the element at the specified index by applying a\n-- | function to the current value, returning a new array or `Nothing` if the\n-- | index is out-of-bounds.\n-- |\n-- | ```purescript\n-- | alterAt 1 (stripSuffix $ Pattern \"!\") [\"Hello\", \"World!\"]\n-- |    = Just [\"Hello\", \"World\"]\n-- |\n-- | alterAt 1 (stripSuffix $ Pattern \"!!!!!\") [\"Hello\", \"World!\"]\n-- |    = Just [\"Hello\"]\n-- |\n-- | alterAt 10 (stripSuffix $ Pattern \"!\") [\"Hello\", \"World!\"] = Nothing\n-- | ```\n-- |\nalterAt :: forall a. Int -> (a -> Maybe a) -> Array a -> Maybe (Array a)\nalterAt i f xs = maybe Nothing go (xs !! i)\n  where\n  go x = case f x of\n    Nothing -> deleteAt i xs\n    Just x' -> updateAt i x' xs\n\n--------------------------------------------------------------------------------\n-- Transformations -------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Inserts the given element in between each element in the array. The array\n-- | must have two or more elements for this operation to take effect.\n-- |\n-- | ```purescript\n-- | intersperse \" \" [ \"a\", \"b\" ] == [ \"a\", \" \", \"b\" ]\n-- | intersperse 0 [ 1, 2, 3, 4, 5 ] == [ 1, 0, 2, 0, 3, 0, 4, 0, 5 ]\n-- | ```\n-- |\n-- | If the array has less than two elements, the input array is returned.\n-- | ```purescript\n-- | intersperse \" \" [] == []\n-- | intersperse \" \" [\"a\"] == [\"a\"]\n-- | ```\nintersperse :: forall a. a -> Array a -> Array a\nintersperse a arr = case length arr of\n  len\n    | len < 2 -> arr\n    | otherwise -> STA.run do\n        let unsafeGetElem idx = unsafePartial (unsafeIndex arr idx)\n        out <- STA.new\n        _ <- STA.push (unsafeGetElem 0) out\n        ST.for 1 len \\idx -> do\n          _ <- STA.push a out\n          void (STA.push (unsafeGetElem idx) out)\n        pure out\n\n-- | Reverse an array, creating a new array.\n-- |\n-- | ```purescript\n-- | reverse [] = []\n-- | reverse [1, 2, 3] = [3, 2, 1]\n-- | ```\n-- |\nforeign import reverse :: forall a. Array a -> Array a\n\n-- | Flatten an array of arrays, creating a new array.\n-- |\n-- | ```purescript\n-- | concat [[1, 2, 3], [], [4, 5, 6]] = [1, 2, 3, 4, 5, 6]\n-- | ```\n-- |\nforeign import concat :: forall a. Array (Array a) -> Array a\n\n-- | Apply a function to each element in an array, and flatten the results\n-- | into a single, new array.\n-- |\n-- | ```purescript\n-- | concatMap (split $ Pattern \" \") [\"Hello World\", \"other thing\"]\n-- |    = [\"Hello\", \"World\", \"other\", \"thing\"]\n-- | ```\n-- |\nconcatMap :: forall a b. (a -> Array b) -> Array a -> Array b\nconcatMap = flip bind\n\n-- | Filter an array, keeping the elements which satisfy a predicate function,\n-- | creating a new array.\n-- |\n-- | ```purescript\n-- | filter (_ > 0) [-1, 4, -5, 7] = [4, 7]\n-- | ```\n-- |\nfilter :: forall a. (a -> Boolean) -> Array a -> Array a\nfilter = runFn2 filterImpl\n\nforeign import filterImpl\n  :: forall a\n   . Fn2 (a -> Boolean) (Array a) (Array a)\n\n-- | Partition an array using a predicate function, creating a set of\n-- | new arrays. One for the values satisfying the predicate function\n-- | and one for values that don't.\n-- |\n-- | ```purescript\n-- | partition (_ > 0) [-1, 4, -5, 7] = { yes: [4, 7], no: [-1, -5] }\n-- | ```\n-- |\npartition\n  :: forall a\n   . (a -> Boolean)\n  -> Array a\n  -> { yes :: Array a, no :: Array a }\npartition = runFn2 partitionImpl\n\nforeign import partitionImpl\n  :: forall a\n   . Fn2 (a -> Boolean) (Array a) { yes :: Array a, no :: Array a }\n\n-- | Splits an array into two subarrays, where `before` contains the elements\n-- | up to (but not including) the given index, and `after` contains the rest\n-- | of the elements, from that index on.\n-- |\n-- | ```purescript\n-- | >>> splitAt 3 [1, 2, 3, 4, 5]\n-- | { before: [1, 2, 3], after: [4, 5] }\n-- | ```\n-- |\n-- | Thus, the length of `(splitAt i arr).before` will equal either `i` or\n-- | `length arr`, if that is shorter. (Or if `i` is negative the length will\n-- | be 0.)\n-- |\n-- | ```purescript\n-- | splitAt 2 ([] :: Array Int) == { before: [], after: [] }\n-- | splitAt 3 [1, 2, 3, 4, 5] == { before: [1, 2, 3], after: [4, 5] }\n-- | ```\nsplitAt :: forall a. Int -> Array a -> { before :: Array a, after :: Array a }\nsplitAt i xs | i <= 0 = { before: [], after: xs }\nsplitAt i xs = { before: slice 0 i xs, after: slice i (length xs) xs }\n\n-- | Filter where the predicate returns a `Boolean` in some `Applicative`.\n-- |\n-- | ```purescript\n-- | powerSet :: forall a. Array a -> Array (Array a)\n-- | powerSet = filterA (const [true, false])\n-- | ```\nfilterA :: forall a f. Applicative f => (a -> f Boolean) -> Array a -> f (Array a)\nfilterA p =\n  traverse (\\x -> Tuple x <$> p x)\n    >>> map (mapMaybe (\\(Tuple x b) -> if b then Just x else Nothing))\n\n-- | Apply a function to each element in an array, keeping only the results\n-- | which contain a value, creating a new array.\n-- |\n-- | ```purescript\n-- | parseEmail :: String -> Maybe Email\n-- | parseEmail = ...\n-- |\n-- | mapMaybe parseEmail [\"a.com\", \"hello@example.com\", \"--\"]\n-- |    = [Email {user: \"hello\", domain: \"example.com\"}]\n-- | ```\n-- |\nmapMaybe :: forall a b. (a -> Maybe b) -> Array a -> Array b\nmapMaybe f = concatMap (maybe [] singleton <<< f)\n\n-- | Filter an array of optional values, keeping only the elements which contain\n-- | a value, creating a new array.\n-- |\n-- | ```purescript\n-- | catMaybes [Nothing, Just 2, Nothing, Just 4] = [2, 4]\n-- | ```\n-- |\ncatMaybes :: forall a. Array (Maybe a) -> Array a\ncatMaybes = mapMaybe identity\n\n-- | Apply a function to each element in an array, supplying a generated\n-- | zero-based index integer along with the element, creating an array\n-- | with the new elements.\n-- |\n-- | ```purescript\n-- | prefixIndex index element = show index <> element\n-- |\n-- | mapWithIndex prefixIndex [\"Hello\", \"World\"] = [\"0Hello\", \"1World\"]\n-- | ```\n-- |\nmapWithIndex :: forall a b. (Int -> a -> b) -> Array a -> Array b\nmapWithIndex = FWI.mapWithIndex\n\n-- | Change the elements at the specified indices in index/value pairs.\n-- | Out-of-bounds indices will have no effect.\n-- |\n-- | ```purescript\n-- | updates = [Tuple 0 \"Hi\", Tuple 2 \".\" , Tuple 10 \"foobar\"]\n-- |\n-- | updateAtIndices updates [\"Hello\", \"World\", \"!\"] = [\"Hi\", \"World\", \".\"]\n-- | ```\n-- |\nupdateAtIndices :: forall t a. Foldable t => t (Tuple Int a) -> Array a -> Array a\nupdateAtIndices us xs =\n  ST.run (STA.withArray (\\res -> traverse_ (\\(Tuple i a) -> STA.poke i a res) us) xs)\n\n-- | Apply a function to the element at the specified indices,\n-- | creating a new array. Out-of-bounds indices will have no effect.\n-- |\n-- | ```purescript\n-- | indices = [1, 3]\n-- | modifyAtIndices indices toUpper [\"Hello\", \"World\", \"and\", \"others\"]\n-- |    = [\"Hello\", \"WORLD\", \"and\", \"OTHERS\"]\n-- | ```\n-- |\nmodifyAtIndices :: forall t a. Foldable t => t Int -> (a -> a) -> Array a -> Array a\nmodifyAtIndices is f xs =\n  ST.run (STA.withArray (\\res -> traverse_ (\\i -> STA.modify i f res) is) xs)\n\nfoldl :: forall a b. (b -> a -> b) -> b -> Array a -> b\nfoldl = F.foldl\n\nfoldr :: forall a b. (a -> b -> b) -> b -> Array a -> b\nfoldr = F.foldr\n\nfoldMap :: forall a m. Monoid m => (a -> m) -> Array a -> m\nfoldMap = F.foldMap\n\nfold :: forall m. Monoid m => Array m -> m\nfold = F.fold\n\nintercalate :: forall a. Monoid a => a -> Array a -> a\nintercalate = F.intercalate\n\n-- | The 'transpose' function transposes the rows and columns of its argument.\n-- | For example,\n-- |\n-- | ```purescript\n-- | transpose \n-- |   [ [1, 2, 3]\n-- |   , [4, 5, 6]\n-- |   ] == \n-- |   [ [1, 4]\n-- |   , [2, 5]\n-- |   , [3, 6]\n-- |   ]\n-- | ```\n-- |\n-- | If some of the rows are shorter than the following rows, their elements are skipped:\n-- |\n-- | ```purescript\n-- | transpose \n-- |   [ [10, 11]\n-- |   , [20]\n-- |   , [30, 31, 32]\n-- |   ] == \n-- |   [ [10, 20, 30]\n-- |   , [11, 31]\n-- |   , [32]\n-- |   ]\n-- | ```\ntranspose :: forall a. Array (Array a) -> Array (Array a)\ntranspose xs = go 0 []\n  where\n  go :: Int -> Array (Array a) -> Array (Array a)\n  go idx allArrays = case buildNext idx of\n    Nothing -> allArrays\n    Just next -> go (idx + 1) (snoc allArrays next)\n\n  buildNext :: Int -> Maybe (Array a)\n  buildNext idx = do\n    xs # flip foldl Nothing \\acc nextArr -> do\n      maybe acc (\\el -> Just $ maybe [ el ] (flip snoc el) acc) $ index nextArr idx\n\n-- | Fold a data structure from the left, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanl`).\n-- |\n-- | ```\n-- | scanl (+) 0  [1,2,3] = [1,3,6]\n-- | scanl (-) 10 [1,2,3] = [9,7,4]\n-- | ```\nscanl :: forall a b. (b -> a -> b) -> b -> Array a -> Array b\nscanl = runFn3 scanlImpl\n\nforeign import scanlImpl :: forall a b. Fn3 (b -> a -> b) b (Array a) (Array b)\n\n-- | Fold a data structure from the right, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanr`).\n-- |\n-- | ```\n-- | scanr (+) 0 [1,2,3] = [6,5,3]\n-- | scanr (flip (-)) 10 [1,2,3] = [4,5,7]\n-- | ```\nscanr :: forall a b. (a -> b -> b) -> b -> Array a -> Array b\nscanr = runFn3 scanrImpl\n\nforeign import scanrImpl :: forall a b. Fn3 (a -> b -> b) b (Array a) (Array b)\n\n--------------------------------------------------------------------------------\n-- Sorting ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Sort the elements of an array in increasing order, creating a new array.\n-- | Sorting is stable: the order of equal elements is preserved.\n-- |\n-- | ```purescript\n-- | sort [2, -3, 1] = [-3, 1, 2]\n-- | ```\n-- |\nsort :: forall a. Ord a => Array a -> Array a\nsort xs = sortBy compare xs\n\n-- | Sort the elements of an array in increasing order, where elements are\n-- | compared using the specified partial ordering, creating a new array.\n-- | Sorting is stable: the order of elements is preserved if they are equal\n-- | according to the specified partial ordering.\n-- |\n-- | ```purescript\n-- | compareLength a b = compare (length a) (length b)\n-- | sortBy compareLength [[1, 2, 3], [7, 9], [-2]] = [[-2],[7,9],[1,2,3]]\n-- | ```\n-- |\nsortBy :: forall a. (a -> a -> Ordering) -> Array a -> Array a\nsortBy comp = runFn3 sortByImpl comp case _ of\n  GT -> 1\n  EQ -> 0\n  LT -> -1\n\n-- | Sort the elements of an array in increasing order, where elements are\n-- | sorted based on a projection. Sorting is stable: the order of elements is\n-- | preserved if they are equal according to the projection.\n-- |\n-- | ```purescript\n-- | sortWith (_.age) [{name: \"Alice\", age: 42}, {name: \"Bob\", age: 21}]\n-- |    = [{name: \"Bob\", age: 21}, {name: \"Alice\", age: 42}]\n-- | ```\n-- |\nsortWith :: forall a b. Ord b => (a -> b) -> Array a -> Array a\nsortWith f = sortBy (comparing f)\n\nforeign import sortByImpl :: forall a. Fn3 (a -> a -> Ordering) (Ordering -> Int) (Array a) (Array a)\n\n--------------------------------------------------------------------------------\n-- Subarrays -------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Extract a subarray by a start and end index.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- | slice 1 3 letters = [\"b\", \"c\"]\n-- | slice 5 7 letters = []\n-- | slice 4 1 letters = []\n-- | ```\n-- |\nslice :: forall a. Int -> Int -> Array a -> Array a\nslice = runFn3 sliceImpl\n\nforeign import sliceImpl :: forall a. Fn3 Int Int (Array a) (Array a)\n\n-- | Keep only a number of elements from the start of an array, creating a new\n-- | array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- |\n-- | take 2 letters = [\"a\", \"b\"]\n-- | take 100 letters = [\"a\", \"b\", \"c\"]\n-- | ```\n-- |\ntake :: forall a. Int -> Array a -> Array a\ntake n xs = if n < 1 then [] else slice 0 n xs\n\n-- | Keep only a number of elements from the end of an array, creating a new\n-- | array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- |\n-- | takeEnd 2 letters = [\"b\", \"c\"]\n-- | takeEnd 100 letters = [\"a\", \"b\", \"c\"]\n-- | ```\n-- |\ntakeEnd :: forall a. Int -> Array a -> Array a\ntakeEnd n xs = drop (length xs - n) xs\n\n-- | Calculate the longest initial subarray for which all element satisfy the\n-- | specified predicate, creating a new array.\n-- |\n-- | ```purescript\n-- | takeWhile (_ > 0) [4, 1, 0, -4, 5] = [4, 1]\n-- | takeWhile (_ > 0) [-1, 4] = []\n-- | ```\n-- |\ntakeWhile :: forall a. (a -> Boolean) -> Array a -> Array a\ntakeWhile p xs = (span p xs).init\n\n-- | Drop a number of elements from the start of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\", \"d\"]\n-- |\n-- | drop 2 letters = [\"c\", \"d\"]\n-- | drop 10 letters = []\n-- | ```\n-- |\ndrop :: forall a. Int -> Array a -> Array a\ndrop n xs = if n < 1 then xs else slice n (length xs) xs\n\n-- | Drop a number of elements from the end of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\", \"d\"]\n-- |\n-- | dropEnd 2 letters = [\"a\", \"b\"]\n-- | dropEnd 10 letters = []\n-- | ```\n-- |\ndropEnd :: forall a. Int -> Array a -> Array a\ndropEnd n xs = take (length xs - n) xs\n\n-- | Remove the longest initial subarray for which all element satisfy the\n-- | specified predicate, creating a new array.\n-- |\n-- | ```purescript\n-- | dropWhile (_ < 0) [-3, -1, 0, 4, -6] = [0, 4, -6]\n-- | ```\n-- |\ndropWhile :: forall a. (a -> Boolean) -> Array a -> Array a\ndropWhile p xs = (span p xs).rest\n\n-- | Split an array into two parts:\n-- |\n-- | 1. the longest initial subarray for which all elements satisfy the\n-- |    specified predicate\n-- | 2. the remaining elements\n-- |\n-- | ```purescript\n-- | span (\\n -> n % 2 == 1) [1,3,2,4,5] == { init: [1,3], rest: [2,4,5] }\n-- | ```\n-- |\n-- | Running time: `O(n)`.\nspan\n  :: forall a\n   . (a -> Boolean)\n  -> Array a\n  -> { init :: Array a, rest :: Array a }\nspan p arr =\n  case breakIndex of\n    Just 0 ->\n      { init: [], rest: arr }\n    Just i ->\n      { init: slice 0 i arr, rest: slice i (length arr) arr }\n    Nothing ->\n      { init: arr, rest: [] }\n  where\n  breakIndex = go 0\n  go i =\n    -- This looks like a good opportunity to use the Monad Maybe instance,\n    -- but it's important to write out an explicit case expression here in\n    -- order to ensure that TCO is triggered.\n    case index arr i of\n      Just x -> if p x then go (i + 1) else Just i\n      Nothing -> Nothing\n\n-- | Group equal, consecutive elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | group [1, 1, 2, 2, 1] == [NonEmptyArray [1, 1], NonEmptyArray [2, 2], NonEmptyArray [1]]\n-- | ```\ngroup :: forall a. Eq a => Array a -> Array (NonEmptyArray a)\ngroup xs = groupBy eq xs\n\n-- | Group equal elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | groupAll [1, 1, 2, 2, 1] == [NonEmptyArray [1, 1, 1], NonEmptyArray [2, 2]]\n-- | ```\ngroupAll :: forall a. Ord a => Array a -> Array (NonEmptyArray a)\ngroupAll = groupAllBy compare\n\n-- | Group equal, consecutive elements of an array into arrays, using the\n-- | specified equivalence relation to determine equality.\n-- |\n-- | ```purescript\n-- | groupBy (\\a b -> odd a && odd b) [1, 3, 2, 4, 3, 3]\n-- |    = [NonEmptyArray [1, 3], NonEmptyArray [2], NonEmptyArray [4], NonEmptyArray [3, 3]]\n-- | ```\n-- |\ngroupBy :: forall a. (a -> a -> Boolean) -> Array a -> Array (NonEmptyArray a)\ngroupBy op xs =\n  ST.run do\n    result <- STA.new\n    iter <- STAI.iterator (xs !! _)\n    STAI.iterate iter \\x -> void do\n      sub <- STA.new\n      _ <- STA.push x sub\n      STAI.pushWhile (op x) iter sub\n      grp <- STA.unsafeFreeze sub\n      STA.push (NonEmptyArray grp) result\n    STA.unsafeFreeze result\n\n-- | Group equal elements of an array into arrays, using the specified\n-- | comparison function to determine equality.\n-- |\n-- | ```purescript\n-- | groupAllBy (comparing Down) [1, 3, 2, 4, 3, 3]\n-- |    = [NonEmptyArray [4], NonEmptyArray [3, 3, 3], NonEmptyArray [2], NonEmptyArray [1]]\n-- | ```\n-- |\ngroupAllBy :: forall a. (a -> a -> Ordering) -> Array a -> Array (NonEmptyArray a)\ngroupAllBy cmp = groupBy (\\x y -> cmp x y == EQ) <<< sortBy cmp\n\n-- | Remove the duplicates from an array, creating a new array.\n-- |\n-- | ```purescript\n-- | nub [1, 2, 1, 3, 3] = [1, 2, 3]\n-- | ```\n-- |\nnub :: forall a. Ord a => Array a -> Array a\nnub = nubBy compare\n\n-- | Remove the duplicates from an array, creating a new array.\n-- |\n-- | This less efficient version of `nub` only requires an `Eq` instance.\n-- |\n-- | ```purescript\n-- | nubEq [1, 2, 1, 3, 3] = [1, 2, 3]\n-- | ```\n-- |\nnubEq :: forall a. Eq a => Array a -> Array a\nnubEq = nubByEq eq\n\n-- | Remove the duplicates from an array, where element equality is determined\n-- | by the specified ordering, creating a new array.\n-- |\n-- | ```purescript\n-- | nubBy compare [1, 3, 4, 2, 2, 1] == [1, 3, 4, 2]\n-- | ```\n-- |\nnubBy :: forall a. (a -> a -> Ordering) -> Array a -> Array a\nnubBy comp xs = case head indexedAndSorted of\n  Nothing -> []\n  Just x -> map snd $ sortWith fst $ ST.run do\n    -- TODO: use NonEmptyArrays here to avoid partial functions\n    result <- STA.unsafeThaw $ singleton x\n    ST.foreach indexedAndSorted \\pair@(Tuple _ x') -> do\n      lst <- snd <<< unsafePartial (fromJust <<< last) <$> STA.unsafeFreeze result\n      when (comp lst x' /= EQ) $ void $ STA.push pair result\n    STA.unsafeFreeze result\n  where\n  indexedAndSorted :: Array (Tuple Int a)\n  indexedAndSorted = sortBy (\\x y -> comp (snd x) (snd y))\n    (mapWithIndex Tuple xs)\n\n-- | Remove the duplicates from an array, where element equality is determined\n-- | by the specified equivalence relation, creating a new array.\n-- |\n-- | This less efficient version of `nubBy` only requires an equivalence\n-- | relation.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | nubByEq mod3eq [1, 3, 4, 5, 6] = [1, 3, 5]\n-- | ```\n-- |\nnubByEq :: forall a. (a -> a -> Boolean) -> Array a -> Array a\nnubByEq eq xs = ST.run do\n  arr <- STA.new\n  ST.foreach xs \\x -> do\n    e <- not <<< any (_ `eq` x) <$> (STA.unsafeFreeze arr)\n    when e $ void $ STA.push x arr\n  STA.unsafeFreeze arr\n\n-- | Calculate the union of two arrays. Note that duplicates in the first array\n-- | are preserved while duplicates in the second array are removed.\n-- |\n-- | Running time: `O(n^2)`\n-- |\n-- | ```purescript\n-- | union [1, 2, 1, 1] [3, 3, 3, 4] = [1, 2, 1, 1, 3, 4]\n-- | ```\n-- |\nunion :: forall a. Eq a => Array a -> Array a -> Array a\nunion = unionBy (==)\n\n-- | Calculate the union of two arrays, using the specified function to\n-- | determine equality of elements. Note that duplicates in the first array\n-- | are preserved while duplicates in the second array are removed.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | unionBy mod3eq [1, 5, 1, 2] [3, 4, 3, 3] = [1, 5, 1, 2, 3]\n-- | ```\n-- |\nunionBy :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Array a\nunionBy eq xs ys = xs <> foldl (flip (deleteBy eq)) (nubByEq eq ys) xs\n\n-- | Delete the first element of an array which is equal to the specified value,\n-- | creating a new array.\n-- |\n-- | ```purescript\n-- | delete 7 [1, 7, 3, 7] = [1, 3, 7]\n-- | delete 7 [1, 2, 3] = [1, 2, 3]\n-- | ```\n-- |\n-- | Running time: `O(n)`\ndelete :: forall a. Eq a => a -> Array a -> Array a\ndelete = deleteBy eq\n\n-- | Delete the first element of an array which matches the specified value,\n-- | under the equivalence relation provided in the first argument, creating a\n-- | new array.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | deleteBy mod3eq 6 [1, 3, 4, 3] = [1, 4, 3]\n-- | ```\n-- |\ndeleteBy :: forall a. (a -> a -> Boolean) -> a -> Array a -> Array a\ndeleteBy _ _ [] = []\ndeleteBy eq x ys = maybe ys (\\i -> unsafePartial $ fromJust (deleteAt i ys)) (findIndex (eq x) ys)\n\n-- | Delete the first occurrence of each element in the second array from the\n-- | first array, creating a new array.\n-- |\n-- | ```purescript\n-- | difference [2, 1] [2, 3] = [1]\n-- | ```\n-- |\n-- | Running time: `O(n*m)`, where n is the length of the first array, and m is\n-- | the length of the second.\ndifference :: forall a. Eq a => Array a -> Array a -> Array a\ndifference = foldr delete\n\ninfix 5 difference as \\\\\n\n-- | Calculate the intersection of two arrays, creating a new array. Note that\n-- | duplicates in the first array are preserved while duplicates in the second\n-- | array are removed.\n-- |\n-- | ```purescript\n-- | intersect [1, 1, 2] [2, 2, 1] = [1, 1, 2]\n-- | ```\n-- |\nintersect :: forall a. Eq a => Array a -> Array a -> Array a\nintersect = intersectBy eq\n\n-- | Calculate the intersection of two arrays, using the specified equivalence\n-- | relation to compare elements, creating a new array. Note that duplicates\n-- | in the first array are preserved while duplicates in the second array are\n-- | removed.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | intersectBy mod3eq [1, 2, 3] [4, 6, 7] = [1, 3]\n-- | ```\n-- |\nintersectBy :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Array a\nintersectBy eq xs ys = filter (\\x -> isJust (findIndex (eq x) ys)) xs\n\n-- | Apply a function to pairs of elements at the same index in two arrays,\n-- | collecting the results in a new array.\n-- |\n-- | If one array is longer, elements will be discarded from the longer array.\n-- |\n-- | For example\n-- |\n-- | ```purescript\n-- | zipWith (*) [1, 2, 3] [4, 5, 6, 7] == [4, 10, 18]\n-- | ```\nzipWith\n  :: forall a b c\n   . (a -> b -> c)\n  -> Array a\n  -> Array b\n  -> Array c\nzipWith = runFn3 zipWithImpl\n\nforeign import zipWithImpl\n  :: forall a b c\n   . Fn3\n       (a -> b -> c)\n       (Array a)\n       (Array b)\n       (Array c)\n\n-- | A generalization of `zipWith` which accumulates results in some\n-- | `Applicative` functor.\n-- |\n-- | ```purescript\n-- | sndChars = zipWithA (\\a b -> charAt 2 (a <> b))\n-- | sndChars [\"a\", \"b\"] [\"A\", \"B\"] = Nothing -- since \"aA\" has no 3rd char\n-- | sndChars [\"aa\", \"b\"] [\"AA\", \"BBB\"] = Just ['A', 'B']\n-- | ```\n-- |\nzipWithA\n  :: forall m a b c\n   . Applicative m\n  => (a -> b -> m c)\n  -> Array a\n  -> Array b\n  -> m (Array c)\nzipWithA f xs ys = sequence (zipWith f xs ys)\n\n-- | Takes two arrays and returns an array of corresponding pairs.\n-- | If one input array is short, excess elements of the longer array are\n-- | discarded.\n-- |\n-- | ```purescript\n-- | zip [1, 2, 3] [\"a\", \"b\"] = [Tuple 1 \"a\", Tuple 2 \"b\"]\n-- | ```\n-- |\nzip :: forall a b. Array a -> Array b -> Array (Tuple a b)\nzip = zipWith Tuple\n\n-- | Transforms an array of pairs into an array of first components and an\n-- | array of second components.\n-- |\n-- | ```purescript\n-- | unzip [Tuple 1 \"a\", Tuple 2 \"b\"] = Tuple [1, 2] [\"a\", \"b\"]\n-- | ```\n-- |\nunzip :: forall a b. Array (Tuple a b) -> Tuple (Array a) (Array b)\nunzip xs =\n  ST.run do\n    fsts <- STA.new\n    snds <- STA.new\n    iter <- STAI.iterator (xs !! _)\n    STAI.iterate iter \\(Tuple fst snd) -> do\n      void $ STA.push fst fsts\n      void $ STA.push snd snds\n    fsts' <- STA.unsafeFreeze fsts\n    snds' <- STA.unsafeFreeze snds\n    pure $ Tuple fsts' snds'\n\n-- | Returns true if at least one array element satisfies the given predicate,\n-- | iterating the array only as necessary and stopping as soon as the predicate\n-- | yields true.\n-- |\n-- | ```purescript\n-- | any (_ > 0) [] = False\n-- | any (_ > 0) [-1, 0, 1] = True\n-- | any (_ > 0) [-1, -2, -3] = False\n-- | ```\nany :: forall a. (a -> Boolean) -> Array a -> Boolean\nany = runFn2 anyImpl\n\nforeign import anyImpl :: forall a. Fn2 (a -> Boolean) (Array a) Boolean\n\n-- | Returns true if all the array elements satisfy the given predicate.\n-- | iterating the array only as necessary and stopping as soon as the predicate\n-- | yields false.\n-- |\n-- | ```purescript\n-- | all (_ > 0) [] = True\n-- | all (_ > 0) [1, 2, 3] = True\n-- | all (_ > 0) [-1, -2, -3] = False\n-- | ```\nall :: forall a. (a -> Boolean) -> Array a -> Boolean\nall = runFn2 allImpl\n\nforeign import allImpl :: forall a. Fn2 (a -> Boolean) (Array a) Boolean\n\n-- | Perform a fold using a monadic step function.\n-- |\n-- | ```purescript\n-- | foldM (\\x y -> Just (x + y)) 0 [1, 4] = Just 5\n-- | ```\nfoldM :: forall m a b. Monad m => (b -> a -> m b) -> b -> Array a -> m b\nfoldM f b = runFn3 unconsImpl (\\_ -> pure b) (\\a as -> f b a >>= \\b' -> foldM f b' as)\n\nfoldRecM :: forall m a b. MonadRec m => (b -> a -> m b) -> b -> Array a -> m b\nfoldRecM f b array = tailRecM2 go b 0\n  where\n  go res i\n    | i >= length array = pure (Done res)\n    | otherwise = do\n        res' <- f res (unsafePartial (unsafeIndex array i))\n        pure (Loop { a: res', b: i + 1 })\n\n-- | Find the element of an array at the specified index.\n-- |\n-- | ```purescript\n-- | unsafePartial $ unsafeIndex [\"a\", \"b\", \"c\"] 1 = \"b\"\n-- | ```\n-- |\n-- | Using `unsafeIndex` with an out-of-range index will not immediately raise a runtime error.\n-- | Instead, the result will be undefined. Most attempts to subsequently use the result will\n-- | cause a runtime error, of course, but this is not guaranteed, and is dependent on the backend;\n-- | some programs will continue to run as if nothing is wrong. For example, in the JavaScript backend,\n-- | the expression `unsafePartial (unsafeIndex [true] 1)` has type `Boolean`;\n-- | since this expression evaluates to `undefined`, attempting to use it in an `if` statement will cause\n-- | the else branch to be taken.\nunsafeIndex :: forall a. Partial => Array a -> Int -> a\nunsafeIndex = runFn2 unsafeIndexImpl\n\nforeign import unsafeIndexImpl :: forall a. Fn2 (Array a) Int a\n", "module Data.List.Types\n  ( List(..)\n  , (:)\n  , NonEmptyList(..)\n  , toList\n  , nelCons\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.Eq (class Eq1, eq1)\nimport Data.Foldable (class Foldable, foldl, foldr, intercalate)\nimport Data.FoldableWithIndex (class FoldableWithIndex, foldlWithIndex, foldrWithIndex, foldMapWithIndex)\nimport Data.FunctorWithIndex (class FunctorWithIndex, mapWithIndex)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Newtype (class Newtype)\nimport Data.NonEmpty (NonEmpty, (:|))\nimport Data.NonEmpty as NE\nimport Data.Ord (class Ord1, compare1)\nimport Data.Semigroup.Foldable (class Foldable1)\nimport Data.Semigroup.Traversable (class Traversable1, traverse1)\nimport Data.Traversable (class Traversable, traverse)\nimport Data.TraversableWithIndex (class TraversableWithIndex, traverseWithIndex)\nimport Data.Tuple (Tuple(..), snd)\nimport Data.Unfoldable (class Unfoldable)\nimport Data.Unfoldable1 (class Unfoldable1)\n\ndata List a = Nil | Cons a (List a)\n\ninfixr 6 Cons as :\n\ninstance showList :: Show a => Show (List a) where\n  show Nil = \"Nil\"\n  show xs = \"(\" <> intercalate \" : \" (show <$> xs) <> \" : Nil)\"\n\ninstance eqList :: Eq a => Eq (List a) where\n  eq = eq1\n\ninstance eq1List :: Eq1 List where\n  eq1 xs ys = go xs ys true\n    where\n      go _ _ false = false\n      go Nil Nil acc = acc\n      go (x : xs') (y : ys') acc = go xs' ys' $ acc && (y == x)\n      go _ _ _ = false\n\ninstance ordList :: Ord a => Ord (List a) where\n  compare = compare1\n\ninstance ord1List :: Ord1 List where\n  compare1 xs ys = go xs ys\n    where\n    go Nil Nil = EQ\n    go Nil _ = LT\n    go _ Nil = GT\n    go (x : xs') (y : ys') =\n      case compare x y of\n        EQ -> go xs' ys'\n        other -> other\n\ninstance semigroupList :: Semigroup (List a) where\n  append xs ys = foldr (:) ys xs\n\ninstance monoidList :: Monoid (List a) where\n  mempty = Nil\n\ninstance functorList :: Functor List where\n  map = listMap\n\n-- chunked list Functor inspired by OCaml\n-- https://discuss.ocaml.org/t/a-new-list-map-that-is-both-stack-safe-and-fast/865\n-- chunk sizes determined through experimentation\nlistMap :: forall a b. (a -> b) -> List a -> List b\nlistMap f = chunkedRevMap Nil\n  where\n  chunkedRevMap :: List (List a) -> List a -> List b\n  chunkedRevMap chunksAcc chunk@(_ : _ : _ : xs) =\n    chunkedRevMap (chunk : chunksAcc) xs\n  chunkedRevMap chunksAcc xs =\n    reverseUnrolledMap chunksAcc $ unrolledMap xs\n    where\n    unrolledMap :: List a -> List b\n    unrolledMap (x1 : x2 : Nil) = f x1 : f x2 : Nil\n    unrolledMap (x1 : Nil) = f x1 : Nil\n    unrolledMap _ = Nil\n\n    reverseUnrolledMap :: List (List a) -> List b -> List b\n    reverseUnrolledMap ((x1 : x2 : x3 : _) : cs) acc =\n      reverseUnrolledMap cs (f x1 : f x2 : f x3 : acc)\n    reverseUnrolledMap _ acc = acc\n\ninstance functorWithIndexList :: FunctorWithIndex Int List where\n  mapWithIndex f = foldrWithIndex (\\i x acc -> f i x : acc) Nil\n\ninstance foldableList :: Foldable List where\n  foldr f b = foldl (flip f) b <<< rev\n    where\n    rev = go Nil\n      where\n      go acc Nil = acc\n      go acc (x : xs) = go (x : acc) xs\n  foldl f = go\n    where\n    go b = case _ of\n      Nil -> b\n      a : as -> go (f b a) as\n  foldMap f = foldl (\\acc -> append acc <<< f) mempty\n\ninstance foldableWithIndexList :: FoldableWithIndex Int List where\n  foldrWithIndex f b xs =\n    -- as we climb the reversed list, we decrement the index\n    snd $ foldl\n            (\\(Tuple i b') a -> Tuple (i - 1) (f (i - 1) a b'))\n            (Tuple len b)\n            revList\n    where\n    Tuple len revList = rev (Tuple 0 Nil) xs\n      where\n      -- As we create our reversed list, we count elements.\n      rev = foldl (\\(Tuple i acc) a -> Tuple (i + 1) (a : acc))\n  foldlWithIndex f acc =\n    snd <<< foldl (\\(Tuple i b) a -> Tuple (i + 1) (f i b a)) (Tuple 0 acc)\n  foldMapWithIndex f = foldlWithIndex (\\i acc -> append acc <<< f i) mempty\n\ninstance unfoldable1List :: Unfoldable1 List where\n  unfoldr1 f b = go b Nil\n    where\n    go source memo = case f source of\n      Tuple one (Just rest) -> go rest (one : memo)\n      Tuple one Nothing -> foldl (flip (:)) Nil (one : memo)\n\ninstance unfoldableList :: Unfoldable List where\n  unfoldr f b = go b Nil\n    where\n    go source memo = case f source of\n      Nothing -> (foldl (flip (:)) Nil memo)\n      Just (Tuple one rest) -> go rest (one : memo)\n\ninstance traversableList :: Traversable List where\n  traverse f = map (foldl (flip (:)) Nil) <<< foldl (\\acc -> lift2 (flip (:)) acc <<< f) (pure Nil)\n  sequence = traverse identity\n\ninstance traversableWithIndexList :: TraversableWithIndex Int List where\n  traverseWithIndex f =\n    map rev\n    <<< foldlWithIndex (\\i acc -> lift2 (flip (:)) acc <<< f i) (pure Nil)\n    where\n    rev = foldl (flip Cons) Nil\n\ninstance applyList :: Apply List where\n  apply Nil _ = Nil\n  apply (f : fs) xs = (f <$> xs) <> (fs <*> xs)\n\ninstance applicativeList :: Applicative List where\n  pure a = a : Nil\n\ninstance bindList :: Bind List where\n  bind Nil _ = Nil\n  bind (x : xs) f = f x <> bind xs f\n\ninstance monadList :: Monad List\n\ninstance altList :: Alt List where\n  alt = append\n\ninstance plusList :: Plus List where\n  empty = Nil\n\ninstance alternativeList :: Alternative List\n\ninstance monadPlusList :: MonadPlus List\n\ninstance extendList :: Extend List where\n  extend _ Nil = Nil\n  extend f l@(_ : as) =\n    f l : (foldr go { val: Nil, acc: Nil } as).val\n    where\n    go a' { val, acc } =\n      let acc' = a' : acc\n      in { val: f acc' : val, acc: acc' }\n\nnewtype NonEmptyList a = NonEmptyList (NonEmpty List a)\n\ntoList :: NonEmptyList ~> List\ntoList (NonEmptyList (x :| xs)) = x : xs\n\nnelCons :: forall a. a -> NonEmptyList a -> NonEmptyList a\nnelCons a (NonEmptyList (b :| bs)) = NonEmptyList (a :| b : bs)\n\nderive instance newtypeNonEmptyList :: Newtype (NonEmptyList a) _\n\nderive newtype instance eqNonEmptyList :: Eq a => Eq (NonEmptyList a)\nderive newtype instance ordNonEmptyList :: Ord a => Ord (NonEmptyList a)\n\nderive newtype instance eq1NonEmptyList :: Eq1 NonEmptyList\nderive newtype instance ord1NonEmptyList :: Ord1 NonEmptyList\n\ninstance showNonEmptyList :: Show a => Show (NonEmptyList a) where\n  show (NonEmptyList nel) = \"(NonEmptyList \" <> show nel <> \")\"\n\nderive newtype instance functorNonEmptyList :: Functor NonEmptyList\n\ninstance applyNonEmptyList :: Apply NonEmptyList where\n  apply (NonEmptyList (f :| fs)) (NonEmptyList (a :| as)) =\n    NonEmptyList (f a :| (fs <*> a : Nil) <> ((f : fs) <*> as))\n\ninstance applicativeNonEmptyList :: Applicative NonEmptyList where\n  pure = NonEmptyList <<< NE.singleton\n\ninstance bindNonEmptyList :: Bind NonEmptyList where\n  bind (NonEmptyList (a :| as)) f =\n    case f a of\n      NonEmptyList (b :| bs) ->\n        NonEmptyList (b :| bs <> bind as (toList <<< f))\n\ninstance monadNonEmptyList :: Monad NonEmptyList\n\ninstance altNonEmptyList :: Alt NonEmptyList where\n  alt = append\n\ninstance extendNonEmptyList :: Extend NonEmptyList where\n  extend f w@(NonEmptyList (_ :| as)) =\n    NonEmptyList (f w :| (foldr go { val: Nil, acc: Nil } as).val)\n    where\n    go a { val, acc } = { val: f (NonEmptyList (a :| acc)) : val, acc: a : acc }\n\ninstance comonadNonEmptyList :: Comonad NonEmptyList where\n  extract (NonEmptyList (a :| _)) = a\n\ninstance semigroupNonEmptyList :: Semigroup (NonEmptyList a) where\n  append (NonEmptyList (a :| as)) as' =\n    NonEmptyList (a :| as <> toList as')\n\nderive newtype instance foldableNonEmptyList :: Foldable NonEmptyList\n\nderive newtype instance traversableNonEmptyList :: Traversable NonEmptyList\n\nderive newtype instance foldable1NonEmptyList :: Foldable1 NonEmptyList\n\nderive newtype instance unfoldable1NonEmptyList :: Unfoldable1 NonEmptyList\n\ninstance functorWithIndexNonEmptyList :: FunctorWithIndex Int NonEmptyList where\n  mapWithIndex fn (NonEmptyList ne) = NonEmptyList $ mapWithIndex (fn <<< maybe 0 (add 1)) ne\n\ninstance foldableWithIndexNonEmptyList :: FoldableWithIndex Int NonEmptyList where\n  foldMapWithIndex f (NonEmptyList ne) = foldMapWithIndex (f <<< maybe 0 (add 1)) ne\n  foldlWithIndex f b (NonEmptyList ne) = foldlWithIndex (f <<< maybe 0 (add 1)) b ne\n  foldrWithIndex f b (NonEmptyList ne) = foldrWithIndex (f <<< maybe 0 (add 1)) b ne\n\ninstance traversableWithIndexNonEmptyList :: TraversableWithIndex Int NonEmptyList where\n  traverseWithIndex f (NonEmptyList ne) = NonEmptyList <$> traverseWithIndex (f <<< maybe 0 (add 1)) ne\n\ninstance traversable1NonEmptyList :: Traversable1 NonEmptyList where\n  traverse1 f (NonEmptyList (a :| as)) =\n    foldl (\\acc -> lift2 (flip nelCons) acc <<< f) (pure <$> f a) as\n      <#> case _ of NonEmptyList (x :| xs) \u2192 foldl (flip nelCons) (pure x) xs\n  sequence1 = traverse1 identity\n", "-- | This module defines a type of _strict_ linked lists, and associated helper\n-- | functions and type class instances.\n-- |\n-- | _Note_: Depending on your use-case, you may prefer to use\n-- | `Data.Sequence` instead, which might give better performance for certain\n-- | use cases. This module is an improvement over `Data.Array` when working with\n-- | immutable lists of data in a purely-functional setting, but does not have\n-- | good random-access performance.\n\nmodule Data.List\n  ( module Data.List.Types\n  , toUnfoldable\n  , fromFoldable\n\n  , singleton\n  , (..), range\n  , some\n  , someRec\n  , many\n  , manyRec\n\n  , null\n  , length\n\n  , snoc\n  , insert\n  , insertBy\n\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n\n  , (!!), index\n  , elemIndex\n  , elemLastIndex\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , deleteAt\n  , updateAt\n  , modifyAt\n  , alterAt\n\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , filterM\n  , mapMaybe\n  , catMaybes\n\n  , sort\n  , sortBy\n\n  , Pattern(..)\n  , stripPrefix\n  , slice\n  , take\n  , takeEnd\n  , takeWhile\n  , drop\n  , dropEnd\n  , dropWhile\n  , span\n  , group\n  , groupAll\n  , groupBy\n  , groupAllBy\n  , partition\n\n  , nub\n  , nubBy\n  , nubEq\n  , nubByEq\n  , union\n  , unionBy\n  , delete\n  , deleteBy\n  , (\\\\), difference\n  , intersect\n  , intersectBy\n\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n\n  , transpose\n\n  , foldM\n\n  , module Exports\n  ) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Lazy (class Lazy, defer)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..), tailRecM, tailRecM2)\nimport Data.Bifunctor (bimap)\nimport Data.Foldable (class Foldable, foldr, any, foldl)\nimport Data.Foldable (foldl, foldr, foldMap, fold, intercalate, elem, notElem, find, findMap, any, all) as Exports\nimport Data.List.Internal (emptySet, insertAndLookupBy)\nimport Data.List.Types (List(..), (:))\nimport Data.List.Types (NonEmptyList(..)) as NEL\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype)\nimport Data.NonEmpty ((:|))\nimport Data.Traversable (scanl, scanr) as Exports\nimport Data.Traversable (sequence)\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (class Unfoldable, unfoldr)\n\n-- | Convert a list into any unfoldable structure.\n-- |\n-- | Running time: `O(n)`\ntoUnfoldable :: forall f. Unfoldable f => List ~> f\ntoUnfoldable = unfoldr (\\xs -> (\\rec -> Tuple rec.head rec.tail) <$> uncons xs)\n\n-- | Construct a list from a foldable structure.\n-- |\n-- | Running time: `O(n)`\nfromFoldable :: forall f. Foldable f => f ~> List\nfromFoldable = foldr Cons Nil\n\n--------------------------------------------------------------------------------\n-- List creation ---------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Create a list with a single element.\n-- |\n-- | Running time: `O(1)`\nsingleton :: forall a. a -> List a\nsingleton a = a : Nil\n\n-- | An infix synonym for `range`.\ninfix 8 range as ..\n\n-- | Create a list containing a range of integers, including both endpoints.\nrange :: Int -> Int -> List Int\nrange start end | start == end = singleton start\n                | otherwise = go end start (if start > end then 1 else -1) Nil\n  where\n  go s e step rest | s == e = s : rest\n                   | otherwise = go (s + step) e step (s : rest)\n\n-- | Attempt a computation multiple times, requiring at least one success.\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nsome :: forall f a. Alternative f => Lazy (f (List a)) => f a -> f (List a)\nsome v = Cons <$> v <*> defer (\\_ -> many v)\n\n-- | A stack-safe version of `some`, at the cost of a `MonadRec` constraint.\nsomeRec :: forall f a. MonadRec f => Alternative f => f a -> f (List a)\nsomeRec v = Cons <$> v <*> manyRec v\n\n-- | Attempt a computation multiple times, returning as many successful results\n-- | as possible (possibly zero).\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nmany :: forall f a. Alternative f => Lazy (f (List a)) => f a -> f (List a)\nmany v = some v <|> pure Nil\n\n-- | A stack-safe version of `many`, at the cost of a `MonadRec` constraint.\nmanyRec :: forall f a. MonadRec f => Alternative f => f a -> f (List a)\nmanyRec p = tailRecM go Nil\n  where\n  go :: List a -> f (Step (List a) (List a))\n  go acc = do\n    aa <- (Loop <$> p) <|> pure (Done unit)\n    pure $ bimap (_ : acc) (\\_ -> reverse acc) aa\n\n--------------------------------------------------------------------------------\n-- List size -------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Test whether a list is empty.\n-- |\n-- | Running time: `O(1)`\nnull :: forall a. List a -> Boolean\nnull Nil = true\nnull _ = false\n\n-- | Get the length of a list\n-- |\n-- | Running time: `O(n)`\nlength :: forall a. List a -> Int\nlength = foldl (\\acc _ -> acc + 1) 0\n\n--------------------------------------------------------------------------------\n-- Extending lists -------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Append an element to the end of a list, creating a new list.\n-- |\n-- | Running time: `O(n)`\nsnoc :: forall a. List a -> a -> List a\nsnoc xs x = foldr (:) (x : Nil) xs\n\n-- | Insert an element into a sorted list.\n-- |\n-- | Running time: `O(n)`\ninsert :: forall a. Ord a => a -> List a -> List a\ninsert = insertBy compare\n\n-- | Insert an element into a sorted list, using the specified function to\n-- | determine the ordering of elements.\n-- |\n-- | Running time: `O(n)`\ninsertBy :: forall a. (a -> a -> Ordering) -> a -> List a -> List a\ninsertBy _ x Nil = singleton x\ninsertBy cmp x ys@(y : ys') =\n  case cmp x y of\n    GT -> y : (insertBy cmp x ys')\n    _  -> x : ys\n\n--------------------------------------------------------------------------------\n-- Non-indexed reads -----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Get the first element in a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(1)`.\nhead :: List ~> Maybe\nhead Nil = Nothing\nhead (x : _) = Just x\n\n-- | Get the last element in a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(n)`.\nlast :: List ~> Maybe\nlast (x : Nil) = Just x\nlast (_ : xs)  = last xs\nlast _         = Nothing\n\n-- | Get all but the first element of a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(1)`\ntail :: forall a. List a -> Maybe (List a)\ntail Nil = Nothing\ntail (_ : xs) = Just xs\n\n-- | Get all but the last element of a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(n)`\ninit :: forall a. List a -> Maybe (List a)\ninit lst = _.init <$> unsnoc lst\n\n-- | Break a list into its first element, and the remaining elements,\n-- | or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(1)`\nuncons :: forall a. List a -> Maybe { head :: a, tail :: List a }\nuncons Nil = Nothing\nuncons (x : xs) = Just { head: x, tail: xs }\n\n-- | Break a list into its last element, and the preceding elements,\n-- | or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(n)`\nunsnoc :: forall a. List a -> Maybe { init :: List a, last :: a }\nunsnoc lst = (\\h -> { init: reverse h.revInit, last: h.last }) <$> go lst Nil\n  where\n  go Nil _ = Nothing\n  go (x : Nil) acc = Just { revInit: acc, last: x }\n  go (x : xs) acc = go xs (x : acc)\n\n--------------------------------------------------------------------------------\n-- Indexed operations ----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Get the element at the specified index, or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)` where `n` is the required index.\nindex :: forall a. List a -> Int -> Maybe a\nindex Nil _ = Nothing\nindex (a : _) 0 = Just a\nindex (_ : as) i = index as (i - 1)\n\n-- | An infix synonym for `index`.\ninfixl 8 index as !!\n\n-- | Find the index of the first element equal to the specified element.\nelemIndex :: forall a. Eq a => a -> List a -> Maybe Int\nelemIndex x = findIndex (_ == x)\n\n-- | Find the index of the last element equal to the specified element.\nelemLastIndex :: forall a. Eq a => a -> List a -> Maybe Int\nelemLastIndex x = findLastIndex (_ == x)\n\n-- | Find the first index for which a predicate holds.\nfindIndex :: forall a. (a -> Boolean) -> List a -> Maybe Int\nfindIndex fn = go 0\n  where\n  go :: Int -> List a -> Maybe Int\n  go n (x : xs) | fn x = Just n\n                | otherwise = go (n + 1) xs\n  go _ Nil = Nothing\n\n-- | Find the last index for which a predicate holds.\nfindLastIndex :: forall a. (a -> Boolean) -> List a -> Maybe Int\nfindLastIndex fn xs = ((length xs - 1) - _) <$> findIndex fn (reverse xs)\n\n-- | Insert an element into a list at the specified index, returning a new\n-- | list or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\ninsertAt :: forall a. Int -> a -> List a -> Maybe (List a)\ninsertAt 0 x xs = Just (x : xs)\ninsertAt n x (y : ys) = (y : _) <$> insertAt (n - 1) x ys\ninsertAt _ _ _  = Nothing\n\n-- | Delete an element from a list at the specified index, returning a new\n-- | list or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\ndeleteAt :: forall a. Int -> List a -> Maybe (List a)\ndeleteAt 0 (_ : ys) = Just ys\ndeleteAt n (y : ys) = (y : _) <$> deleteAt (n - 1) ys\ndeleteAt _ _  = Nothing\n\n-- | Update the element at the specified index, returning a new\n-- | list or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\nupdateAt :: forall a. Int -> a -> List a -> Maybe (List a)\nupdateAt 0 x ( _ : xs) = Just (x : xs)\nupdateAt n x (x1 : xs) = (x1 : _) <$> updateAt (n - 1) x xs\nupdateAt _ _ _ = Nothing\n\n-- | Update the element at the specified index by applying a function to\n-- | the current value, returning a new list or `Nothing` if the index is\n-- | out-of-bounds.\n-- |\n-- | Running time: `O(n)`\nmodifyAt :: forall a. Int -> (a -> a) -> List a -> Maybe (List a)\nmodifyAt n f = alterAt n (Just <<< f)\n\n-- | Update or delete the element at the specified index by applying a\n-- | function to the current value, returning a new list or `Nothing` if the\n-- | index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\nalterAt :: forall a. Int -> (a -> Maybe a) -> List a -> Maybe (List a)\nalterAt 0 f (y : ys) = Just $\n  case f y of\n    Nothing -> ys\n    Just y' -> y' : ys\nalterAt n f (y : ys) = (y : _) <$> alterAt (n - 1) f ys\nalterAt _ _ _  = Nothing\n\n--------------------------------------------------------------------------------\n-- Transformations -------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Reverse a list.\n-- |\n-- | Running time: `O(n)`\nreverse :: List ~> List\nreverse = go Nil\n  where\n  go acc Nil = acc\n  go acc (x : xs) = go (x : acc) xs\n\n-- | Flatten a list of lists.\n-- |\n-- | Running time: `O(n)`, where `n` is the total number of elements.\nconcat :: forall a. List (List a) -> List a\nconcat = (_ >>= identity)\n\n-- | Apply a function to each element in a list, and flatten the results\n-- | into a single, new list.\n-- |\n-- | Running time: `O(n)`, where `n` is the total number of elements.\nconcatMap :: forall a b. (a -> List b) -> List a -> List b\nconcatMap = flip bind\n\n-- | Filter a list, keeping the elements which satisfy a predicate function.\n-- |\n-- | Running time: `O(n)`\nfilter :: forall a. (a -> Boolean) -> List a -> List a\nfilter p = go Nil\n  where\n  go acc Nil = reverse acc\n  go acc (x : xs)\n    | p x = go (x : acc) xs\n    | otherwise = go acc xs\n\n-- | Filter where the predicate returns a monadic `Boolean`.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | powerSet :: forall a. [a] -> [[a]]\n-- | powerSet = filterM (const [true, false])\n-- | ```\nfilterM :: forall a m. Monad m => (a -> m Boolean) -> List a -> m (List a)\nfilterM _ Nil = pure Nil\nfilterM p (x : xs) = do\n  b <- p x\n  xs' <- filterM p xs\n  pure if b then x : xs' else xs'\n\n-- | Apply a function to each element in a list, keeping only the results which\n-- | contain a value.\n-- |\n-- | Running time: `O(n)`\nmapMaybe :: forall a b. (a -> Maybe b) -> List a -> List b\nmapMaybe f = go Nil\n  where\n  go acc Nil = reverse acc\n  go acc (x : xs) =\n    case f x of\n      Nothing -> go acc xs\n      Just y -> go (y : acc) xs\n\n-- | Filter a list of optional values, keeping only the elements which contain\n-- | a value.\ncatMaybes :: forall a. List (Maybe a) -> List a\ncatMaybes = mapMaybe identity\n\n--------------------------------------------------------------------------------\n-- Sorting ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Sort the elements of an list in increasing order.\nsort :: forall a. Ord a => List a -> List a\nsort xs = sortBy compare xs\n\n-- | Sort the elements of a list in increasing order, where elements are\n-- | compared using the specified ordering.\nsortBy :: forall a. (a -> a -> Ordering) -> List a -> List a\nsortBy cmp = mergeAll <<< sequences\n  -- implementation lifted from http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-OldList.html#sort\n  where\n  sequences :: List a -> List (List a)\n  sequences (a : b : xs)\n    | a `cmp` b == GT = descending b (singleton a) xs\n    | otherwise = ascending b (a : _) xs\n  sequences xs = singleton xs\n\n  descending :: a -> List a -> List a -> List (List a)\n  descending a as (b : bs)\n    | a `cmp` b == GT = descending b (a : as) bs\n  descending a as bs = (a : as) : sequences bs\n\n  ascending :: a -> (List a -> List a) -> List a -> List (List a)\n  ascending a as (b : bs)\n    | a `cmp` b /= GT = ascending b (\\ys -> as (a : ys)) bs\n  ascending a as bs = ((as $ singleton a) : sequences bs)\n\n  mergeAll :: List (List a) -> List a\n  mergeAll (x : Nil) = x\n  mergeAll xs = mergeAll (mergePairs xs)\n\n  mergePairs :: List (List a) -> List (List a)\n  mergePairs (a : b : xs) = merge a b : mergePairs xs\n  mergePairs xs = xs\n\n  merge :: List a -> List a -> List a\n  merge as@(a : as') bs@(b : bs')\n    | a `cmp` b == GT = b : merge as bs'\n    | otherwise       = a : merge as' bs\n  merge Nil bs = bs\n  merge as Nil = as\n\n--------------------------------------------------------------------------------\n-- Sublists --------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | A newtype used in cases where there is a list to be matched.\nnewtype Pattern a = Pattern (List a)\n\nderive instance eqPattern :: Eq a => Eq (Pattern a)\nderive instance ordPattern :: Ord a => Ord (Pattern a)\nderive instance newtypePattern :: Newtype (Pattern a) _\n\ninstance showPattern :: Show a => Show (Pattern a) where\n  show (Pattern s) = \"(Pattern \" <> show s <> \")\"\n\n\n-- | If the list starts with the given prefix, return the portion of the\n-- | list left after removing it, as a Just value. Otherwise, return Nothing.\n-- | * `stripPrefix (Pattern (1:Nil)) (1:2:Nil) == Just (2:Nil)`\n-- | * `stripPrefix (Pattern Nil) (1:Nil) == Just (1:Nil)`\n-- | * `stripPrefix (Pattern (2:Nil)) (1:Nil) == Nothing`\n-- |\n-- | Running time: `O(n)` where `n` is the number of elements to strip.\nstripPrefix :: forall a. Eq a => Pattern a -> List a -> Maybe (List a)\nstripPrefix (Pattern p') s = tailRecM2 go p' s\n  where\n  go prefix input = case prefix, input of\n    Cons p ps, Cons i is | p == i -> Just $ Loop { a: ps, b: is }\n    Nil, is -> Just $ Done is\n    _, _ -> Nothing\n\n-- | Extract a sublist by a start and end index.\nslice :: Int -> Int -> List ~> List\nslice start end xs = take (end - start) (drop start xs)\n\n-- | Take the specified number of elements from the front of a list.\n-- |\n-- | Running time: `O(n)` where `n` is the number of elements to take.\ntake :: forall a. Int -> List a -> List a\ntake = go Nil\n  where\n  go acc n _ | n < 1 = reverse acc\n  go acc _ Nil = reverse acc\n  go acc n (x : xs) = go (x : acc) (n - 1) xs\n\n-- | Take the specified number of elements from the end of a list.\n-- |\n-- | Running time: `O(2n - m)` where `n` is the number of elements in list\n-- | and `m` is number of elements to take.\ntakeEnd :: forall a. Int -> List a -> List a\ntakeEnd n xs = drop (length xs - n) xs\n\n-- | Take those elements from the front of a list which match a predicate.\n-- |\n-- | Running time (worst case): `O(n)`\ntakeWhile :: forall a. (a -> Boolean) -> List a -> List a\ntakeWhile p = go Nil\n  where\n  go acc (x : xs) | p x = go (x : acc) xs\n  go acc _ = reverse acc\n\n-- | Drop the specified number of elements from the front of a list.\n-- |\n-- | Running time: `O(n)` where `n` is the number of elements to drop.\ndrop :: forall a. Int -> List a -> List a\ndrop n xs | n < 1 = xs\ndrop _ Nil = Nil\ndrop n (_ : xs) = drop (n - 1) xs\n\n-- | Drop the specified number of elements from the end of a list.\n-- |\n-- | Running time: `O(2n - m)` where `n` is the number of elements in list\n-- | and `m` is number of elements to drop.\ndropEnd :: forall a. Int -> List a -> List a\ndropEnd n xs = take (length xs - n) xs\n\n-- | Drop those elements from the front of a list which match a predicate.\n-- |\n-- | Running time (worst case): `O(n)`\ndropWhile :: forall a. (a -> Boolean) -> List a -> List a\ndropWhile p = go\n  where\n  go (x : xs) | p x = go xs\n  go xs = xs\n\n-- | Split a list into two parts:\n-- |\n-- | 1. the longest initial segment for which all elements satisfy the specified predicate\n-- | 2. the remaining elements\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | span (\\n -> n % 2 == 1) (1 : 3 : 2 : 4 : 5 : Nil) == { init: (1 : 3 : Nil), rest: (2 : 4 : 5 : Nil) }\n-- | ```\n-- |\n-- | Running time: `O(n)`\nspan :: forall a. (a -> Boolean) -> List a -> { init :: List a, rest :: List a }\nspan p (x : xs') | p x = case span p xs' of\n  { init: ys, rest: zs } -> { init: x : ys, rest: zs }\nspan _ xs = { init: Nil, rest: xs }\n\n-- | Group equal, consecutive elements of a list into lists.\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | group (1 : 1 : 2 : 2 : 1 : Nil) ==\n-- |   (NonEmptyList (NonEmpty 1 (1 : Nil))) : (NonEmptyList (NonEmpty 2 (2 : Nil))) : (NonEmptyList (NonEmpty 1 Nil)) : Nil\n-- | ```\n-- |\n-- | Running time: `O(n)`\ngroup :: forall a. Eq a => List a -> List (NEL.NonEmptyList a)\ngroup = groupBy (==)\n\n-- | Group equal elements of a list into lists.\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | groupAll (1 : 1 : 2 : 2 : 1 : Nil) ==\n-- |   (NonEmptyList (NonEmpty 1 (1 : 1 : Nil))) : (NonEmptyList (NonEmpty 2 (2 : Nil))) : Nil\n-- | ```\ngroupAll :: forall a. Ord a => List a -> List (NEL.NonEmptyList a)\ngroupAll = group <<< sort\n\n-- | Group equal, consecutive elements of a list into lists, using the specified\n-- | equivalence relation to determine equality.\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | groupBy (\\a b -> odd a && odd b) (1 : 3 : 2 : 4 : 3 : 3 : Nil) ==\n-- |   (NonEmptyList (NonEmpty 1 (3 : Nil))) : (NonEmptyList (NonEmpty 2 Nil)) : (NonEmptyList (NonEmpty 4 Nil)) : (NonEmptyList (NonEmpty 3 (3 : Nil))) : Nil\n-- | ```\n-- |\n-- | Running time: `O(n)`\ngroupBy :: forall a. (a -> a -> Boolean) -> List a -> List (NEL.NonEmptyList a)\ngroupBy _ Nil = Nil\ngroupBy eq (x : xs) = case span (eq x) xs of\n  { init: ys, rest: zs } -> NEL.NonEmptyList (x :| ys) : groupBy eq zs\n\n-- | Sort, then group equal elements of a list into lists, using the provided comparison function.\n-- |\n-- | ```purescript\n-- | groupAllBy (compare `on` (_ `div` 10)) (32 : 31 : 21 : 22 : 11 : 33 : Nil) ==\n-- |   NonEmptyList (11 :| Nil) : NonEmptyList (21 :| 22 : Nil) : NonEmptyList (32 :| 31 : 33) : Nil\n-- | ```\n-- |\n-- | Running time: `O(n log n)`\ngroupAllBy :: forall a. (a -> a -> Ordering) -> List a -> List (NEL.NonEmptyList a)\ngroupAllBy p = groupBy (\\x y -> p x y == EQ) <<< sortBy p\n\n-- | Returns a lists of elements which do and do not satisfy a predicate.\n-- |\n-- | Running time: `O(n)`\npartition :: forall a. (a -> Boolean) -> List a -> { yes :: List a, no :: List a }\npartition p xs = foldr select { no: Nil, yes: Nil } xs\n  where\n    select x { no, yes } = if p x\n                           then { no, yes: x : yes }\n                           else { no: x : no, yes }\n\n-- | Returns all final segments of the argument, longest first. For example,\n-- |\n-- | ```purescript\n-- | tails (1 : 2 : 3 : Nil) == ((1 : 2 : 3 : Nil) : (2 : 3 : Nil) : (3 : Nil) : (Nil) : Nil)\n-- | ```\n-- | Running time: `O(n)`\ntails :: forall a. List a -> List (List a)\ntails Nil = singleton Nil\ntails list@(Cons _ tl)= list : tails tl\n\n--------------------------------------------------------------------------------\n-- Set-like operations ---------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Remove duplicate elements from a list.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- |\n-- | ```purescript\n-- | nub 1:2:1:3:3:Nil == 1:2:3:Nil\n-- | ```\n-- |\n-- | Running time: `O(n log n)`\nnub :: forall a. Ord a => List a -> List a\nnub = nubBy compare\n\n-- | Remove duplicate elements from a list based on the provided comparison function.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- |\n-- | ```purescript\n-- | nubBy (compare `on` Array.length) ([1]:[2]:[3,4]:Nil) == [1]:[3,4]:Nil\n-- | ```\n-- |\n-- | Running time: `O(n log n)`\nnubBy :: forall a. (a -> a -> Ordering) -> List a -> List a\nnubBy p = reverse <<< go emptySet Nil\n  where\n    go _ acc Nil = acc\n    go s acc (a : as) =\n      let { found, result: s' } = insertAndLookupBy p a s\n      in if found\n        then go s' acc as\n        else go s' (a : acc) as\n\n-- | Remove duplicate elements from a list.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- | This less efficient version of `nub` only requires an `Eq` instance.\n-- |\n-- | ```purescript\n-- | nubEq 1:2:1:3:3:Nil == 1:2:3:Nil\n-- | ```\n-- |\n-- | Running time: `O(n^2)`\nnubEq :: forall a. Eq a => List a -> List a\nnubEq = nubByEq eq\n\n-- | Remove duplicate elements from a list, using the provided equivalence function.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- | This less efficient version of `nubBy` only requires an equivalence\n-- | function, rather than an ordering function.\n-- |\n-- | ```purescript\n-- | mod3eq = eq `on` \\n -> mod n 3\n-- | nubByEq mod3eq 1:3:4:5:6:Nil == 1:3:5:Nil\n-- | ```\n-- |\n-- | Running time: `O(n^2)`\nnubByEq :: forall a. (a -> a -> Boolean) -> List a -> List a\nnubByEq _     Nil = Nil\nnubByEq eq' (x : xs) = x : nubByEq eq' (filter (\\y -> not (eq' x y)) xs)\n\n-- | Calculate the union of two lists.\n-- |\n-- | Running time: `O(n^2)`\nunion :: forall a. Eq a => List a -> List a -> List a\nunion = unionBy (==)\n\n-- | Calculate the union of two lists, using the specified\n-- | function to determine equality of elements.\n-- |\n-- | Running time: `O(n^2)`\nunionBy :: forall a. (a -> a -> Boolean) -> List a -> List a -> List a\nunionBy eq xs ys = xs <> foldl (flip (deleteBy eq)) (nubByEq eq ys) xs\n\n-- | Delete the first occurrence of an element from a list.\n-- |\n-- | Running time: `O(n)`\ndelete :: forall a. Eq a => a -> List a -> List a\ndelete = deleteBy (==)\n\n-- | Delete the first occurrence of an element from a list, using the specified\n-- | function to determine equality of elements.\n-- |\n-- | Running time: `O(n)`\ndeleteBy :: forall a. (a -> a -> Boolean) -> a -> List a -> List a\ndeleteBy _ _ Nil = Nil\ndeleteBy eq' x (y : ys) | eq' x y = ys\ndeleteBy eq' x (y : ys) = y : deleteBy eq' x ys\n\ninfix 5 difference as \\\\\n\n-- | Delete the first occurrence of each element in the second list from the first list.\n-- |\n-- | Running time: `O(n^2)`\ndifference :: forall a. Eq a => List a -> List a -> List a\ndifference = foldl (flip delete)\n\n-- | Calculate the intersection of two lists.\n-- |\n-- | Running time: `O(n^2)`\nintersect :: forall a. Eq a => List a -> List a -> List a\nintersect = intersectBy (==)\n\n-- | Calculate the intersection of two lists, using the specified\n-- | function to determine equality of elements.\n-- |\n-- | Running time: `O(n^2)`\nintersectBy :: forall a. (a -> a -> Boolean) -> List a -> List a -> List a\nintersectBy _  Nil _   = Nil\nintersectBy _  _   Nil = Nil\nintersectBy eq xs  ys  = filter (\\x -> any (eq x) ys) xs\n\n--------------------------------------------------------------------------------\n-- Zipping ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Apply a function to pairs of elements at the same positions in two lists,\n-- | collecting the results in a new list.\n-- |\n-- | If one list is longer, elements will be discarded from the longer list.\n-- |\n-- | For example\n-- |\n-- | ```purescript\n-- | zipWith (*) (1 : 2 : 3 : Nil) (4 : 5 : 6 : 7 Nil) == 4 : 10 : 18 : Nil\n-- | ```\n-- |\n-- | Running time: `O(min(m, n))`\nzipWith :: forall a b c. (a -> b -> c) -> List a -> List b -> List c\nzipWith f xs ys = reverse $ go xs ys Nil\n  where\n  go Nil _ acc = acc\n  go _ Nil acc = acc\n  go (a : as) (b : bs) acc = go as bs $ f a b : acc\n\n-- | A generalization of `zipWith` which accumulates results in some `Applicative`\n-- | functor.\nzipWithA :: forall m a b c. Applicative m => (a -> b -> m c) -> List a -> List b -> m (List c)\nzipWithA f xs ys = sequence (zipWith f xs ys)\n\n-- | Collect pairs of elements at the same positions in two lists.\n-- |\n-- | Running time: `O(min(m, n))`\nzip :: forall a b. List a -> List b -> List (Tuple a b)\nzip = zipWith Tuple\n\n-- | Transforms a list of pairs into a list of first components and a list of\n-- | second components.\nunzip :: forall a b. List (Tuple a b) -> Tuple (List a) (List b)\nunzip = foldr (\\(Tuple a b) (Tuple as bs) -> Tuple (a : as) (b : bs)) (Tuple Nil Nil)\n\n--------------------------------------------------------------------------------\n-- Transpose -------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | The 'transpose' function transposes the rows and columns of its argument.\n-- | For example,\n-- |\n-- |     transpose ((1:2:3:Nil) : (4:5:6:Nil) : Nil) ==\n-- |       ((1:4:Nil) : (2:5:Nil) : (3:6:Nil) : Nil)\n-- |\n-- | If some of the rows are shorter than the following rows, their elements are skipped:\n-- |\n-- |     transpose ((10:11:Nil) : (20:Nil) : Nil : (30:31:32:Nil) : Nil) ==\n-- |       ((10:20:30:Nil) : (11:31:Nil) : (32:Nil) : Nil)\ntranspose :: forall a. List (List a) -> List (List a)\ntranspose Nil = Nil\ntranspose (Nil : xss) = transpose xss\ntranspose ((x : xs) : xss) =\n  (x : mapMaybe head xss) : transpose (xs : mapMaybe tail xss)\n\n--------------------------------------------------------------------------------\n-- Folding ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Perform a fold using a monadic step function.\nfoldM :: forall m a b. Monad m => (b -> a -> m b) -> b -> List a -> m b\nfoldM _ b Nil = pure b\nfoldM f b (a : as) = f b a >>= \\b' -> foldM f b' as\n", "module Data.Compactable\n  ( class Compactable\n  , compact\n  , separate\n  , compactDefault\n  , separateDefault\n  , applyMaybe\n  , applyEither\n  , bindMaybe\n  , bindEither\n  ) where\n\nimport Control.Alternative (empty, (<|>))\nimport Control.Applicative (class Apply, apply, pure)\nimport Control.Apply ((<*>))\nimport Control.Bind (class Bind, bind, join)\nimport Control.Monad.ST as ST\nimport Data.Array ((!!))\nimport Data.Array.ST as STA\nimport Data.Array.ST.Iterator as STAI\nimport Data.Either (Either(Right, Left), hush, note)\nimport Data.Foldable (foldl, foldr)\nimport Data.Function (($))\nimport Data.Functor (class Functor, map, (<$>))\nimport Data.List as List\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Data.Monoid (class Monoid, mempty)\nimport Data.Tuple (Tuple(..))\nimport Prelude (class Ord, const, discard, unit, void, (<<<))\n\n-- | `Compactable` represents data structures which can be _compacted_/_filtered_.\n-- | This is a generalization of catMaybes as a new function `compact`. `compact`\n-- | has relations with `Functor`, `Applicative`, `Monad`, `Plus`, and `Traversable`\n-- | in that we can use these classes to provide the ability to operate on a data type\n-- | by eliminating intermediate Nothings. This is useful for representing the\n-- | filtering out of values, or failure.\n-- |\n-- | To be compactable alone, no laws must be satisfied other than the type signature.\n-- |\n-- | If the data type is also a Functor the following should hold:\n-- |\n-- | - Functor Identity: `compact <<< map Just \u2261 id`\n-- |\n-- | According to Kmett, (Compactable f, Functor f) is a functor from the\n-- | kleisli category of Maybe to the category of Hask.\n-- | `Kleisli Maybe -> Hask`.\n-- |\n-- | If the data type is also `Applicative` the following should hold:\n-- |\n-- | - `compact <<< (pure Just <*> _) \u2261 id`\n-- | - `applyMaybe (pure Just) \u2261 id`\n-- | - `compact \u2261 applyMaybe (pure id)`\n-- |\n-- | If the data type is also a `Monad` the following should hold:\n-- |\n-- | - `flip bindMaybe (pure <<< Just) \u2261 id`\n-- | - `compact <<< (pure <<< (Just (=<<))) \u2261 id`\n-- | - `compact \u2261 flip bindMaybe pure`\n-- |\n-- | If the data type is also `Plus` the following should hold:\n-- |\n-- | - `compact empty \u2261 empty`\n-- | - `compact (const Nothing <$> xs) \u2261 empty`\n\nclass Compactable f where\n  compact :: forall a.\n    f (Maybe a) -> f a\n\n  separate :: forall l r.\n    f (Either l r) -> { left :: f l, right :: f r }\n\ncompactDefault :: forall f a. Functor f => Compactable f =>\n  f (Maybe a) -> f a\ncompactDefault = _.right <<< separate <<< map (note unit)\n\nseparateDefault :: forall f l r. Functor f => Compactable f =>\n  f (Either l r) -> { left :: f l, right :: f r}\nseparateDefault xs = { left: compact $ (hush <<< swapEither) <$> xs\n                     , right: compact $ hush <$> xs\n                     }\n  where\n    swapEither e = case e of\n      Left x  -> Right x\n      Right y -> Left y\n\ninstance compactableMaybe :: Compactable Maybe where\n  compact = join\n\n  separate Nothing = { left: Nothing, right: Nothing }\n  separate (Just e) = case e of\n    Left l  -> { left: Just l, right: Nothing }\n    Right r -> { left: Nothing, right: Just r }\n\ninstance compactableEither :: Monoid m => Compactable (Either m) where\n  compact (Left m) = Left m\n  compact (Right m) = case m of\n    Just v  -> Right v\n    Nothing -> Left mempty\n\n  separate (Left x) = { left: Left x, right: Left x }\n  separate (Right e) = case e of\n    Left l  -> { left: Right l, right: Left mempty }\n    Right r -> { left: Left mempty, right: Right r }\n\ninstance compactableArray :: Compactable Array where\n  compact xs = ST.run do\n    result <- STA.new\n    iter   <- STAI.iterator (xs !! _)\n\n    STAI.iterate iter $ void <<< case _ of\n      Nothing -> pure 0\n      Just j  -> STA.push j result\n\n    STA.unsafeFreeze result\n\n  separate xs = ST.run do\n    ls <- STA.new\n    rs <- STA.new\n    iter <- STAI.iterator (xs !! _)\n\n    STAI.iterate iter $ void <<< case _ of\n      Left l  -> STA.push l ls\n      Right r -> STA.push r rs\n\n    {left: _, right: _} <$> STA.unsafeFreeze ls <*> STA.unsafeFreeze rs\n\ninstance compactableList :: Compactable List.List where\n  compact = List.catMaybes\n  separate = foldl go { left: empty, right: empty } where\n    go acc = case _ of\n      Left l  -> acc { left = acc.left <|> pure l }\n      Right r -> acc { right = acc.right <|> pure r }\n\ninstance compactableMap :: Ord k => Compactable (Map.Map k) where\n  compact = foldr select Map.empty <<< mapToList\n    where\n      select (Tuple k x) m = Map.alter (const x) k m\n\n  separate = foldr select { left: Map.empty, right: Map.empty } <<< mapToList\n    where\n      select (Tuple k v) { left, right } = case v of\n        Left l -> { left: Map.insert k l left, right }\n        Right r -> { left: left, right: Map.insert k r right }\n\nmapToList :: forall k v. Ord k =>\n  Map.Map k v -> List.List (Tuple k v)\nmapToList = Map.toUnfoldable\n\napplyMaybe :: forall f a b. Apply f => Compactable f =>\n  f (a -> Maybe b) -> f a -> f b\napplyMaybe p = compact <<< apply p\n\napplyEither :: forall f a l r. Apply f => Compactable f =>\n  f (a -> Either l r) -> f a -> { left :: f l, right :: f r }\napplyEither p = separate <<< apply p\n\nbindMaybe :: forall m a b. Bind m => Compactable m =>\n  m a -> (a -> m (Maybe b)) -> m b\nbindMaybe x = compact <<< bind x\n\nbindEither :: forall m a l r. Bind m => Compactable m =>\n  m a -> (a -> m (Either l r)) -> { left :: m l, right :: m r }\nbindEither x = separate <<< bind x\n", "export function showErrorImpl(err) {\n  return err.stack || err.toString();\n}\n\nexport function error(msg) {\n  return new Error(msg);\n}\n\nexport function errorWithCause(msg) {\n  return function(cause) {\n    return new Error(msg, { cause });\n  };\n}\n\nexport function errorWithName(msg) {\n  return function(name) {\n    const e = new Error(msg);\n    e.name = name;\n    return e;\n  };\n}\n\nexport function message(e) {\n  return e.message;\n}\n\nexport function name(e) {\n  return e.name || \"Error\";\n}\n\nexport function stackImpl(just) {\n  return function (nothing) {\n    return function (e) {\n      return e.stack ? just(e.stack) : nothing;\n    };\n  };\n}\n\nexport function throwException(e) {\n  return function () {\n    throw e;\n  };\n}\n\nexport function catchException(c) {\n  return function (t) {\n    return function () {\n      try {\n        return t();\n      } catch (e) {\n        if (e instanceof Error || Object.prototype.toString.call(e) === \"[object Error]\") {\n          return c(e)();\n        } else {\n          return c(new Error(e.toString()))();\n        }\n      }\n    };\n  };\n}\n", "export const fromCharArray = function (a) {\n  return a.join(\"\");\n};\n\nexport const toCharArray = function (s) {\n  return s.split(\"\");\n};\n\nexport const singleton = function (c) {\n  return c;\n};\n\nexport const _charAt = function (just) {\n  return function (nothing) {\n    return function (i) {\n      return function (s) {\n        return i >= 0 && i < s.length ? just(s.charAt(i)) : nothing;\n      };\n    };\n  };\n};\n\nexport const _toChar = function (just) {\n  return function (nothing) {\n    return function (s) {\n      return s.length === 1 ? just(s) : nothing;\n    };\n  };\n};\n\nexport const length = function (s) {\n  return s.length;\n};\n\nexport const countPrefix = function (p) {\n  return function (s) {\n    var i = 0;\n    while (i < s.length && p(s.charAt(i))) i++;\n    return i;\n  };\n};\n\nexport const _indexOf = function (just) {\n  return function (nothing) {\n    return function (x) {\n      return function (s) {\n        var i = s.indexOf(x);\n        return i === -1 ? nothing : just(i);\n      };\n    };\n  };\n};\n\nexport const _indexOfStartingAt = function (just) {\n  return function (nothing) {\n    return function (x) {\n      return function (startAt) {\n        return function (s) {\n          if (startAt < 0 || startAt > s.length) return nothing;\n          var i = s.indexOf(x, startAt);\n          return i === -1 ? nothing : just(i);\n        };\n      };\n    };\n  };\n};\n\nexport const _lastIndexOf = function (just) {\n  return function (nothing) {\n    return function (x) {\n      return function (s) {\n        var i = s.lastIndexOf(x);\n        return i === -1 ? nothing : just(i);\n      };\n    };\n  };\n};\n\nexport const _lastIndexOfStartingAt = function (just) {\n  return function (nothing) {\n    return function (x) {\n      return function (startAt) {\n        return function (s) {\n          var i = s.lastIndexOf(x, startAt);\n          return i === -1 ? nothing : just(i);\n        };\n      };\n    };\n  };\n};\n\nexport const take = function (n) {\n  return function (s) {\n    return s.substr(0, n);\n  };\n};\n\nexport const drop = function (n) {\n  return function (s) {\n    return s.substring(n);\n  };\n};\n\nexport const slice = function (b) {\n  return function (e) {\n    return function (s) {\n      return s.slice(b,e);\n    };\n  };\n};\n\nexport const splitAt = function (i) {\n  return function (s) {\n    return { before: s.substring(0, i), after: s.substring(i) };\n  };\n};\n", "module Data.String.CodeUnits\n  ( stripPrefix\n  , stripSuffix\n  , contains\n  , singleton\n  , fromCharArray\n  , toCharArray\n  , charAt\n  , toChar\n  , uncons\n  , length\n  , countPrefix\n  , indexOf\n  , indexOf'\n  , lastIndexOf\n  , lastIndexOf'\n  , take\n  , takeRight\n  , takeWhile\n  , drop\n  , dropRight\n  , dropWhile\n  , slice\n  , splitAt\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe(..), isJust)\nimport Data.String.Pattern (Pattern(..))\nimport Data.String.Unsafe as U\n\n-------------------------------------------------------------------------------\n-- `stripPrefix`, `stripSuffix`, and `contains` are CodeUnit/CodePoint agnostic\n-- as they are based on patterns rather than lengths/indices, but they need to\n-- be defined in here to avoid a circular module dependency\n-------------------------------------------------------------------------------\n\n-- | If the string starts with the given prefix, return the portion of the\n-- | string left after removing it, as a `Just` value. Otherwise, return `Nothing`.\n-- |\n-- | ```purescript\n-- | stripPrefix (Pattern \"http:\") \"http://purescript.org\" == Just \"//purescript.org\"\n-- | stripPrefix (Pattern \"http:\") \"https://purescript.org\" == Nothing\n-- | ```\nstripPrefix :: Pattern -> String -> Maybe String\nstripPrefix (Pattern prefix) str =\n  let { before, after } = splitAt (length prefix) str in\n  if before == prefix then Just after else Nothing\n\n-- | If the string ends with the given suffix, return the portion of the\n-- | string left after removing it, as a `Just` value. Otherwise, return\n-- | `Nothing`.\n-- |\n-- | ```purescript\n-- | stripSuffix (Pattern \".exe\") \"psc.exe\" == Just \"psc\"\n-- | stripSuffix (Pattern \".exe\") \"psc\" == Nothing\n-- | ```\nstripSuffix :: Pattern -> String -> Maybe String\nstripSuffix (Pattern suffix) str =\n  let { before, after } = splitAt (length str - length suffix) str in\n  if after == suffix then Just before else Nothing\n\n-- | Checks whether the pattern appears in the given string.\n-- |\n-- | ```purescript\n-- | contains (Pattern \"needle\") \"haystack with needle\" == true\n-- | contains (Pattern \"needle\") \"haystack\" == false\n-- | ```\ncontains :: Pattern -> String -> Boolean\ncontains pat = isJust <<< indexOf pat\n\n-------------------------------------------------------------------------------\n-- all functions past this point are CodeUnit specific\n-------------------------------------------------------------------------------\n\n-- | Returns a string of length `1` containing the given character.\n-- |\n-- | ```purescript\n-- | singleton 'l' == \"l\"\n-- | ```\n-- |\nforeign import singleton :: Char -> String\n\n-- | Converts an array of characters into a string.\n-- |\n-- | ```purescript\n-- | fromCharArray ['H', 'e', 'l', 'l', 'o'] == \"Hello\"\n-- | ```\nforeign import fromCharArray :: Array Char -> String\n\n-- | Converts the string into an array of characters.\n-- |\n-- | ```purescript\n-- | toCharArray \"Hello\u263A\\n\" == ['H','e','l','l','o','\u263A','\\n']\n-- | ```\nforeign import toCharArray :: String -> Array Char\n\n-- | Returns the character at the given index, if the index is within bounds.\n-- |\n-- | ```purescript\n-- | charAt 2 \"Hello\" == Just 'l'\n-- | charAt 10 \"Hello\" == Nothing\n-- | ```\n-- |\ncharAt :: Int -> String -> Maybe Char\ncharAt = _charAt Just Nothing\n\nforeign import _charAt\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Int\n  -> String\n  -> Maybe Char\n\n-- | Converts the string to a character, if the length of the string is\n-- | exactly `1`.\n-- |\n-- | ```purescript\n-- | toChar \"l\" == Just 'l'\n-- | toChar \"Hi\" == Nothing -- since length is not 1\n-- | ```\ntoChar :: String -> Maybe Char\ntoChar = _toChar Just Nothing\n\nforeign import _toChar\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> String\n  -> Maybe Char\n\n-- | Returns the first character and the rest of the string,\n-- | if the string is not empty.\n-- |\n-- | ```purescript\n-- | uncons \"\" == Nothing\n-- | uncons \"Hello World\" == Just { head: 'H', tail: \"ello World\" }\n-- | ```\n-- |\nuncons :: String -> Maybe { head :: Char, tail :: String }\nuncons \"\" = Nothing\nuncons s  = Just { head: U.charAt zero s, tail: drop one s }\n\n-- | Returns the number of characters the string is composed of.\n-- |\n-- | ```purescript\n-- | length \"Hello World\" == 11\n-- | ```\n-- |\nforeign import length :: String -> Int\n\n-- | Returns the number of contiguous characters at the beginning\n-- | of the string for which the predicate holds.\n-- |\n-- | ```purescript\n-- | countPrefix (_ /= ' ') \"Hello World\" == 5 -- since length \"Hello\" == 5\n-- | ```\n-- |\nforeign import countPrefix :: (Char -> Boolean) -> String -> Int\n\n-- | Returns the index of the first occurrence of the pattern in the\n-- | given string. Returns `Nothing` if there is no match.\n-- |\n-- | ```purescript\n-- | indexOf (Pattern \"c\") \"abcdc\" == Just 2\n-- | indexOf (Pattern \"c\") \"aaa\" == Nothing\n-- | ```\n-- |\nindexOf :: Pattern -> String -> Maybe Int\nindexOf = _indexOf Just Nothing\n\nforeign import _indexOf\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Pattern\n  -> String\n  -> Maybe Int\n\n-- | Returns the index of the first occurrence of the pattern in the\n-- | given string, starting at the specified index. Returns `Nothing` if there is\n-- | no match.\n-- |\n-- | ```purescript\n-- | indexOf' (Pattern \"a\") 2 \"ababa\" == Just 2\n-- | indexOf' (Pattern \"a\") 3 \"ababa\" == Just 4\n-- | ```\n-- |\nindexOf' :: Pattern -> Int -> String -> Maybe Int\nindexOf' = _indexOfStartingAt Just Nothing\n\nforeign import _indexOfStartingAt\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Pattern\n  -> Int\n  -> String\n  -> Maybe Int\n\n-- | Returns the index of the last occurrence of the pattern in the\n-- | given string. Returns `Nothing` if there is no match.\n-- |\n-- | ```purescript\n-- | lastIndexOf (Pattern \"c\") \"abcdc\" == Just 4\n-- | lastIndexOf (Pattern \"c\") \"aaa\" == Nothing\n-- | ```\n-- |\nlastIndexOf :: Pattern -> String -> Maybe Int\nlastIndexOf = _lastIndexOf Just Nothing\n\nforeign import _lastIndexOf\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Pattern\n  -> String\n  -> Maybe Int\n\n-- | Returns the index of the last occurrence of the pattern in the\n-- | given string, starting at the specified index and searching\n-- | backwards towards the beginning of the string.\n-- |\n-- | Starting at a negative index is equivalent to starting at 0 and\n-- | starting at an index greater than the string length is equivalent\n-- | to searching in the whole string.\n-- |\n-- | Returns `Nothing` if there is no match.\n-- |\n-- | ```purescript\n-- | lastIndexOf' (Pattern \"a\") (-1) \"ababa\" == Just 0\n-- | lastIndexOf' (Pattern \"a\") 1 \"ababa\" == Just 0\n-- | lastIndexOf' (Pattern \"a\") 3 \"ababa\" == Just 2\n-- | lastIndexOf' (Pattern \"a\") 4 \"ababa\" == Just 4\n-- | lastIndexOf' (Pattern \"a\") 5 \"ababa\" == Just 4\n-- | ```\n-- |\nlastIndexOf' :: Pattern -> Int -> String -> Maybe Int\nlastIndexOf' = _lastIndexOfStartingAt Just Nothing\n\nforeign import _lastIndexOfStartingAt\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Pattern\n  -> Int\n  -> String\n  -> Maybe Int\n\n-- | Returns the first `n` characters of the string.\n-- |\n-- | ```purescript\n-- | take 5 \"Hello World\" == \"Hello\"\n-- | ```\n-- |\nforeign import take :: Int -> String -> String\n\n-- | Returns the last `n` characters of the string.\n-- |\n-- | ```purescript\n-- | takeRight 5 \"Hello World\" == \"World\"\n-- | ```\n-- |\ntakeRight :: Int -> String -> String\ntakeRight i s = drop (length s - i) s\n\n-- | Returns the longest prefix (possibly empty) of characters that satisfy\n-- | the predicate.\n-- |\n-- | ```purescript\n-- | takeWhile (_ /= ':') \"http://purescript.org\" == \"http\"\n-- | ```\n-- |\ntakeWhile :: (Char -> Boolean) -> String -> String\ntakeWhile p s = take (countPrefix p s) s\n\n-- | Returns the string without the first `n` characters.\n-- |\n-- | ```purescript\n-- | drop 6 \"Hello World\" == \"World\"\n-- | ```\n-- |\nforeign import drop :: Int -> String -> String\n\n-- | Returns the string without the last `n` characters.\n-- |\n-- | ```purescript\n-- | dropRight 6 \"Hello World\" == \"Hello\"\n-- | ```\n-- |\ndropRight :: Int -> String -> String\ndropRight i s = take (length s - i) s\n\n-- | Returns the suffix remaining after `takeWhile`.\n-- |\n-- | ```purescript\n-- | dropWhile (_ /= '.') \"Test.purs\" == \".purs\"\n-- | ```\n-- |\ndropWhile :: (Char -> Boolean) -> String -> String\ndropWhile p s = drop (countPrefix p s) s\n\n-- | Returns the substring at indices `[begin, end)`.\n-- | If either index is negative, it is normalised to `length s - index`,\n-- | where `s` is the input string. `\"\"` is returned if either\n-- | index is out of bounds or if `begin > end` after normalisation.\n-- |\n-- | ```purescript\n-- | slice 0 0   \"purescript\" == \"\"\n-- | slice 0 1   \"purescript\" == \"p\"\n-- | slice 3 6   \"purescript\" == \"esc\"\n-- | slice (-4) (-1) \"purescript\" == \"rip\"\n-- | slice (-4) 3  \"purescript\" == \"\"\n-- | ```\nforeign import slice :: Int -> Int -> String -> String\n\n-- | Splits a string into two substrings, where `before` contains the\n-- | characters up to (but not including) the given index, and `after` contains\n-- | the rest of the string, from that index on.\n-- |\n-- | ```purescript\n-- | splitAt 2 \"Hello World\" == { before: \"He\", after: \"llo World\"}\n-- | splitAt 10 \"Hi\" == { before: \"Hi\", after: \"\"}\n-- | ```\n-- |\n-- | Thus the length of `(splitAt i s).before` will equal either `i` or\n-- | `length s`, if that is shorter. (Or if `i` is negative the length will be\n-- | 0.)\n-- |\n-- | In code:\n-- | ```purescript\n-- | length (splitAt i s).before == min (max i 0) (length s)\n-- | (splitAt i s).before <> (splitAt i s).after == s\n-- | splitAt i s == {before: take i s, after: drop i s}\n-- | ```\nforeign import splitAt :: Int -> String -> { before :: String, after :: String }\n", "export function typeOf(value) {\n  return typeof value;\n}\n\nexport function tagOf(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\n\nexport function isNull(value) {\n  return value === null;\n}\n\nexport function isUndefined(value) {\n  return value === undefined;\n}\n\nexport const isArray = Array.isArray || function (value) {\n  return Object.prototype.toString.call(value) === \"[object Array]\";\n};\n", "-- | This module defines a strict double-ended queue.\n-- |\n-- | The queue implementation is based on a pair of lists where all\n-- | operations require `O(1)` amortized time.\n-- |\n-- | However, any single `uncons` operation may run in `O(n)` time.\n-- |\n-- | See [Simple and Efficient Purely Functional Queues and Dequeues](http://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/jfp95queue.pdf) (Okasaki 1995)\nmodule Data.CatQueue\n  ( CatQueue(..)\n  , empty\n  , null\n  , singleton\n  , length\n  , cons\n  , snoc\n  , uncons\n  , unsnoc\n  , fromFoldable\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.Foldable (class Foldable, foldMap, foldMapDefaultL, foldl, foldrDefault)\nimport Data.List (List(..), reverse)\nimport Data.List as L\nimport Data.Maybe (Maybe(..))\nimport Data.Traversable (class Traversable, sequenceDefault)\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (class Unfoldable, class Unfoldable1)\n\n-- | A strict double-ended queue (dequeue) representated using a pair of lists.\ndata CatQueue a = CatQueue (List a) (List a)\n\n-- | Create an empty queue.\n-- |\n-- | Running time: `O(1)`\nempty :: forall a. CatQueue a\nempty = CatQueue Nil Nil\n\n-- | Test whether a queue is empty.\n-- |\n-- | Running time: `O(1)`\nnull :: forall a. CatQueue a -> Boolean\nnull (CatQueue Nil Nil) = true\nnull _ = false\n\n-- | Create a queue containing a single element.\n-- |\n-- | Running time: `O(1)`\nsingleton :: forall a. a -> CatQueue a\nsingleton = snoc empty\n\n-- | Number of elements in queue.\n-- |\n-- | Running time: `O(n)` in length of queue.\nlength :: forall a. CatQueue a -> Int\nlength (CatQueue l r) = L.length l + L.length r\n\n-- | Append an element to the beginning of the queue, creating a new queue.\n-- |\n-- | Running time: `O(1)`\ncons :: forall a. a -> CatQueue a -> CatQueue a\ncons a (CatQueue l r) = CatQueue (Cons a l) r\n\n-- | Append an element to the end of the queue, creating a new queue.\n-- |\n-- | Running time: `O(1)`\nsnoc :: forall a. CatQueue a -> a -> CatQueue a\nsnoc (CatQueue l r) a = CatQueue l (Cons a r)\n\n-- | Decompose a queue into a `Tuple` of the first element and the rest of the queue.\n-- |\n-- | Running time: `O(1)`\n-- |\n-- | Note that any single operation may run in `O(n)`.\nuncons :: forall a. CatQueue a -> Maybe (Tuple a (CatQueue a))\nuncons (CatQueue Nil Nil) = Nothing\nuncons (CatQueue Nil r) = uncons (CatQueue (reverse r) Nil)\nuncons (CatQueue (Cons a as) r) = Just (Tuple a (CatQueue as r))\n\n-- | Decompose a queue into a `Tuple` of the last element and the rest of the queue.\n-- |\n-- | Running time: `O(1)`\n-- |\n-- | Note that any single operation may run in `O(n)`.\nunsnoc :: forall a. CatQueue a -> Maybe (Tuple a (CatQueue a))\nunsnoc (CatQueue l (Cons a as)) = Just (Tuple a (CatQueue l as))\nunsnoc (CatQueue Nil Nil) = Nothing\nunsnoc (CatQueue l Nil) = unsnoc (CatQueue Nil (reverse l))\n\n-- | Convert any `Foldable` into a `CatQueue`.\n-- |\n-- | Running time: `O(n)`\nfromFoldable :: forall f a. Foldable f => f a -> CatQueue a\nfromFoldable f = foldMap singleton f\n\ncqEq :: forall a. Eq a => CatQueue a -> CatQueue a -> Boolean\ncqEq = go\n  where\n    elemEq = eq :: (a -> a -> Boolean)\n    go xs ys = case uncons xs, uncons ys of\n      Just (Tuple x xs'), Just (Tuple y ys')\n        | x `elemEq` y -> go xs' ys'\n      Nothing, Nothing -> true\n      _      , _       -> false\n\ncqCompare :: forall a. Ord a => CatQueue a -> CatQueue a -> Ordering\ncqCompare = go\n  where\n    elemCompare = compare :: (a -> a -> Ordering)\n    go xs ys = case uncons xs, uncons ys of\n      Just (Tuple x xs'), Just (Tuple y ys') ->\n        case elemCompare x y of\n             EQ       -> go xs' ys'\n             ordering -> ordering\n      Just _,   Nothing -> GT\n      Nothing,  Just _  -> LT\n      Nothing,  Nothing -> EQ\n\ninstance eqCatQueue :: Eq a => Eq (CatQueue a) where\n  eq = cqEq\n\ninstance ordCatQueue :: Ord a => Ord (CatQueue a) where\n  compare = cqCompare\n\n-- | Running time: `O(n) in the length of the second queue`\ninstance semigroupCatQueue :: Semigroup (CatQueue a) where\n  append = foldl snoc\n\ninstance monoidCatQueue :: Monoid (CatQueue a) where\n  mempty = empty\n\ninstance showCatQueue :: Show a => Show (CatQueue a) where\n  show (CatQueue l r) = \"(CatQueue \" <> show l <> \" \" <> show r <> \")\"\n\ninstance foldableCatQueue :: Foldable CatQueue where\n  foldMap = foldMapDefaultL\n  foldr f = foldrDefault f\n  foldl f = go\n    where\n    go acc q = case uncons q of\n       Just (Tuple x xs) -> go (f acc x) xs\n       Nothing -> acc\n\ninstance unfoldable1CatQueue :: Unfoldable1 CatQueue where\n  unfoldr1 f b = go b empty\n    where\n      go source memo = case f source of\n        Tuple one Nothing -> snoc memo one\n        Tuple one (Just rest) -> go rest (snoc memo one)\n\ninstance unfoldableCatQueue :: Unfoldable CatQueue where\n  unfoldr f b = go b empty\n    where\n      go source memo = case f source of\n        Nothing -> memo\n        Just (Tuple one rest) -> go rest (snoc memo one)\n\ninstance traversableCatQueue :: Traversable CatQueue where\n  traverse f =\n    map (foldl snoc empty)\n    <<< foldl (\\acc -> lift2 snoc acc <<< f) (pure empty)\n  sequence = sequenceDefault\n\ninstance functorCatQueue :: Functor CatQueue where\n  map f (CatQueue l r) = CatQueue (map f l) (map f r)\n\ninstance applyCatQueue :: Apply CatQueue where\n  apply = ap\n\ninstance applicativeCatQueue :: Applicative CatQueue where\n  pure = singleton\n\ninstance bindCatQueue :: Bind CatQueue where\n  bind = flip foldMap\n\ninstance monadCatQueue :: Monad CatQueue\n\ninstance altCatQueue :: Alt CatQueue where\n  alt = append\n\ninstance plusCatQueue :: Plus CatQueue where\n  empty = empty\n\ninstance alternativeCatQueue :: Alternative CatQueue\n\ninstance monadPlusCatQueue :: MonadPlus CatQueue\n", "-- | This module defines a strict catenable list.\n-- |\n-- | The implementation is based on a queue where all operations require\n-- | `O(1)` amortized time.\n-- |\n-- | However, any single `uncons` operation may run in `O(n)` time.\n-- |\n-- | See [Purely Functional Data Structures](http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf) (Okasaki 1996)\nmodule Data.CatList\n  ( CatList(..)\n  , empty\n  , null\n  , singleton\n  , length\n  , append\n  , cons\n  , snoc\n  , uncons\n  , fromFoldable\n  ) where\n\nimport Prelude hiding (append)\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.CatQueue as Q\nimport Data.Foldable (class Foldable, foldMapDefaultL)\nimport Data.Foldable as Foldable\nimport Data.List as L\nimport Data.Maybe (Maybe(..))\nimport Data.Traversable (sequence, traverse, class Traversable)\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (class Unfoldable)\nimport Data.Unfoldable1 (class Unfoldable1)\n\n-- | A strict catenable list.\n-- |\n-- | `CatList` may be empty, represented by `CatNil`.\n-- |\n-- | `CatList` may be non-empty, represented by `CatCons`. The `CatCons`\n-- | data constructor takes the first element of the list and a queue of\n-- | `CatList`.\ndata CatList a = CatNil | CatCons a (Q.CatQueue (CatList a))\n\n-- | Create an empty catenable list.\n-- |\n-- | Running time: `O(1)`\nempty :: forall a. CatList a\nempty = CatNil\n\n-- | Test whether a catenable list is empty.\n-- |\n-- | Running time: `O(1)`\nnull :: forall a. CatList a -> Boolean\nnull CatNil = true\nnull _ = false\n\n-- | Number of elements in queue.\n-- |\n-- | Running time: `O(n)` in length of queue.\nlength :: forall a. CatList a -> Int\nlength = Foldable.length\n\n-- | Append all elements of a catenable list to the end of another\n-- | catenable list, create a new catenable list.\n-- |\n-- | Running time: `O(1)`\nappend :: forall a. CatList a -> CatList a -> CatList a\nappend = link\n\n-- | Append an element to the beginning of the catenable list, creating a new\n-- | catenable list.\n-- |\n-- | Running time: `O(1)`\ncons :: forall a. a -> CatList a -> CatList a\ncons a cat = append (CatCons a Q.empty) cat\n\n-- | Create a catenable list with a single item.\n-- |\n-- | Running time: `O(1)`\nsingleton :: forall a. a -> CatList a\nsingleton a = cons a CatNil\n\n-- | Append an element to the end of the catenable list, creating a new\n-- | catenable list.\n-- |\n-- | Running time: `O(1)`\nsnoc :: forall a. CatList a -> a -> CatList a\nsnoc cat a = append cat (CatCons a Q.empty)\n\n-- | Decompose a catenable list into a `Tuple` of the first element and\n-- | the rest of the catenable list.\n-- |\n-- | Running time: `O(1)`\n-- |\n-- | Note that any single operation may run in `O(n)`.\nuncons :: forall a. CatList a -> Maybe (Tuple a (CatList a))\nuncons CatNil = Nothing\nuncons (CatCons a q) = Just (Tuple a (if Q.null q then CatNil else (foldr link CatNil q)))\n\n-- | Links two catenable lists by making appending the queue in the\n-- | first catenable list to the second catenable list. This operation\n-- | creates a new catenable list.\n-- |\n-- | Running time: `O(1)`\nlink :: forall a. CatList a -> CatList a -> CatList a\nlink CatNil cat = cat\nlink cat CatNil = cat\nlink (CatCons a q) cat = CatCons a (Q.snoc q cat)\n\n-- | Tail recursive version of foldr on `CatList`.\n-- |\n-- | Ensures foldl on `List` is tail-recursive.\nfoldr :: forall a. (CatList a -> CatList a -> CatList a) -> CatList a -> Q.CatQueue (CatList a) -> CatList a\nfoldr k b q = go q L.Nil\n  where\n  go :: Q.CatQueue (CatList a) -> L.List (CatList a -> CatList a) -> CatList a\n  go xs ys = case Q.uncons xs of\n                  Nothing -> foldl (\\x i -> i x) b ys\n                  Just (Tuple a rest) -> go rest (L.Cons (k a) ys)\n\n  foldl :: forall b c. (c -> b -> c) -> c -> L.List b -> c\n  foldl _ c L.Nil = c\n  foldl k' c (L.Cons b' as) = foldl k' (k' c b') as\n\n-- | Convert any `Foldable` into a `CatList`.\n-- |\n-- | Running time: `O(n)`\nfromFoldable :: forall f. Foldable f => f ~> CatList\nfromFoldable f = Foldable.foldMap singleton f\n\nfoldMap :: forall a m. Monoid m => (a -> m) -> CatList a -> m\nfoldMap _ CatNil = mempty\nfoldMap f (CatCons a q) =\n  let d = if Q.null q then CatNil else (foldr link CatNil q)\n  in f a <> foldMap f d\n\n-- | Running time: `O(1)`\ninstance semigroupCatList :: Semigroup (CatList a) where\n  append = append\n\ninstance monoidCatList :: Monoid (CatList a) where\n  mempty = CatNil\n\ninstance showCatList :: Show a => Show (CatList a) where\n  show CatNil = \"CatNil\"\n  show (CatCons a as) = \"(CatList \" <> show a <> \" \" <> show as <> \")\"\n\ninstance foldableCatList :: Foldable CatList where\n  foldMap = foldMapDefaultL\n  foldr f s l = Foldable.foldrDefault f s l\n  foldl f = go\n    where\n    go acc q = case uncons q of\n       Just (Tuple x xs) -> go (f acc x) xs\n       Nothing -> acc\n\ninstance unfoldableCatList :: Unfoldable CatList where\n  unfoldr f b = go b CatNil\n    where\n      go source memo = case f source of\n        Nothing -> memo\n        Just (Tuple one rest) -> go rest (snoc memo one)\n\ninstance unfoldable1CatList :: Unfoldable1 CatList where\n  unfoldr1 f b = go b CatNil\n    where\n      go source memo = case f source of\n        Tuple one Nothing -> snoc memo one\n        Tuple one (Just rest) -> go rest (snoc memo one)\n\ninstance traversableCatList :: Traversable CatList where\n  traverse _ CatNil = pure CatNil\n  traverse f (CatCons a q) =\n    let d = if Q.null q then CatNil else (foldr link CatNil q)\n    in cons <$> f a <*> traverse f d\n  sequence CatNil = pure CatNil\n  sequence (CatCons a q) =\n    let d = if Q.null q then CatNil else (foldr link CatNil q)\n    in cons <$> a <*> sequence d\n\ninstance functorCatList :: Functor CatList where\n  map _ CatNil = CatNil\n  map f (CatCons a q) =\n    let d = if Q.null q then CatNil else (foldr link CatNil q)\n    in f a `cons` map f d\n\ninstance applyCatList :: Apply CatList where\n  apply = ap\n\ninstance applicativeCatList :: Applicative CatList where\n  pure = singleton\n\ninstance bindCatList :: Bind CatList where\n  bind = flip foldMap\n\ninstance monadCatList :: Monad CatList\n\ninstance altCatList :: Alt CatList where\n  alt = append\n\ninstance plusCatList :: Plus CatList where\n  empty = empty\n\ninstance alternativeCatList :: Alternative CatList\n\ninstance monadPlusCatList :: MonadPlus CatList\n", "module Control.Monad.Free\n  ( Free\n  , suspendF\n  , wrap\n  , liftF\n  , hoistFree\n  , foldFree\n  , substFree\n  , runFree\n  , runFreeM\n  , resume\n  , resume'\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..), tailRecM)\nimport Control.Monad.Trans.Class (class MonadTrans)\n\nimport Data.CatList (CatList, empty, snoc, uncons)\nimport Data.Either (Either(..))\nimport Data.Eq (class Eq1, eq1)\nimport Data.Foldable (class Foldable, foldMap, foldl, foldr)\nimport Data.Maybe (Maybe(..))\nimport Data.Ord (class Ord1, compare1)\nimport Data.Traversable (class Traversable, traverse)\nimport Data.Tuple (Tuple(..))\n\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | The free monad for a type constructor `f`.\n-- |\n-- | Implemented in the spirit of [Reflection without Remorse](http://okmij.org/ftp/Haskell/zseq.pdf),\n-- | the free monad is represented using a sequential data structure in\n-- | order to overcome the quadratic complexity of left-associated binds\n-- | and traversal through the free monad structure.\ndata Free f a = Free (FreeView f Val Val) (CatList (ExpF f))\n\nnewtype ExpF f = ExpF (Val -> Free f Val)\n\ndata FreeView f a b = Return a | Bind (f b) (b -> Free f a)\n\ndata Val\n\ninstance eqFree :: (Functor f, Eq1 f, Eq a) => Eq (Free f a) where\n  eq x y = case resume x, resume y of\n    Left fa, Left fb -> eq1 fa fb\n    Right a, Right b -> a == b\n    _, _ -> false\n\ninstance eq1Free :: (Functor f, Eq1 f) => Eq1 (Free f) where\n  eq1 = eq\n\ninstance ordFree :: (Functor f, Ord1 f, Ord a) => Ord (Free f a) where\n  compare x y = case resume x, resume y of\n    Left fa, Left fb -> compare1 fa fb\n    Left _, _ -> LT\n    _, Left _ -> GT\n    Right a, Right b -> compare a b\n\ninstance ord1Free :: (Functor f, Ord1 f) => Ord1 (Free f) where\n  compare1 = compare\n\ninstance freeFunctor :: Functor (Free f) where\n  map k f = pure <<< k =<< f\n\ninstance freeBind :: Bind (Free f) where\n  bind (Free v s) k = Free v (snoc s (ExpF (unsafeCoerceBind k)))\n    where\n    unsafeCoerceBind :: forall a b. (a -> Free f b) -> Val -> Free f Val\n    unsafeCoerceBind = unsafeCoerce\n\ninstance freeApplicative :: Applicative (Free f) where\n  pure = fromView <<< Return\n\ninstance freeApply :: Apply (Free f) where\n  apply = ap\n\ninstance freeMonad :: Monad (Free f)\n\ninstance freeMonadTrans :: MonadTrans Free where\n  lift = liftF\n\ninstance freeMonadRec :: MonadRec (Free f) where\n  tailRecM k a = k a >>= case _ of\n    Loop b -> tailRecM k b\n    Done r -> pure r\n\ninstance foldableFree :: (Functor f, Foldable f) => Foldable (Free f) where\n  foldMap f = go\n    where\n    go = resume >>> case _ of\n      Left fa -> foldMap go fa\n      Right a -> f a\n  foldl f = go\n    where\n    go r = resume >>> case _  of\n      Left fa -> foldl go r fa\n      Right a -> f r a\n  foldr f = go\n    where\n    go r = resume >>> case _ of\n      Left fa -> foldr (flip go) r fa\n      Right a -> f a r\n\ninstance traversableFree :: Traversable f => Traversable (Free f) where\n  traverse f = go\n    where\n    go = resume >>> case _ of\n      Left fa -> join <<< liftF <$> traverse go fa\n      Right a -> pure <$> f a\n  sequence tma = traverse identity tma\n\ninstance semigroupFree :: Semigroup a => Semigroup (Free f a) where\n  append = lift2 append\n\ninstance monoidFree :: Monoid a => Monoid (Free f a) where\n  mempty = pure mempty\n  \n-- | Lift an impure value described by the generating type constructor `f` into\n-- | the free monad.\nliftF :: forall f. f ~> Free f\nliftF f = fromView (Bind (unsafeCoerceF f) (pure <<< unsafeCoerceVal))\n  where\n  unsafeCoerceF :: forall a. f a -> f Val\n  unsafeCoerceF = unsafeCoerce\n\n  unsafeCoerceVal :: forall a. Val -> a\n  unsafeCoerceVal = unsafeCoerce\n\n-- | Add a layer.\nwrap :: forall f a. f (Free f a) -> Free f a\nwrap f = fromView (Bind (unsafeCoerceF f) unsafeCoerceVal)\n  where\n  unsafeCoerceF :: forall b. f (Free f b) -> f Val\n  unsafeCoerceF = unsafeCoerce\n\n  unsafeCoerceVal :: forall b. Val -> Free f b\n  unsafeCoerceVal = unsafeCoerce\n\n-- | Suspend a value given the applicative functor `f` into the free monad.\nsuspendF :: forall f. Applicative f => Free f ~> Free f\nsuspendF f = wrap (pure f)\n\n-- | Use a natural transformation to change the generating type constructor of a\n-- | free monad.\nhoistFree :: forall f g. (f ~> g) -> Free f ~> Free g\nhoistFree k = substFree (liftF <<< k)\n\n-- | Run a free monad with a natural transformation from the type constructor `f`\n-- | to the tail-recursive monad `m`. See the `MonadRec` type class for more\n-- | details.\nfoldFree :: forall f m. MonadRec m => (f ~> m) -> Free f ~> m\nfoldFree k = tailRecM go\n  where\n  go :: forall a. Free f a -> m (Step (Free f a) a)\n  go f = case toView f of\n    Return a -> Done <$> pure a\n    Bind g i -> (Loop <<< i) <$> k g\n\n-- | Like `foldFree`, but for folding into some other Free monad without the\n-- | overhead that `MonadRec` incurs.\nsubstFree :: forall f g. (f ~> Free g) -> Free f ~> Free g\nsubstFree k = go\n  where\n  go :: Free f ~> Free g\n  go f = case toView f of\n    Return a -> pure a\n    Bind g i -> k g >>= go <$> i\n\n-- | Run a free monad with a function that unwraps a single layer of the functor\n-- | `f` at a time.\nrunFree :: forall f a. Functor f => (f (Free f a) -> Free f a) -> Free f a -> a\nrunFree k = go\n  where\n  go :: Free f a -> a\n  go f = case toView f of\n    Return a -> a\n    Bind g i -> go (k (i <$> g))\n\n-- | Run a free monad with a function mapping a functor `f` to a tail-recursive\n-- | monad `m`. See the `MonadRec` type class for more details.\nrunFreeM\n  :: forall f m a\n   . Functor f\n  => MonadRec m\n  => (f (Free f a) -> m (Free f a))\n  -> Free f a\n  -> m a\nrunFreeM k = tailRecM go\n  where\n  go :: Free f a -> m (Step (Free f a) a)\n  go f = case toView f of\n    Return a -> Done <$> pure a\n    Bind g i -> Loop <$> k (i <$> g)\n\n-- | Unwraps a single layer of the functor `f`.\nresume\n  :: forall f a\n   . Functor f\n  => Free f a\n  -> Either (f (Free f a)) a\nresume = resume' (\\g i -> Left (i <$> g)) Right\n\n-- | Unwraps a single layer of `f`, providing the continuation.\nresume'\n  :: forall f a r\n   . (forall b. f b -> (b -> Free f a) -> r)\n  -> (a -> r)\n  -> Free f a\n  -> r\nresume' k j f = case toView f of\n  Return a -> j a\n  Bind g i -> k g i\n\nfromView :: forall f a. FreeView f a Val -> Free f a\nfromView f = Free (unsafeCoerceFreeView f) empty\n  where\n  unsafeCoerceFreeView :: FreeView f a Val -> FreeView f Val Val\n  unsafeCoerceFreeView = unsafeCoerce\n\ntoView :: forall f a. Free f a -> FreeView f a Val\ntoView (Free v s) =\n  case v of\n    Return a ->\n      case uncons s of\n        Nothing ->\n          Return (unsafeCoerceVal a)\n        Just (Tuple h t) ->\n          toView (unsafeCoerceFree (concatF ((runExpF h) a) t))\n    Bind f k ->\n      Bind f (\\a -> unsafeCoerceFree (concatF (k a) s))\n  where\n  concatF :: Free f Val -> CatList (ExpF f) -> Free f Val\n  concatF (Free v' l) r = Free v' (l <> r)\n\n  runExpF :: ExpF f -> (Val -> Free f Val)\n  runExpF (ExpF k) = k\n\n  unsafeCoerceFree :: Free f Val -> Free f a\n  unsafeCoerceFree = unsafeCoerce\n\n  unsafeCoerceVal :: Val -> a\n  unsafeCoerceVal = unsafeCoerce\n", "/* eslint-disable no-eq-null, eqeqeq */\n\nconst nullImpl = null;\nexport { nullImpl as null };\n\nexport function nullable(a, r, f) {\n  return a == null ? r : f(a);\n}\n\nexport function notNull(x) {\n  return x;\n}\n", "-- | This module defines types and functions for working with nullable types\n-- | using the FFI.\n\nmodule Data.Nullable\n  ( Nullable\n  , null\n  , notNull\n  , toMaybe\n  , toNullable\n  ) where\n\nimport Prelude\n\nimport Data.Eq (class Eq1)\nimport Data.Function (on)\nimport Data.Function.Uncurried (Fn3, runFn3)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Ord (class Ord1)\n\n-- | A nullable type. This type constructor is intended to be used for\n-- | interoperating with JavaScript functions which accept or return null\n-- | values.\n-- |\n-- | The runtime representation of `Nullable T` is the same as that of `T`,\n-- | except that it may also be `null`. For example, the JavaScript values\n-- | `null`, `[]`, and `[1,2,3]` may all be given the type\n-- | `Nullable (Array Int)`. Similarly, the JavaScript values `[]`, `[null]`,\n-- | and `[1,2,null,3]` may all be given the type `Array (Nullable Int)`.\n-- |\n-- | There is one pitfall with `Nullable`, which is that values of the type\n-- | `Nullable T` will not function as you might expect if the type `T` happens\n-- | to itself permit `null` as a valid runtime representation.\n-- |\n-- | In particular, values of the type `Nullable (Nullable T)` will \u2018collapse\u2019,\n-- | in the sense that the PureScript expressions `notNull null` and `null`\n-- | will both leave you with a value whose runtime representation is just\n-- | `null`. Therefore it is important to avoid using `Nullable T` in\n-- | situations where `T` itself can take `null` as a runtime representation.\n-- | If in doubt, use `Maybe` instead.\n-- |\n-- | `Nullable` does not permit lawful `Functor`, `Applicative`, or `Monad`\n-- | instances as a result of this pitfall, which is why these instances are\n-- | not provided.\nforeign import data Nullable :: Type -> Type\n\ntype role Nullable representational\n\n-- | The null value.\nforeign import null :: forall a. Nullable a\n\nforeign import nullable :: forall a r. Fn3 (Nullable a) r (a -> r) r\n\n-- | Wrap a non-null value.\nforeign import notNull :: forall a. a -> Nullable a\n\n-- | Takes `Nothing` to `null`, and `Just a` to `a`.\ntoNullable :: forall a. Maybe a -> Nullable a\ntoNullable = maybe null notNull\n\n-- | Represent `null` using `Maybe a` as `Nothing`. Note that this function\n-- | can violate parametricity, as it inspects the runtime representation of\n-- | its argument (see the warning about the pitfall of `Nullable` above).\ntoMaybe :: forall a. Nullable a -> Maybe a\ntoMaybe n = runFn3 nullable n Nothing Just\n\ninstance showNullable :: Show a => Show (Nullable a) where\n  show = maybe \"null\" show <<< toMaybe\n\ninstance eqNullable :: Eq a => Eq (Nullable a) where\n  eq = eq `on` toMaybe\n\ninstance eq1Nullable :: Eq1 Nullable where\n  eq1 = eq\n\ninstance ordNullable :: Ord a => Ord (Nullable a) where\n  compare = compare `on` toMaybe\n\ninstance ord1Nullable :: Ord1 Nullable where\n  compare1 = compare\n", "export const mkEffectFn1 = function mkEffectFn1(fn) {\n  return function(x) {\n    return fn(x)();\n  };\n};\n\nexport const mkEffectFn2 = function mkEffectFn2(fn) {\n  return function(a, b) {\n    return fn(a)(b)();\n  };\n};\n\nexport const mkEffectFn3 = function mkEffectFn3(fn) {\n  return function(a, b, c) {\n    return fn(a)(b)(c)();\n  };\n};\n\nexport const mkEffectFn4 = function mkEffectFn4(fn) {\n  return function(a, b, c, d) {\n    return fn(a)(b)(c)(d)();\n  };\n};\n\nexport const mkEffectFn5 = function mkEffectFn5(fn) {\n  return function(a, b, c, d, e) {\n    return fn(a)(b)(c)(d)(e)();\n  };\n};\n\nexport const mkEffectFn6 = function mkEffectFn6(fn) {\n  return function(a, b, c, d, e, f) {\n    return fn(a)(b)(c)(d)(e)(f)();\n  };\n};\n\nexport const mkEffectFn7 = function mkEffectFn7(fn) {\n  return function(a, b, c, d, e, f, g) {\n    return fn(a)(b)(c)(d)(e)(f)(g)();\n  };\n};\n\nexport const mkEffectFn8 = function mkEffectFn8(fn) {\n  return function(a, b, c, d, e, f, g, h) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)();\n  };\n};\n\nexport const mkEffectFn9 = function mkEffectFn9(fn) {\n  return function(a, b, c, d, e, f, g, h, i) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)();\n  };\n};\n\nexport const mkEffectFn10 = function mkEffectFn10(fn) {\n  return function(a, b, c, d, e, f, g, h, i, j) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)();\n  };\n};\n\nexport const runEffectFn1 = function runEffectFn1(fn) {\n  return function(a) {\n    return function() {\n      return fn(a);\n    };\n  };\n};\n\nexport const runEffectFn2 = function runEffectFn2(fn) {\n  return function(a) {\n    return function(b) {\n      return function() {\n        return fn(a, b);\n      };\n    };\n  };\n};\n\nexport const runEffectFn3 = function runEffectFn3(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function() {\n          return fn(a, b, c);\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn4 = function runEffectFn4(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function() {\n            return fn(a, b, c, d);\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn5 = function runEffectFn5(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function() {\n              return fn(a, b, c, d, e);\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn6 = function runEffectFn6(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function() {\n                return fn(a, b, c, d, e, f);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn7 = function runEffectFn7(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function() {\n                  return fn(a, b, c, d, e, f, g);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn8 = function runEffectFn8(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function() {\n                    return fn(a, b, c, d, e, f, g, h);\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn9 = function runEffectFn9(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function(i) {\n                    return function() {\n                      return fn(a, b, c, d, e, f, g, h, i);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn10 = function runEffectFn10(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function(i) {\n                    return function(j) {\n                      return function() {\n                        return fn(a, b, c, d, e, f, g, h, i, j);\n                      };\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n", "-- | This module defines types for effectful uncurried functions, as well as\n-- | functions for converting back and forth between them.\n-- |\n-- | This makes it possible to give a PureScript type to JavaScript functions\n-- | such as this one:\n-- |\n-- | ```javascript\n-- | function logMessage(level, message) {\n-- |   console.log(level + \": \" + message);\n-- | }\n-- | ```\n-- |\n-- | In particular, note that `logMessage` performs effects immediately after\n-- | receiving all of its parameters, so giving it the type `Data.Function.Fn2\n-- | String String Unit`, while convenient, would effectively be a lie.\n-- |\n-- | One way to handle this would be to convert the function into the normal\n-- | PureScript form (namely, a curried function returning an Effect action),\n-- | and performing the marshalling in JavaScript, in the FFI module, like this:\n-- |\n-- | ```purescript\n-- | -- In the PureScript file:\n-- | foreign import logMessage :: String -> String -> Effect Unit\n-- | ```\n-- |\n-- | ```javascript\n-- | // In the FFI file:\n-- | exports.logMessage = function(level) {\n-- |   return function(message) {\n-- |     return function() {\n-- |       logMessage(level, message);\n-- |     };\n-- |   };\n-- | };\n-- | ```\n-- |\n-- | This method, unfortunately, turns out to be both tiresome and error-prone.\n-- | This module offers an alternative solution. By providing you with:\n-- |\n-- |  * the ability to give the real `logMessage` function a PureScript type,\n-- |    and\n-- |  * functions for converting between this form and the normal PureScript\n-- |    form,\n-- |\n-- | the FFI boilerplate is no longer needed. The previous example becomes:\n-- |\n-- | ```purescript\n-- | -- In the PureScript file:\n-- | foreign import logMessageImpl :: EffectFn2 String String Unit\n-- | ```\n-- |\n-- | ```javascript\n-- | // In the FFI file:\n-- | exports.logMessageImpl = logMessage\n-- | ```\n-- |\n-- | You can then use `runEffectFn2` to provide a nicer version:\n-- |\n-- | ```purescript\n-- | logMessage :: String -> String -> Effect Unit\n-- | logMessage = runEffectFn2 logMessageImpl\n-- | ```\n-- |\n-- | (note that this has the same type as the original `logMessage`).\n-- |\n-- | Effectively, we have reduced the risk of errors by moving as much code into\n-- | PureScript as possible, so that we can leverage the type system. Hopefully,\n-- | this is a little less tiresome too.\n-- |\n-- | Here's a slightly more advanced example. Here, because we are using\n-- | callbacks, we need to use `mkEffectFn{N}` as well.\n-- |\n-- | Suppose our `logMessage` changes so that it sometimes sends details of the\n-- | message to some external server, and in those cases, we want the resulting\n-- | `HttpResponse` (for whatever reason).\n-- |\n-- | ```javascript\n-- | function logMessage(level, message, callback) {\n-- |   console.log(level + \": \" + message);\n-- |   if (level > LogLevel.WARN) {\n-- |     LogAggregatorService.post(\"/logs\", {\n-- |       level: level,\n-- |       message: message\n-- |     }, callback);\n-- |   } else {\n-- |     callback(null);\n-- |   }\n-- | }\n-- | ```\n-- |\n-- | The import then looks like this:\n-- | ```purescript\n-- | foreign import logMessageImpl\n-- |  EffectFn3\n-- |    String\n-- |    String\n-- |    (EffectFn1 (Nullable HttpResponse) Unit)\n-- |    Unit\n-- | ```\n-- |\n-- | And, as before, the FFI file is extremely simple:\n-- |\n-- | ```javascript\n-- | exports.logMessageImpl = logMessage\n-- | ```\n-- |\n-- | Finally, we use `runEffectFn{N}` and `mkEffectFn{N}` for a more comfortable\n-- | PureScript version:\n-- |\n-- | ```purescript\n-- | logMessage ::\n-- |   String ->\n-- |   String ->\n-- |   (Nullable HttpResponse -> Effect Unit) ->\n-- |   Effect Unit\n-- | logMessage level message callback =\n-- |   runEffectFn3 logMessageImpl level message (mkEffectFn1 callback)\n-- | ```\n-- |\n-- | The general naming scheme for functions and types in this module is as\n-- | follows:\n-- |\n-- | * `EffectFn{N}` means, an uncurried function which accepts N arguments and\n-- |   performs some effects. The first N arguments are the actual function's\n-- |   argument. The last type argument is the return type.\n-- | * `runEffectFn{N}` takes an `EffectFn` of N arguments, and converts it into\n-- |   the normal PureScript form: a curried function which returns an Effect\n-- |   action.\n-- | * `mkEffectFn{N}` is the inverse of `runEffectFn{N}`. It can be useful for\n-- |   callbacks.\n-- |\n\nmodule Effect.Uncurried where\n\nimport Data.Monoid (class Monoid, class Semigroup, mempty, (<>))\nimport Effect (Effect)\n\nforeign import data EffectFn1 :: Type -> Type -> Type\n\ntype role EffectFn1 representational representational\n\nforeign import data EffectFn2 :: Type -> Type -> Type -> Type\n\ntype role EffectFn2 representational representational representational\n\nforeign import data EffectFn3 :: Type -> Type -> Type -> Type -> Type\n\ntype role EffectFn3 representational representational representational representational\n\nforeign import data EffectFn4 :: Type -> Type -> Type -> Type -> Type -> Type\n\ntype role EffectFn4 representational representational representational representational representational\n\nforeign import data EffectFn5 :: Type -> Type -> Type -> Type -> Type -> Type -> Type\n\ntype role EffectFn5 representational representational representational representational representational representational\n\nforeign import data EffectFn6 :: Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type\n\ntype role EffectFn6 representational representational representational representational representational representational representational\n\nforeign import data EffectFn7 :: Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type\n\ntype role EffectFn7 representational representational representational representational representational representational representational representational\n\nforeign import data EffectFn8 :: Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type\n\ntype role EffectFn8 representational representational representational representational representational representational representational representational representational\n\nforeign import data EffectFn9 :: Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type\n\ntype role EffectFn9 representational representational representational representational representational representational representational representational representational representational\n\nforeign import data EffectFn10 :: Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type\n\ntype role EffectFn10 representational representational representational representational representational representational representational representational representational representational representational\n\nforeign import mkEffectFn1 :: forall a r.\n  (a -> Effect r) -> EffectFn1 a r\nforeign import mkEffectFn2 :: forall a b r.\n  (a -> b -> Effect r) -> EffectFn2 a b r\nforeign import mkEffectFn3 :: forall a b c r.\n  (a -> b -> c -> Effect r) -> EffectFn3 a b c r\nforeign import mkEffectFn4 :: forall a b c d r.\n  (a -> b -> c -> d -> Effect r) -> EffectFn4 a b c d r\nforeign import mkEffectFn5 :: forall a b c d e r.\n  (a -> b -> c -> d -> e -> Effect r) -> EffectFn5 a b c d e r\nforeign import mkEffectFn6 :: forall a b c d e f r.\n  (a -> b -> c -> d -> e -> f -> Effect r) -> EffectFn6 a b c d e f r\nforeign import mkEffectFn7 :: forall a b c d e f g r.\n  (a -> b -> c -> d -> e -> f -> g -> Effect r) -> EffectFn7 a b c d e f g r\nforeign import mkEffectFn8 :: forall a b c d e f g h r.\n  (a -> b -> c -> d -> e -> f -> g -> h -> Effect r) -> EffectFn8 a b c d e f g h r\nforeign import mkEffectFn9 :: forall a b c d e f g h i r.\n  (a -> b -> c -> d -> e -> f -> g -> h -> i -> Effect r) -> EffectFn9 a b c d e f g h i r\nforeign import mkEffectFn10 :: forall a b c d e f g h i j r.\n  (a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> Effect r) -> EffectFn10 a b c d e f g h i j r\n\nforeign import runEffectFn1 :: forall a r.\n  EffectFn1 a r -> a -> Effect r\nforeign import runEffectFn2 :: forall a b r.\n  EffectFn2 a b r -> a -> b -> Effect r\nforeign import runEffectFn3 :: forall a b c r.\n  EffectFn3 a b c r -> a -> b -> c -> Effect r\nforeign import runEffectFn4 :: forall a b c d r.\n  EffectFn4 a b c d r -> a -> b -> c -> d -> Effect r\nforeign import runEffectFn5 :: forall a b c d e r.\n  EffectFn5 a b c d e r -> a -> b -> c -> d -> e -> Effect r\nforeign import runEffectFn6 :: forall a b c d e f r.\n  EffectFn6 a b c d e f r -> a -> b -> c -> d -> e -> f -> Effect r\nforeign import runEffectFn7 :: forall a b c d e f g r.\n  EffectFn7 a b c d e f g r -> a -> b -> c -> d -> e -> f -> g -> Effect r\nforeign import runEffectFn8 :: forall a b c d e f g h r.\n  EffectFn8 a b c d e f g h r -> a -> b -> c -> d -> e -> f -> g -> h -> Effect r\nforeign import runEffectFn9 :: forall a b c d e f g h i r.\n  EffectFn9 a b c d e f g h i r -> a -> b -> c -> d -> e -> f -> g -> h -> i -> Effect r\nforeign import runEffectFn10 :: forall a b c d e f g h i j r.\n  EffectFn10 a b c d e f g h i j r -> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> Effect r\n\n-- The reason these are written eta-expanded instead of as:\n-- ```\n-- append f1 f2 = mkEffectFnN $ runEffectFnN f1 <> runEffectFnN f2\n-- ```\n-- is to help the compiler recognize that it can emit uncurried\n-- JS functions (which are more efficient), when an appended\n-- EffectFn is applied to all its arguments\n\ninstance semigroupEffectFn1 :: Semigroup r => Semigroup (EffectFn1 a r) where\n  append f1 f2 = mkEffectFn1 \\a -> runEffectFn1 f1 a <> runEffectFn1 f2 a\n\ninstance semigroupEffectFn2 :: Semigroup r => Semigroup (EffectFn2 a b r) where\n  append f1 f2 = mkEffectFn2 \\a b -> runEffectFn2 f1 a b <> runEffectFn2 f2 a b\n\ninstance semigroupEffectFn3 :: Semigroup r => Semigroup (EffectFn3 a b c r) where\n  append f1 f2 = mkEffectFn3 \\a b c -> runEffectFn3 f1 a b c <> runEffectFn3 f2 a b c\n\ninstance semigroupEffectFn4 :: Semigroup r => Semigroup (EffectFn4 a b c d r) where\n  append f1 f2 = mkEffectFn4 \\a b c d -> runEffectFn4 f1 a b c d <> runEffectFn4 f2 a b c d\n\ninstance semigroupEffectFn5 :: Semigroup r => Semigroup (EffectFn5 a b c d e r) where\n  append f1 f2 = mkEffectFn5 \\a b c d e -> runEffectFn5 f1 a b c d e <> runEffectFn5 f2 a b c d e\n\ninstance semigroupEffectFn6 :: Semigroup r => Semigroup (EffectFn6 a b c d e f r) where\n  append f1 f2 = mkEffectFn6 \\a b c d e f -> runEffectFn6 f1 a b c d e f <> runEffectFn6 f2 a b c d e f\n\ninstance semigroupEffectFn7 :: Semigroup r => Semigroup (EffectFn7 a b c d e f g r) where\n  append f1 f2 = mkEffectFn7 \\a b c d e f g -> runEffectFn7 f1 a b c d e f g <> runEffectFn7 f2 a b c d e f g\n\ninstance semigroupEffectFn8 :: Semigroup r => Semigroup (EffectFn8 a b c d e f g h r) where\n  append f1 f2 = mkEffectFn8 \\a b c d e f g h -> runEffectFn8 f1 a b c d e f g h <> runEffectFn8 f2 a b c d e f g h\n\ninstance semigroupEffectFn9 :: Semigroup r => Semigroup (EffectFn9 a b c d e f g h i r) where\n  append f1 f2 = mkEffectFn9 \\a b c d e f g h i -> runEffectFn9 f1 a b c d e f g h i <> runEffectFn9 f2 a b c d e f g h i\n\ninstance semigroupEffectFn10 :: Semigroup r => Semigroup (EffectFn10 a b c d e f g h i j r) where\n  append f1 f2 = mkEffectFn10 \\a b c d e f g h i j -> runEffectFn10 f1 a b c d e f g h i j <> runEffectFn10 f2 a b c d e f g h i j\n\ninstance monoidEffectFn1 :: Monoid r => Monoid (EffectFn1 a r) where\n  mempty = mkEffectFn1 \\_ -> mempty\n\ninstance monoidEffectFn2 :: Monoid r => Monoid (EffectFn2 a b r) where\n  mempty = mkEffectFn2 \\_ _ -> mempty\n\ninstance monoidEffectFn3 :: Monoid r => Monoid (EffectFn3 a b c r) where\n  mempty = mkEffectFn3 \\_ _ _ -> mempty\n\ninstance monoidEffectFn4 :: Monoid r => Monoid (EffectFn4 a b c d r) where\n  mempty = mkEffectFn4 \\_ _ _ _ -> mempty\n\ninstance monoidEffectFn5 :: Monoid r => Monoid (EffectFn5 a b c d e r) where\n  mempty = mkEffectFn5 \\_ _ _ _ _ -> mempty\n\ninstance monoidEffectFn6 :: Monoid r => Monoid (EffectFn6 a b c d e f r) where\n  mempty = mkEffectFn6 \\_ _ _ _ _ _ -> mempty\n\ninstance monoidEffectFn7 :: Monoid r => Monoid (EffectFn7 a b c d e f g r) where\n  mempty = mkEffectFn7 \\_ _ _ _ _ _ _ -> mempty\n\ninstance monoidEffectFn8 :: Monoid r => Monoid (EffectFn8 a b c d e f g h r) where\n  mempty = mkEffectFn8 \\_ _ _ _ _ _ _ _ -> mempty\n\ninstance monoidEffectFn9 :: Monoid r => Monoid (EffectFn9 a b c d e f g h i r) where\n  mempty = mkEffectFn9 \\_ _ _ _ _ _ _ _ _ -> mempty\n\ninstance monoidEffectFn10 :: Monoid r => Monoid (EffectFn10 a b c d e f g h i j r) where\n  mempty = mkEffectFn10 \\_ _ _ _ _ _ _ _ _ _ -> mempty\n", "export function _copyST(m) {\n  return function () {\n    var r = {};\n    for (var k in m) {\n      if (hasOwnProperty.call(m, k)) {\n        r[k] = m[k];\n      }\n    }\n    return r;\n  };\n}\n\nexport const empty = {};\n\nexport function runST(f) {\n  return f();\n}\n\nexport function _fmapObject(m0, f) {\n  var m = {};\n  for (var k in m0) {\n    if (hasOwnProperty.call(m0, k)) {\n      m[k] = f(m0[k]);\n    }\n  }\n  return m;\n}\n\nexport function _mapWithKey(m0, f) {\n  var m = {};\n  for (var k in m0) {\n    if (hasOwnProperty.call(m0, k)) {\n      m[k] = f(k)(m0[k]);\n    }\n  }\n  return m;\n}\n\nexport function _foldM(bind) {\n  return function (f) {\n    return function (mz) {\n      return function (m) {\n        var acc = mz;\n        function g(k) {\n          return function (z) {\n            return f(z)(k)(m[k]);\n          };\n        }\n        for (var k in m) {\n          if (hasOwnProperty.call(m, k)) {\n            acc = bind(acc)(g(k));\n          }\n        }\n        return acc;\n      };\n    };\n  };\n}\n\nexport function _foldSCObject(m, z, f, fromMaybe) {\n  var acc = z;\n  for (var k in m) {\n    if (hasOwnProperty.call(m, k)) {\n      var maybeR = f(acc)(k)(m[k]);\n      var r = fromMaybe(null)(maybeR);\n      if (r === null) return acc;\n      else acc = r;\n    }\n  }\n  return acc;\n}\n\nexport function all(f) {\n  return function (m) {\n    for (var k in m) {\n      if (hasOwnProperty.call(m, k) && !f(k)(m[k])) return false;\n    }\n    return true;\n  };\n}\n\nexport function size(m) {\n  var s = 0;\n  for (var k in m) {\n    if (hasOwnProperty.call(m, k)) {\n      ++s;\n    }\n  }\n  return s;\n}\n\nexport function _lookup(no, yes, k, m) {\n  return k in m ? yes(m[k]) : no;\n}\n\nexport function _lookupST(no, yes, k, m) {\n  return function () {\n    return k in m ? yes(m[k]) : no;\n  };\n}\n\nexport function toArrayWithKey(f) {\n  return function (m) {\n    var r = [];\n    for (var k in m) {\n      if (hasOwnProperty.call(m, k)) {\n        r.push(f(k)(m[k]));\n      }\n    }\n    return r;\n  };\n}\n\nexport const keys = Object.keys || toArrayWithKey(function (k) {\n  return function () { return k; };\n});\n", "module Deku.Internal.Ancestry\n  ( root\n  , element\n  , dyn\n  , portal\n  , fixed\n  , toStringRepresentationInDOM\n  , unsafeFakeAncestry\n  , hasElementParent\n  , unsafeCollectLineage\n  , reconstructAncestry\n  , Ancestry\n  , DekuAncestry(..)\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Except (except)\nimport Data.Either (Either(..), either)\nimport Data.List.NonEmpty (singleton)\nimport Data.Maybe (Maybe(..))\nimport Data.String as String\nimport Foreign (ForeignError(..))\nimport Yoga.JSON as Yoga\n\n-- Fixed and Element track total\ndata DekuAncestry\n  = Element Int DekuAncestry\n  | Dyn Int DekuAncestry\n  | Portal Int DekuAncestry\n  | Fixed Int DekuAncestry\n  | Root\n\nnewtype AncestryHelperType = AncestryHelperType { t :: String }\nnewtype AncestryHelperIA = AncestryHelperIA { i :: Int, a :: DekuAncestry }\n\nderive newtype instance Yoga.ReadForeign AncestryHelperType\nderive newtype instance Yoga.WriteForeign AncestryHelperType\nderive newtype instance Yoga.ReadForeign AncestryHelperIA\nderive newtype instance Yoga.WriteForeign AncestryHelperIA\n\ninstance Yoga.ReadForeign DekuAncestry where\n  readImpl x = do\n    AncestryHelperType { t } <- Yoga.readImpl x\n    case t of\n      \"Element\" -> do\n        AncestryHelperIA { i, a } <- Yoga.readImpl x\n        pure $ Element i a\n      \"Dyn\" -> do\n        AncestryHelperIA { i, a } <- Yoga.readImpl x\n        pure $ Dyn i a\n      \"Portal\" -> do\n        AncestryHelperIA { i, a } <- Yoga.readImpl x\n        pure $ Portal i a\n      \"Fixed\" -> do\n        AncestryHelperIA { i, a } <- Yoga.readImpl x\n        pure $ Fixed i a\n      \"Root\" -> pure Root\n      _ -> except $ Left\n        (singleton $ ForeignError (\"Unknown DekuAncestry type: \" <> t))\n\ninstance Yoga.WriteForeign DekuAncestry where\n  writeImpl = case _ of\n    Element i a -> Yoga.writeImpl { i, a, t: \"Element\" }\n    Dyn i a -> Yoga.writeImpl { i, a, t: \"Dyn\" }\n    Portal i a -> Yoga.writeImpl { i, a, t: \"Portal\" }\n    Fixed i a -> Yoga.writeImpl { i, a, t: \"Fixed\" }\n    Root -> Yoga.writeImpl { t: \"Root\" }\n\ninstance Show DekuAncestry where\n  show (Element i a) = \"Element \" <> show i <> \" \" <> show a\n  show (Dyn i a) = \"Dyn \" <> show i <> \" \" <> show a\n  show (Portal i a) = \"Portal \" <> show i <> \" \" <> show a\n  show (Fixed i a) = \"Fixed \" <> show i <> \" \" <> show a\n  show Root = \"Root\"\n\nderive instance Eq DekuAncestry\nderive instance Ord DekuAncestry\n\ndata Ancestry\n  = RealAncestry\n      { rep :: String, lineage :: DekuAncestry, hasElementParent :: Boolean }\n  | FakeAncestry { rep :: String }\n\ninstance Yoga.ReadForeign Ancestry where\n  readImpl = map (either RealAncestry FakeAncestry) <<< Yoga.readImpl\n\ninstance Yoga.WriteForeign Ancestry where\n  writeImpl = toEither >>> Yoga.writeImpl\n    where\n    toEither (RealAncestry a) = Left a\n    toEither (FakeAncestry a) = Right a\n\ninstance Eq Ancestry where\n  eq (RealAncestry a) (RealAncestry b) = a.rep == b.rep\n  eq (FakeAncestry a) (FakeAncestry b) = a.rep == b.rep\n  eq (RealAncestry a) (FakeAncestry b) = a.rep == b.rep\n  eq (FakeAncestry a) (RealAncestry b) = a.rep == b.rep\n\ninstance Ord Ancestry where\n  compare (RealAncestry a) (RealAncestry b) = compare a.rep b.rep\n  compare (FakeAncestry a) (FakeAncestry b) = compare a.rep b.rep\n  compare (RealAncestry a) (FakeAncestry b) = compare a.rep b.rep\n  compare (FakeAncestry a) (RealAncestry b) = compare a.rep b.rep\n\ninstance Show Ancestry where\n  show (RealAncestry a) = \"RealAncestry \" <> show a\n  show (FakeAncestry a) = \"FakeAncestry \" <> show a\n\nhasElementParent :: Ancestry -> Boolean\nhasElementParent (RealAncestry a) = a.hasElementParent\n-- todo: this is not correct, as a dyn would cancel this\n-- not currently used, but fix it eventually\nhasElementParent (FakeAncestry { rep }) = String.contains (String.Pattern \"e\")\n  rep\n\nroot :: Ancestry\nroot = RealAncestry { rep: \"\", lineage: Root, hasElementParent: false }\n\nelement :: Int -> Ancestry -> Ancestry\nelement i (RealAncestry a) = RealAncestry\n  { rep: a.rep <> \"e\" <> show i\n  , lineage: Element i a.lineage\n  , hasElementParent: true\n  }\nelement i (FakeAncestry a) = FakeAncestry\n  { rep: a.rep <> \"e\" <> show i }\n\ndyn :: Int -> Ancestry -> Ancestry\ndyn i (RealAncestry a) = RealAncestry\n  { rep: a.rep <> \"d\" <> show i\n  , lineage: Dyn i a.lineage\n  , hasElementParent: false\n  }\ndyn i (FakeAncestry a) = FakeAncestry\n  { rep: a.rep <> \"d\" <> show i }\n\nportal :: Int -> Ancestry -> Ancestry\nportal i (RealAncestry a) = RealAncestry\n  { rep: a.rep <> \"p\" <> show i\n  , lineage: Portal i a.lineage\n  , hasElementParent: a.hasElementParent\n  }\nportal i (FakeAncestry a) = FakeAncestry\n  { rep: a.rep <> \"p\" <> show i }\n\nfixed :: Int -> Ancestry -> Ancestry\nfixed i (RealAncestry a) = RealAncestry\n  { rep: a.rep <> \"f\" <> show i\n  , lineage: Fixed i a.lineage\n  , hasElementParent: a.hasElementParent\n  }\nfixed i (FakeAncestry a) = FakeAncestry\n  { rep: a.rep <> \"f\" <> show i }\n\ntoStringRepresentationInDOM :: Ancestry -> String\ntoStringRepresentationInDOM (RealAncestry { rep }) = rep\ntoStringRepresentationInDOM (FakeAncestry { rep }) = rep\n\nunsafeFakeAncestry :: String -> Ancestry\nunsafeFakeAncestry rep = FakeAncestry { rep }\n\nunsafeCollectLineage :: Ancestry -> Maybe DekuAncestry\nunsafeCollectLineage (RealAncestry { lineage }) = Just lineage\nunsafeCollectLineage (FakeAncestry _) = Nothing\n\nreconstructAncestry :: DekuAncestry -> Ancestry\nreconstructAncestry (Element i a) = element i $ reconstructAncestry a\nreconstructAncestry (Dyn i a) = dyn i $ reconstructAncestry a\nreconstructAncestry (Portal i a) = portal i $ reconstructAncestry a\nreconstructAncestry (Fixed i a) = fixed i $ reconstructAncestry a\nreconstructAncestry Root = root\n", "module Deku.Internal.Entities where\n\nimport Unsafe.Coerce (unsafeCoerce)\n\ndata DekuElement\n\ntoDekuElement :: forall @a. a -> DekuElement\ntoDekuElement = unsafeCoerce\n\nfromDekuElement :: forall @a. DekuElement -> a\nfromDekuElement = unsafeCoerce\n\ndata DekuText\n\ntoDekuText :: forall @a. a -> DekuText\ntoDekuText = unsafeCoerce\n\nfromDekuText :: forall @a. DekuText -> a\nfromDekuText = unsafeCoerce\n\ndata DekuEvent\n\ntoDekuEvent :: forall @a. a -> DekuEvent\ntoDekuEvent = unsafeCoerce\n\nfromDekuEvent :: forall @a. DekuEvent -> a\nfromDekuEvent = unsafeCoerce\n\nnewtype DekuChild = DekuChild DekuElement\nnewtype DekuParent = DekuParent DekuElement", "export const objHack = (tag) => () => {\n  return {\n    r: false, // isRunning\n    q: [],    // queue\n    m: [{}],  // subscriptions\n    tag       // dubug tag\n  };\n};\n\nexport const insertObjHack = (k, v, o) => {\n  o.m[o.m.length - 1][k] = v;\n};\n\nexport const deleteObjHack = (k, o) => {\n  for (const m of o.m) {\n    if (delete m[k]) {\n      return true;\n    }\n  }\n  return false;\n};\n\nconst run = (o, M, f, i) => {\n  o.m.push({});\n  for (const kv of Object.entries(o.m[i])) {\n    const k = kv[0];\n    const v = kv[1];\n    f(v);\n    if (Object.keys(o.m[i + 1]).length) run(o, M, f, i + 1);\n    o.m[i + 1] = {};\n    o.m.length = i + 1 + 1;\n    M[k] = v;\n  }\n};\nexport const fastForeachOhE = (o, ff) => {\n  let f = ff;\n  while (true) {\n    if (o.r) {\n      o.q.push(f);\n      return;\n    }\n    o.r = true;\n    const M = {}; // new subscription object\n    run(o, M, f, 0);\n    o.m.length = 0; // make empty\n    o.m.push(M);\n    o.r = false;\n    f = o.q.shift();\n    if (f == undefined) {\n      break;\n    }\n  }\n};\n", "module Data.Filterable\n  ( class Filterable\n  , partitionMap\n  , partition\n  , filterMap\n  , filter\n  , eitherBool\n  , partitionDefault\n  , partitionDefaultFilter\n  , partitionDefaultFilterMap\n  , partitionMapDefault\n  , maybeBool\n  , filterDefault\n  , filterDefaultPartition\n  , filterDefaultPartitionMap\n  , filterMapDefault\n  , cleared\n  , module Data.Compactable\n  ) where\n\nimport Control.Bind ((=<<))\nimport Control.Category ((<<<))\nimport Data.Array (partition, mapMaybe, filter) as Array\nimport Data.Compactable (class Compactable, compact, separate)\nimport Data.Either (Either(..))\nimport Data.Foldable (foldl, foldr)\nimport Data.Functor (class Functor, map)\nimport Data.HeytingAlgebra (not)\nimport Data.List (List(..), filter, mapMaybe) as List\nimport Data.Map (Map, empty, insert, alter, toUnfoldable) as Map\nimport Data.Maybe (Maybe(..))\nimport Data.Monoid (class Monoid, mempty)\nimport Data.Semigroup ((<>))\nimport Data.Tuple (Tuple(..))\nimport Prelude (const, class Ord)\n\n-- | `Filterable` represents data structures which can be _partitioned_/_filtered_.\n-- |\n-- | - `partitionMap` - partition a data structure based on an either predicate.\n-- | - `partition` - partition a data structure based on boolean predicate.\n-- | - `filterMap` - map over a data structure and filter based on a maybe.\n-- | - `filter` - filter a data structure based on a boolean.\n-- |\n-- | Laws:\n-- | - Functor Relation: `filterMap identity \u2261 compact`\n-- | - Functor Identity: `filterMap Just \u2261 identity`\n-- | - Kleisli Composition: `filterMap (l <=< r) \u2261 filterMap l <<< filterMap r`\n-- |\n-- | - `filter \u2261 filterMap <<< maybeBool`\n-- | - `filterMap p \u2261 filter (isJust <<< p)`\n-- |\n-- | - Functor Relation: `partitionMap identity \u2261 separate`\n-- | - Functor Identity 1: `_.right <<< partitionMap Right \u2261 identity`\n-- | - Functor Identity 2: `_.left <<< partitionMap Left \u2261 identity`\n-- |\n-- | - `f <<< partition \u2261 partitionMap <<< eitherBool` where `f = \\{ no, yes } -> { left: no, right: yes }`\n-- | - `f <<< partitionMap p \u2261 partition (isRight <<< p)` where `f = \\{ left, right } -> { no: left, yes: right}`\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `partitionDefault`\n-- | - `partitionDefaultFilter`\n-- | - `partitionDefaultFilterMap`\n-- | - `partitionMapDefault`\n-- | - `filterDefault`\n-- | - `filterDefaultPartition`\n-- | - `filterDefaultPartitionMap`\n-- | - `filterMapDefault`\nclass (Compactable f, Functor f) <= Filterable f where\n  partitionMap :: forall a l r.\n    (a -> Either l r) -> f a -> { left :: f l, right :: f r }\n\n  partition :: forall a.\n    (a -> Boolean) -> f a -> { no :: f a, yes :: f a }\n\n  filterMap :: forall a b.\n    (a -> Maybe b) -> f a -> f b\n\n  filter :: forall a.\n    (a -> Boolean) -> f a -> f a\n\n-- | Upgrade a boolean-style predicate to an either-style predicate mapping.\neitherBool :: forall a.\n  (a -> Boolean) -> a -> Either a a\neitherBool p x = if p x then Right x else Left x\n\n-- | Upgrade a boolean-style predicate to a maybe-style predicate mapping.\nmaybeBool :: forall a.\n  (a -> Boolean) -> a -> Maybe a\nmaybeBool p x = if p x then Just x else Nothing\n\n-- | A default implementation of `partitionMap` using `separate`. Note that this is\n-- | almost certainly going to be suboptimal compared to direct implementations.\npartitionMapDefault :: forall f a l r. Filterable f =>\n  (a -> Either l r) -> f a -> { left :: f l, right :: f r }\npartitionMapDefault p = separate <<< map p\n\n-- | A default implementation of `partition` using `partitionMap`.\npartitionDefault :: forall f a. Filterable f =>\n  (a -> Boolean) -> f a -> { no :: f a, yes :: f a }\npartitionDefault p xs =\n  let o = partitionMap (eitherBool p) xs\n  in {no: o.left, yes: o.right}\n\n-- | A default implementation of `partition` using `filter`. Note that this is\n-- | almost certainly going to be suboptimal compared to direct implementations.\npartitionDefaultFilter :: forall f a. Filterable f =>\n  (a -> Boolean) -> f a -> { no :: f a, yes :: f a }\npartitionDefaultFilter p xs = { yes: filter p xs, no: filter (not p) xs }\n\n-- | A default implementation of `filterMap` using `separate`. Note that this is\n-- | almost certainly going to be suboptimal compared to direct implementations.\nfilterMapDefault :: forall f a b. Filterable f =>\n  (a -> Maybe b) -> f a -> f b\nfilterMapDefault p = compact <<< map p\n\n-- | A default implementation of `partition` using `filterMap`. Note that this\n-- | is almost certainly going to be suboptimal compared to direct\n-- | implementations.\npartitionDefaultFilterMap :: forall f a. Filterable f =>\n  (a -> Boolean) -> f a -> { no :: f a, yes :: f a }\npartitionDefaultFilterMap p xs =\n  { yes: filterMap (maybeBool p) xs\n  , no: filterMap (maybeBool (not p)) xs\n  }\n\n-- | A default implementation of `filter` using `filterMap`.\nfilterDefault :: forall f a. Filterable f =>\n  (a -> Boolean) -> f a -> f a\nfilterDefault = filterMap <<< maybeBool\n\n-- | A default implementation of `filter` using `partition`.\nfilterDefaultPartition :: forall f a. Filterable f =>\n  (a -> Boolean) -> f a -> f a\nfilterDefaultPartition p xs = (partition p xs).yes\n\n-- | A default implementation of `filter` using `partitionMap`.\nfilterDefaultPartitionMap :: forall f a. Filterable f =>\n  (a -> Boolean) -> f a -> f a\nfilterDefaultPartitionMap p xs = (partitionMap (eitherBool p) xs).right\n\n-- | Filter out all values.\ncleared :: forall f a b. Filterable f =>\n  f a -> f b\ncleared = filterMap (const Nothing)\n\ninstance filterableArray :: Filterable Array where\n  partitionMap p = foldl go {left: [], right: []} where\n    go acc x = case p x of\n      Left l -> acc { left = acc.left <> [l] }\n      Right r -> acc { right = acc.right <> [r] }\n\n  partition = Array.partition\n\n  filterMap = Array.mapMaybe\n\n  filter = Array.filter\n\ninstance filterableMaybe :: Filterable Maybe where\n  partitionMap _ Nothing = { left: Nothing, right: Nothing }\n  partitionMap p (Just x) = case p x of\n    Left a -> { left: Just a, right: Nothing }\n    Right b -> { left: Nothing, right: Just b }\n\n  partition p = partitionDefault p\n\n  filterMap = (=<<)\n\n  filter p = filterDefault p\n\ninstance filterableEither :: Monoid m => Filterable (Either m) where\n  partitionMap _ (Left x) = { left: Left x, right: Left x }\n  partitionMap p (Right x) = case p x of\n    Left a -> { left: Right a, right: Left mempty }\n    Right b -> { left: Left mempty, right: Right b }\n\n  partition p = partitionDefault p\n\n  filterMap _ (Left l) = Left l\n  filterMap p (Right r) = case p r of\n    Nothing -> Left mempty\n    Just x -> Right x\n\n  filter p = filterDefault p\n\ninstance filterableList :: Filterable List.List where\n  -- partitionMap :: forall a l r. (a -> Either l r) -> List a -> { left :: List l, right :: List r }\n  partitionMap p xs = foldr select { left: List.Nil, right: List.Nil } xs\n    where\n        select x { left, right } = case p x of\n                                     Left l -> { left: List.Cons l left, right }\n                                     Right r -> { left, right: List.Cons r right }\n\n  -- partition :: forall a. (a -> Boolean) -> List a -> { no :: List a, yes :: List a }\n  partition p xs = foldr select { no: List.Nil, yes: List.Nil } xs\n    where\n        -- select :: (a -> Boolean) -> a -> { no :: List a, yes :: List a } -> { no :: List a, yes :: List a }\n        select x { no, yes } = if p x\n                                 then { no, yes: List.Cons x yes }\n                                 else { no: List.Cons x no, yes }\n\n  -- filterMap :: forall a b. (a -> Maybe b) -> List a -> List b\n  filterMap p = List.mapMaybe p\n\n  -- filter :: forall a. (a -> Boolean) -> List a -> List a\n  filter = List.filter\n\ninstance filterableMap :: Ord k => Filterable (Map.Map k) where\n  partitionMap p xs =\n    foldr select { left: Map.empty, right: Map.empty } (toList xs)\n    where\n      toList :: forall v. Map.Map k v -> List.List (Tuple k v)\n      toList = Map.toUnfoldable\n\n      select (Tuple k x) { left, right } = case p x of\n        Left l -> { left: Map.insert k l left, right }\n        Right r -> { left, right: Map.insert k r right }\n\n  partition p = partitionDefault p\n\n  filterMap p xs =\n    foldr select Map.empty (toList xs)\n    where\n      toList :: forall v. Map.Map k v -> List.List (Tuple k v)\n      toList = Map.toUnfoldable\n\n      select (Tuple k x) m = Map.alter (const (p x)) k m\n\n  filter p = filterDefault p\n", "module FRP.Event.Class\n  ( (*|>)\n  , (<**>)\n  , (<**|>)\n  , (<*|>)\n  , (<|*)\n  , (<|**>)\n  , (<|*>)\n  , applyOp\n  , class IsEvent\n  , count\n  , fix\n  , fold\n  , folded\n  , gate\n  , gateBy\n  , keepLatest\n  , mapAccum\n  , module Data.Filterable\n  , once\n  , sampleOnLeft\n  , sampleOnLeftOp\n  , sampleOnLeft_\n  , sampleOnRight\n  , sampleOnRightOp\n  , sampleOnRight_\n  , withLast\n  ) where\n\nimport Prelude\n\nimport Control.Alternative (class Alt, class Plus, (<|>))\nimport Data.Compactable (compact)\nimport Data.Filterable (class Filterable, filterMap)\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Tuple (Tuple(..), snd)\n\n-- | Functions which an `Event` type should implement:\n-- |\n-- | - `once`: emits an event once\n-- | - `keepLatest` flattens a nested event, reporting values only from the\n-- | most recent inner event.\n-- | - `sampleOnRight`: samples an event at the times when a second event fires.\n-- | - `fix`: compute a fixed point, by feeding output events back in as\n-- | inputs.\n-- |\n-- | ```\n-- | push channel event1:          1  2                   3       4\n-- | push channel event2:                 +100    +200                     +300    +400\n-- | sampleOnLeft event1 event2:   _  _   _       _       203     204      _       _\n-- | sampleOnRight event1 event2:  _  _   102     202     _       _        304     404\n-- | apply event2 event1:          _  _   102     202     203     204      304     404\n-- | ```\nclass (Plus event, Alt event, Filterable event) <= IsEvent event where\n  keepLatest :: forall a. event (event a) -> event a\n  once :: event ~> event\n  sampleOnRight :: forall a b. event a -> event (a -> b) -> event b\n  sampleOnLeft :: forall a b. event a -> event (a -> b) -> event b\n  fix :: forall i. (event i -> event i) -> event i\n\ninfixl 4 sampleOnRight as <|**>\ninfixl 4 sampleOnLeft as <**|>\n\nsampleOnRightOp :: forall event a b. IsEvent event => event (a -> b) -> event a -> event b\nsampleOnRightOp ef ea = sampleOnRight ef ((#) <$> ea)\n\ninfixl 4 sampleOnRightOp as <|*>\n\nsampleOnLeftOp :: forall event a b. IsEvent event => event (a -> b) -> event a -> event b\nsampleOnLeftOp ef ea = sampleOnLeft ef ((#) <$> ea)\n\ninfixl 4 sampleOnLeftOp as <*|>\n\napplyOp :: forall event a b. Applicative event => event a -> event (a -> b) -> event b\napplyOp ea ef = apply ((#) <$> ea) ef\n\ninfixl 4 applyOp as <**>\n\n-- | Count the number of events received.\ncount :: forall event a. IsEvent event => event a -> event Int\ncount = fold (\\n _ -> n + 1) 0\n\n-- | Combine subsequent events using a `Monoid`.\nfolded :: forall event a. IsEvent event => Monoid a => event a -> event a\nfolded = fold append mempty\n\n-- | Compute differences between successive event values.\nwithLast :: forall event a. IsEvent event => event a -> event { now :: a, last :: Maybe a }\nwithLast e = filterMap identity (fold step Nothing e)\n  where\n  step Nothing a = Just { now: a, last: Nothing }\n  step (Just { now: b }) a = Just { now: a, last: Just b }\n\n-- | Map over an event with an accumulator.\n-- |\n-- | For example, to keep the index of the current event:\n-- |\n-- | ```purescript\n-- | mapAccum (\\x i -> Tuple (i + 1) (Tuple x i)) 0\n-- | ```\nmapAccum :: forall event a b c. IsEvent event => (a -> b -> Tuple a c) -> a -> event b -> event c\nmapAccum f acc xs = filterMap snd\n  $ fold (\\(Tuple a _) b -> pure <$> f a b) (Tuple acc Nothing) xs\n\n-- | Create an `Event` which samples the latest values from the first event\n-- | at the times when the second event fires, ignoring the values produced by\n-- | the second event.\nsampleOnRight_ :: forall event a b. IsEvent event => event a -> event b -> event a\nsampleOnRight_ a b = sampleOnRight a (const identity <$> b)\n\ninfixl 4 sampleOnRight_ as <|*\n\nsampleOnLeft_ :: forall event a b. IsEvent event => event a -> event b -> event b\nsampleOnLeft_ a b = sampleOnLeft a (const <$> b)\n\ninfixl 4 sampleOnLeft_ as *|>\n\n-- | Sample the events that are fired while a boolean event is true. Note that,\n-- | until the boolean event fires, it will be assumed to be `false`, and events\n-- | will be blocked.\ngate :: forall a event. IsEvent event => event Boolean -> event a -> event a\ngate = gateBy (\\x _ -> fromMaybe false x)\n\n-- | Generalised form of `gateBy`, allowing for any predicate between the two\n-- | events. The predicate will not be evaluated until a value from the first event is received.\ngateBy\n  :: forall a b event\n   . IsEvent event\n  => (Maybe a -> b -> Boolean)\n  -> event a\n  -> event b\n  -> event b\ngateBy f sampled sampler = compact $\n  (\\p x -> if f p x then Just x else Nothing)\n    <$> ((once sampler $> Nothing) <|> Just <$> sampled)\n    <|*> sampler\n\n-- | Fold over values received from some `Event`, creating a new `Event`.\nfold :: forall event a b. IsEvent event => (b -> a -> b) -> b -> event a -> event b\nfold f b e = fix \\i -> sampleOnRight (i <|> (once e $> b)) ((flip f) <$> e :: event (b -> b))\n\ndata OnceTracker a = Initial | Latch a | Stop\n", "-- @inline export fastForeachThunkST always\n-- @inline export fastForeachThunkE always\n-- @inline export fastForeachST always\n-- @inline export fastForeachE always\n\nmodule FRP.Event\n  ( Event\n  , EventIO\n  , EventIOO\n  , EventfulProgram\n  , ProgramfulEvent\n  , PureEventIO\n  , PureEventIOO\n  , TupleArrayInSt\n  , create\n  , createPure\n  , createPureTagged\n  , createTagged\n  , fastForeachE\n  , fastForeachST\n  , fastForeachThunkE\n  , fastForeachThunkST\n  , foldArr\n  , foldObj\n  , justMany\n  , justManyM\n  , justNone\n  , justOne\n  , justOneM\n  , mailbox\n  , mailbox'\n  , mailboxPure\n  , mailboxPure'\n  , mailboxPureS\n  , mailboxPureS'\n  , mailboxS\n  , mailboxS'\n  , makeEvent\n  , makeEventE\n  , makeEventFromO\n  , makeEventFrom\n  , memoize\n  , merge\n  , mergeMap\n  , module Class\n  , Subscriber(..)\n  , subscribe\n  , subscribeO\n  , until\n  ) where\n\nimport Prelude\n\nimport Control.Alternative (class Alt, class Plus)\nimport Control.Apply (lift2)\nimport Control.Monad.Free (Free, liftF, resume)\nimport Control.Monad.Rec.Class (Step(..), tailRecM)\nimport Control.Monad.ST (Region, ST)\nimport Control.Monad.ST as ST\nimport Control.Monad.ST.Class (liftST)\nimport Control.Monad.ST.Global (Global)\nimport Control.Monad.ST.Internal as STRef\nimport Control.Monad.ST.Uncurried (STFn1, STFn2, STFn3, mkSTFn1, mkSTFn2, runSTFn1, runSTFn2, runSTFn3)\nimport Data.Array.ST (STArray)\nimport Data.Array.ST as STArray\nimport Data.Compactable (class Compactable)\nimport Data.Either (Either(..), either, hush)\nimport Data.Filterable as Filterable\nimport Data.Foldable (for_)\nimport Data.Functor.Compose (Compose(..))\nimport Data.FunctorWithIndex (class FunctorWithIndex)\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Data.Tuple (Tuple(..))\nimport Effect (Effect)\nimport Effect.Uncurried (EffectFn1, EffectFn2, mkEffectFn1, mkEffectFn2, runEffectFn1, runEffectFn2)\nimport FRP.Event.Class (class Filterable, class IsEvent, count, filterMap, fix, fold, folded, gate, gateBy, keepLatest, mapAccum, sampleOnRight, sampleOnRight_, withLast) as Class\nimport Foreign.Object.ST (STObject)\nimport Foreign.Object.ST as STObject\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | An `Event` represents a collection of discrete occurrences with associated\n-- | times. Conceptually, an `Event` is a (possibly-infinite) list of values-and-times:\n-- |\n-- | ```purescript\n-- | type Event a = List { value :: a, time :: Time }\n-- | ```\n-- |\n-- | Events are created from real events like timers or mouse clicks, and then\n-- | combined using the various functions and instances provided in this module.\n-- |\n-- | Events are consumed by providing a callback using the `subscribe` function.\n-- |\n-- | Without optimizations it reads as\n-- |\n-- | ```purescript\n-- | type Event a = (a -> Effect Unit) -> ST Global (ST Global Unit))\n-- | ```\nnewtype Event a = Event (STFn1 (EffectFn1 a Unit) Global (ST Global Unit))\n\ninstance functorEvent :: Functor Event where\n  map f (Event e) = Event (mkSTFn1 (\\effectfulCallback -> runSTFn1 e (mkEffectFn1 (\\a -> runEffectFn1 effectfulCallback (f a)))))\n\ninstance functorWithIndexEvent :: FunctorWithIndex Int Event where\n  mapWithIndex f e = Class.mapAccum (\\a b -> Tuple (a + 1) (f a b)) 0 e\n\ntype TupleArrayInSt a = Compose (ST Global) (Tuple (Array a))\ntype EventfulProgram a = Free (TupleArrayInSt a) Unit\ntype ProgramfulEvent b = forall a. Free (TupleArrayInSt a) b\n\ninstance compactableEvent :: Compactable Event where\n  compact = filter identity\n  separate xs =\n    { left:\n        filter\n          ( case _ of\n              Left x -> Just x\n              Right _ -> Nothing\n          )\n          xs\n    , right:\n        filter\n          ( case _ of\n              Right x -> Just x\n              Left _ -> Nothing\n          )\n          xs\n    }\n\nfilter' :: forall a. (a \u2192 Boolean) \u2192 Event a \u2192 Event a\nfilter' f =\n  filter\n    ( \\a -> case f a of\n        true -> Just a\n        false -> Nothing\n    )\n\ninstance filterableEvent :: Filterable.Filterable Event where\n  filter = filter'\n  filterMap = filter\n  partition p xs = { yes: filter' p xs, no: filter' (not <<< p) xs }\n  partitionMap f xs =\n    { left: Filterable.filterMap (either Just (const Nothing) <<< f) xs\n    , right: Filterable.filterMap (hush <<< f) xs\n    }\n\n-- | IF duplicated THEN will just repeat\n-- |\n-- | ```\n-- | push to `event1`           | 1       2\n-- | get in `event1 <|> event1` | 1   1   2   2\n-- | ```\ninstance altEvent :: Alt Event where\n  alt (Event f) (Event g) =\n    Event $ mkSTFn1 \\effectfulCallback -> ado\n      c1 <- runSTFn1 f effectfulCallback\n      c2 <- runSTFn1 g effectfulCallback\n      in\n        do\n          c1\n          c2\n\n-- | Merge together several events. This has the same functionality\n-- | as `oneOf`, but it is faster and less prone to stack explosions.\nmerge :: forall a. Array (Event a) \u2192 Event a\nmerge f = Event $ mkSTFn1 \\effectfulCallback -> do\n  a <- STArray.new\n  runSTFn2 fastForeachST f $ mkSTFn1 \\(Event i) -> do\n    u <- runSTFn1 i effectfulCallback\n    void $ liftST $ STArray.push u a\n  pure do\n    o <- liftST (STArray.freeze a)\n    runSTFn1 fastForeachThunkST o\n\n-- | Merge together several events and map on the event. This has the same functionality\n-- | as `oneOf`, but it is faster and less prone to stack explosions.\nmergeMap :: forall a b. (a -> Event b) -> Array a \u2192 Event b\nmergeMap f0 f = Event $ mkSTFn1 \\effectfulCallback -> do\n  a <- STArray.new\n  runSTFn2 fastForeachST f $ mkSTFn1 \\x -> do\n    let (Event i) = f0 x\n    u <- runSTFn1 i effectfulCallback\n    void $ liftST $ STArray.push u a\n  pure do\n    o <- liftST (STArray.freeze a)\n    runSTFn1 fastForeachThunkST o\n\ninstance plusEvent :: Plus Event where\n  empty = Event $ mkSTFn1 \\_ -> pure (pure unit)\n\ninstance applyEvent :: Apply Event where\n  apply a b = biSampleOn a ((#) <$> b)\n\ninstance eventIsEvent :: Class.IsEvent Event where\n  keepLatest = keepLatest\n  sampleOnRight = sampleOnRight\n  sampleOnLeft = sampleOnLeft\n  fix = fix\n  once = once\n\ninstance semigroupEvent :: (Semigroup a) => Semigroup (Event a) where\n  append = lift2 append\n\n-- | Emits an event only once\n-- |\n-- | ```\n-- | push to `event1`            | 1       2        3\n-- | get in `EClass.once event1` | 1       _        _\n-- | ```\n-- |\n-- | In combination with `alt` will give\n-- |\n-- | ```\n-- | push to `event1`                       |       2          4\n-- | push to `event2`                       | 1           3          5\n-- | get in `EClass.once event1 <|> event2` | 1     2     3    _     5\n-- | ```\n\nonce :: forall a. Event a -> Event a\nonce (Event e) =\n  Event $ mkSTFn1 \\effectfulCallback -> do\n    latest <- STRef.new Nothing\n    u <- STRef.new $ pure unit\n    c <-\n      runSTFn1 e $ mkEffectFn1 \\a -> do\n        o <- liftST $ STRef.read latest\n        case o of\n          Nothing -> do\n            void $ liftST $ STRef.write (Just a) latest\n            runEffectFn1 effectfulCallback a\n            liftST $ join (STRef.read u)\n          -- should not hit here\n          Just _ -> pure unit\n    void $ STRef.write c u\n    o <- liftST $ STRef.read latest\n    case o of\n      Just _ -> c\n      _ -> pure unit\n    pure do\n      c\n\n-- | Create an `Event` which only fires when a predicate holds.\nfilter :: forall a b. (a -> Maybe b) -> Event a -> Event b\nfilter p (Event e) =\n  Event\n    ( mkSTFn1 \\effectfulCallback ->\n        runSTFn1 e\n          ( mkEffectFn1 \\a -> case p a of\n              Just y -> runEffectFn1 effectfulCallback y\n              Nothing -> pure unit\n          )\n    )\n\nsampleOnLeft :: forall a b. Event a -> Event (a -> b) -> Event b\nsampleOnLeft (Event e1) (Event e2) =\n  Event $ mkSTFn1 \\effectfulCallback -> do\n    latest <- STRef.new Nothing\n    c1 <-\n      runSTFn1 e1 $ mkEffectFn1 \\a -> do\n        o <- liftST $ STRef.read latest\n        for_ o (\\f -> runEffectFn1 effectfulCallback (f a))\n    c2 <-\n      runSTFn1 e2 $ mkEffectFn1 \\f -> do\n        liftST $ void $ STRef.write (Just f) latest\n    pure do\n      c1\n      c2\n\n-- | Create an `Event` which samples the latest values from the first event\n-- | at the times when the second event fires.\nsampleOnRight :: forall a b. Event a -> Event (a -> b) -> Event b\nsampleOnRight (Event e1) (Event e2) =\n  Event $ mkSTFn1 \\effectfulCallback -> do\n    latest <- STRef.new Nothing\n    c1 <-\n      runSTFn1 e1 $ mkEffectFn1 \\a -> do\n        void $ liftST $ STRef.write (Just a) latest\n    c2 <-\n      runSTFn1 e2 $ mkEffectFn1 \\f -> do\n        o <- liftST $ STRef.read latest\n        for_ o (\\a -> runEffectFn1 effectfulCallback (f a))\n    pure do\n      c1\n      c2\n\nbiSampleOn :: forall a b. Event a -> Event (a -> b) -> Event b\nbiSampleOn (Event e1) (Event e2) =\n  Event $ mkSTFn1 \\effectfulCallback -> do\n    latest1 <- STRef.new Nothing\n    latest2 <- STRef.new Nothing\n    c1 <-\n      runSTFn1 e1 $ mkEffectFn1 \\a -> do\n        void $ liftST $ STRef.write (Just a) latest1\n        res <- liftST $ STRef.read latest2\n        for_ res (\\f -> runEffectFn1 effectfulCallback (f a))\n    c2 <-\n      runSTFn1 e2 $ mkEffectFn1 \\f -> do\n        void $ liftST $ STRef.write (Just f) latest2\n        res <- liftST $ STRef.read latest1\n        for_ res (\\a -> runEffectFn1 effectfulCallback (f a))\n    pure do\n      c1\n      c2\n\n-- | Flatten a nested `Event`, reporting values only from the most recent\n-- | inner `Event`.\nkeepLatest :: forall a. Event (Event a) -> Event a\nkeepLatest (Event e) =\n  Event $ mkSTFn1 \\effectfulCallback -> do\n    cancelInner <- STRef.new (pure unit)\n    cancelOuter <-\n      runSTFn1 e $ mkEffectFn1 \\(Event inner) -> liftST do\n        ci <- STRef.read cancelInner\n        ci\n        c <- runSTFn1 inner effectfulCallback\n        void $ STRef.write c cancelInner\n    pure do\n      ci <- STRef.read cancelInner\n      ci\n      cancelOuter\n\n-- | Compute a fixed point\n-- |\n-- | # Fix + Alt\n-- |\n-- | ```\n-- | push to `event1`                              | 1                   ...will never get to here\n-- | get in `fix (\\i -> i <|> event1)`             | 1 1 1 1...\n-- | get in `fix (\\i -> event1 <|> i)`             | 1 1 1 1...\n-- | get in `fix (\\i -> map ((+) 1) i <|> event1)` | 1 2 3 4...\n-- | ```\n-- |\n-- | ```\n-- | push to `event1`                          | 1                   ...will never get to here\n-- | get in `fix (\\i -> i <|> once event1)`    | 1 1 1 1...\n-- | get in `fix (\\i -> once event1 <|> i)`    | 1 1 1 1...\n-- | ```\n-- |\n-- | ```\n-- | push to `event1`                          | 1       2       3\n-- | get in `fix (\\i -> once (i <|>  event1))` | 1       _       _\n-- | get in `fix (\\i -> once (event1 <|>  i))` | 1       _       _\n-- | ```\n-- |\n-- | # Fix + sampleOnLeft and sampleOnRight and apply\n-- |\n-- | ```\n-- | push to `event1`                                          | 1          2\n-- | push to `sampler`                                         |     +100\n-- | get in `fix (\\i -> sampleOnLeft i sampler)`               | ...never outputs anything\n-- | get in `fix (\\i -> sampleOnLeft (i <|> event1) sampler)`  | _   _      102 202 302 ...\n-- | get in `fix (\\i -> sampleOnLeft (event1 <|> i) sampler)`  | _   _      102 202 302 ...\n-- | ```\n-- |\n-- | ```\n-- | push to `event1`                                          |       1   2                 3    4\n-- | push to `sampler`                                         | +100          +200   +300            +400   +500\n-- | get in `fix (\\i -> sampleOnRight i sampler)`              | ...never outputs anything\n-- | get in `fix (\\i -> sampleOnRight (i <|> event1) sampler)` | _     _   _   202    502    _    _   404    904\n-- | get in `fix (\\i -> sampleOnRight (event1 <|> i) sampler)` | _     _   _   202    502    _    _   404    904\n-- | ```\n-- |\n-- | ```\n-- | push to `event1`                                          |         1             ...will never get to here\n-- | push to `sampler`                                         | +100                  ...will never get to here\n-- | get in `fix (\\i -> flip apply i sampler)`                 | ...never outputs anything\n-- | get in `fix (\\i -> flip apply (i <|> event1) sampler)`    | _       101 201 301....\n-- | get in `fix (\\i -> flip apply (event1 <|> i) sampler)`    | _       101 201 301....\n-- | ```\nfix :: forall i. (Event i -> Event i) -> Event i\nfix f =\n  Event $ mkSTFn1 \\(effectfulCallback :: EffectFn1 i Unit) -> do\n    { event, push } <- create\n    let Event (eventModified :: STFn1 (EffectFn1 i Unit) Global (ST Global Unit)) = f event\n    let Event (eventOriginal :: STFn1 (EffectFn1 i Unit) Global (ST Global Unit)) = event\n    c2 <- runSTFn1 eventOriginal effectfulCallback\n    c1 <- runSTFn1 eventModified (mkEffectFn1 push)\n    pure do\n      c1\n      c2\n\n-- | Subscribe to an `Event` by providing a callback.\n-- |\n-- | `subscribe` returns a canceller function.\nsubscribe\n  :: forall a\n   . Event a\n  -> (a -> Effect Unit)\n  -> Effect (Effect Unit)\nsubscribe (Event e) effectfulCallback = liftST $ map liftST $ runSTFn1 e (mkEffectFn1 effectfulCallback)\n\n-- | Subscribe to an `Event` by providing a callback. (optimized)\n-- |\n-- | `subscribe` returns a canceller function.\nsubscribeO\n  :: forall a\n   . EffectFn2 (Event a) (EffectFn1 a Unit) (Effect Unit)\nsubscribeO = mkEffectFn2 \\(Event e) effectfulCallback -> liftST $ map liftST $ runSTFn1 e effectfulCallback\n\n-- TODO: is this method unsafe? @srghma couldn't implement example that shows it's unsafety\n-- subscribePure\n--   :: forall a\n--    . Event a\n--   -> (a -> ST Global Unit)\n--   -> ST Global (ST Global Unit)\n-- subscribePure (Event e) callback = runSTFn1 e (mkEffectFn1 $ \\a -> liftST $ callback a)\n\njustOne :: forall a. a -> EventfulProgram a\njustOne a = liftF (Compose (pure (Tuple [ a ] unit)))\n\njustOneM :: forall a. ST Global a -> EventfulProgram a\njustOneM a = liftF (Compose (a <#> \\a' -> Tuple [ a' ] unit))\n\njustMany :: Array ~> EventfulProgram\njustMany a = liftF (Compose (pure (Tuple a unit)))\n\njustManyM :: forall a. ST Global (Array a) -> EventfulProgram a\njustManyM a = liftF (Compose (a <#> \\a' -> Tuple a' unit))\n\njustNone :: ST Global ~> ProgramfulEvent\njustNone st = liftF (Compose (st <#> \\st' -> (Tuple [] st')))\n\n-- | Make an `Event` from a function which accepts a callback and returns an\n-- | unsubscription function.\n-- |\n-- | Note: you probably want to use `create` instead, unless you need explicit\n-- | control over unsubscription.\n\n-- | `Event a` - covariant position (matter)\n-- | `((forall b. Event b -> (b -> EventfulProgram a) -> ST Global (ST Global Unit)) -> ST Global (ST Global Unit))` - contravariant position (antimatter)\n-- | `(forall b. Event b -> (b -> EventfulProgram a) -> ST Global (ST Global Unit))` - covariant position (matter)\n-- | `Event b` - contravariant position (antimatter)\nmakeEvent\n  :: forall a\n   . ((forall b. Event b -> (b -> EventfulProgram a) -> ST Global (ST Global Unit)) -> ST Global (ST Global Unit))\n  -> Event a\nmakeEvent giveMe_eventb_btoEventfulProgram_iGive_StSt = Event $ mkSTFn1 \\effectfulCallback ->\n  giveMe_eventb_btoEventfulProgram_iGive_StSt \\(Event b_createEvent) bToEventfulProgram -> makeEventFromO b_createEvent bToEventfulProgram effectfulCallback\n\nmakeEventFromO\n  :: forall a b\n   . STFn1 (EffectFn1 a Unit) Global (ST Global Unit)\n  -> (a -> EventfulProgram b)\n  -> EffectFn1 b Unit\n  -> ST Global (ST Global Unit)\nmakeEventFromO event eventfulProgram effectfulCallback = do\n  closeEvent <- runSTFn1 event $ mkEffectFn1 \\a -> do\n    let\n      go\n        :: Free (TupleArrayInSt b) Unit\n        -> Effect (Step (Free (TupleArrayInSt b) Unit) Unit)\n      go = resume >>> case _ of\n        Right _unit -> pure $ Done unit\n        Left (Compose prog) -> do\n          Tuple value rest <- liftST prog\n          runEffectFn2 fastForeachE value effectfulCallback\n          pure $ Loop rest\n    tailRecM go (eventfulProgram a)\n  pure closeEvent\n\nmakeEventFrom\n  :: forall a b\n   . Event a\n  -> (a -> EventfulProgram b)\n  -> Event b\nmakeEventFrom (Event event) eventfulProgram = Event $ mkSTFn1 \\effectfulCallback -> makeEventFromO event eventfulProgram effectfulCallback\n\n-- This function makes a hot event (data is created outside of ST monad)\nmakeEventE :: forall a. ((a -> Effect Unit) -> Effect (Effect Unit)) -> Effect { event :: Event a, unsubscribe :: Effect Unit }\nmakeEventE e = do\n  { event, push } <- liftST create\n  unsubscribe <- e push\n  pure { event, unsubscribe }\n\nnewtype Subscriber = Subscriber (forall b. STFn2 (Event b) (STFn1 b Global Unit) Global (ST Global Unit))\n\ntype EventIO a =\n  { event :: Event a\n  , push :: a -> Effect Unit\n  }\n\n-- | Create an event and a function which supplies a value to that event.\ncreate :: forall a. ST Global (EventIO a)\ncreate = create_ \"\"\n\ncreateTagged :: forall a. String -> ST Global (EventIO a)\ncreateTagged = create_\n\ncreatePure :: forall a. ST Global (PureEventIO a)\ncreatePure = unsafeCoerce $ create_ \"\"\n\ncreatePureTagged :: forall a. String -> ST Global (PureEventIO a)\ncreatePureTagged = unsafeCoerce create_\n\ntype EventIOO i o = -- O for Optimized\n  { event :: Event o\n  , push :: EffectFn1 i Unit\n  }\n\nforeign import data ObjHack :: Region -> Type -> Type\n\ntype role ObjHack nominal representational\n\nforeign import objHack :: forall a r. String -> ST r (ObjHack r a)\nforeign import insertObjHack :: forall a r. STFn3 Int a (ObjHack r a) Global Unit\nforeign import deleteObjHack :: forall a r. STFn2 Int (ObjHack r a) Global Unit\n\n-- | Will make the `ST Global (...)` in\n-- | `type Event a = (a -> Effect Unit) -> ST Global (ST Global Unit))`\n-- | to be executed only once, no matter how many times `subscribe` was called\nmemoize :: forall a. Event a -> Effect { event :: Event a, unsubscribe :: Effect Unit }\nmemoize e = do\n  { event, push } <- liftST create\n  unsubscribe <- subscribe e push\n  pure { event, unsubscribe }\n\ncreate_\n  :: forall a\n   . String\n  -> ST Global (EventIO a)\ncreate_ tag = do\n  subscribers <- objHack tag\n  idx <- STRef.new 0\n  pure\n    { event:\n        Event $ mkSTFn1 \\effectfulCallback -> do\n          recordOfEffectfulCallbacks <- STRef.new effectfulCallback\n          ix <- STRef.read idx\n          runSTFn3 insertObjHack ix recordOfEffectfulCallbacks subscribers\n          void $ STRef.modify (_ + 1) idx\n          pure do\n            void $ STRef.write mempty recordOfEffectfulCallbacks\n            runSTFn2 deleteObjHack ix subscribers\n            pure unit\n    , push:\n        \\a -> do\n          runEffectFn2 fastForeachOhE subscribers $ mkEffectFn1 \\recordOfEffectfulCallbacks -> do\n            effectfulCallback <- liftST $ STRef.read recordOfEffectfulCallbacks\n            runEffectFn1 effectfulCallback a\n    }\n\ntype PureEventIO a =\n  { event :: Event a\n  , push :: a -> ST Global Unit\n  }\n\ntype PureEventIOO r a =\n  { event :: Event a\n  , push :: STFn1 a r Unit\n  }\n\nmailbox :: forall a b. Ord a => ST Global { push :: { address :: a, payload :: b } -> Effect Unit, event :: a -> Event b }\nmailbox = do\n  { push, event } <- mailbox'\n  pure\n    { push: \\ap -> runEffectFn1 push ap\n    , event\n    }\n\nmailboxPure :: forall a b. Ord a => ST Global { push :: { address :: a, payload :: b } -> ST Global Unit, event :: a -> Event b }\nmailboxPure = (unsafeCoerce :: (forall a b. Ord a => ST Global { push :: { address :: a, payload :: b } -> Effect Unit, event :: a -> Event b }) -> (Ord a => ST Global { push :: { address :: a, payload :: b } -> ST Global Unit, event :: a -> Event b })) mailbox\n\nmailboxPure' :: forall a b. Ord a => ST Global { push :: STFn1 { address :: a, payload :: b } Global Unit, event :: a -> Event b }\nmailboxPure' = (unsafeCoerce :: (Ord a => ST Global { push :: EffectFn1 { address :: a, payload :: b } Unit, event :: a -> Event b }) -> (Ord a => ST Global { push :: STFn1 { address :: a, payload :: b } Global Unit, event :: a -> Event b })) mailbox'\n\nmailbox' :: forall a b. Ord a => ST Global { push :: EffectFn1 { address :: a, payload :: b } Unit, event :: a -> Event b }\nmailbox' = do\n  r <- STRef.new Map.empty\n  idx <- STRef.new 0\n  pure\n    { event: \\a ->\n        Event $ mkSTFn1 \\effectfulCallback -> do\n          o <- liftST $ STRef.read r\n          subscribers <- case Map.lookup a o of\n            Nothing -> do\n              oh <- objHack \"\"\n              void $ STRef.modify (Map.insert a oh) r\n              pure oh\n            Just s -> pure s\n          recordOfEffectfulCallbacks <- STRef.new effectfulCallback\n          ix <- STRef.read idx\n          runSTFn3 insertObjHack ix recordOfEffectfulCallbacks subscribers\n          void $ STRef.modify (_ + 1) idx\n          pure do\n            void $ STRef.write mempty recordOfEffectfulCallbacks\n            runSTFn2 deleteObjHack ix subscribers\n            pure unit\n    , push: mkEffectFn1 \\{ address, payload } -> do\n        o <- liftST $ STRef.read r\n        case Map.lookup address o of\n          Nothing -> pure unit\n          Just subscribers -> runEffectFn2 fastForeachOhE subscribers $ mkEffectFn1 \\recordOfEffectfulCallbacks -> do\n            effectfulCallback <- liftST $ STRef.read recordOfEffectfulCallbacks\n            runEffectFn1 effectfulCallback payload\n        pure unit\n    }\n\nmailboxS :: forall b. ST Global { push :: { address :: String, payload :: b } -> Effect Unit, event :: String -> Event b }\nmailboxS = do\n  { push, event } <- mailboxS'\n  pure\n    { push: \\ap -> runEffectFn1 push ap\n    , event\n    }\n\nmailboxPureS :: forall b. ST Global { push :: { address :: String, payload :: b } -> ST Global Unit, event :: String -> Event b }\nmailboxPureS = (unsafeCoerce :: (forall b. ST Global { push :: { address :: String, payload :: b } -> Effect Unit, event :: String -> Event b }) -> (ST Global { push :: { address :: String, payload :: b } -> ST Global Unit, event :: String -> Event b })) mailbox\n\nmailboxPureS' :: forall b. ST Global { push :: STFn1 { address :: String, payload :: b } Global Unit, event :: String -> Event b }\nmailboxPureS' = (unsafeCoerce :: (ST Global { push :: EffectFn1 { address :: String, payload :: b } Unit, event :: String -> Event b }) -> (ST Global { push :: STFn1 { address :: String, payload :: b } Global Unit, event :: String -> Event b })) mailbox'\n\nmailboxS' :: forall b. ST Global { push :: EffectFn1 { address :: String, payload :: b } Unit, event :: String -> Event b }\nmailboxS' = do\n  r <- STObject.new\n  idx <- STRef.new 0\n  pure\n    { event: \\a ->\n        Event $ mkSTFn1 \\effectfulCallback -> do\n          o <- liftST $ STObject.peek a r\n          subscribers <- case o of\n            Nothing -> do\n              oh <- objHack \"\"\n              void $ STObject.poke a oh r\n              pure oh\n            Just s -> pure s\n          recordOfEffectfulCallbacks <- STRef.new effectfulCallback\n          ix <- STRef.read idx\n          runSTFn3 insertObjHack ix recordOfEffectfulCallbacks subscribers\n          void $ STRef.modify (_ + 1) idx\n          pure do\n            void $ STRef.write mempty recordOfEffectfulCallbacks\n            runSTFn2 deleteObjHack ix subscribers\n            pure unit\n    , push: mkEffectFn1 \\{ address, payload } -> do\n        o <- liftST $ STObject.peek address r\n        case o of\n          Nothing -> pure unit\n          Just subscribers -> runEffectFn2 fastForeachOhE subscribers $ mkEffectFn1 \\recordOfEffectfulCallbacks -> do\n            effectfulCallback <- liftST $ STRef.read recordOfEffectfulCallbacks\n            runEffectFn1 effectfulCallback payload\n        pure unit\n    }\n\nfastForeachThunkST :: forall r. STFn1 (Array (ST r Unit)) r Unit\nfastForeachThunkST = mkSTFn1 \\array -> ST.foreach array identity\n\nfastForeachThunkE :: EffectFn1 (Array (Effect Unit)) Unit\nfastForeachThunkE = unsafeCoerce fastForeachThunkST\n\n-- dont use!\n-- `fastForeachST = mkSTFn2 \\array fn -> ST.foreach array (runSTFn1 fn)`\n-- bacause it is compiled into!\n-- `const fastForeachST = (array, fn) => { const $0 = Control$dMonad$dST$dUncurried.runSTFn1(fn); for (const $1 of array) { $0($1)(); } };`\n--\n-- this is compiled into\n-- `const fastForeachST = (array, fn) => { for (const x of array) { fn(x); } };`\nfastForeachST :: forall a r. STFn2 (Array a) (STFn1 a r Unit) r Unit\nfastForeachST = mkSTFn2 \\array fn -> ST.foreach array \\x -> runSTFn1 fn x\n\nfastForeachE :: forall a. EffectFn2 (Array a) (EffectFn1 a Unit) Unit\nfastForeachE = unsafeCoerce fastForeachST\n\nforeign import fastForeachOhE :: forall a r. EffectFn2 (ObjHack r a) (EffectFn1 a Unit) Unit -- TODO: r looks ugly\n\nfastForeachOhST :: forall a r. STFn2 (ObjHack r a) (STFn1 a r Unit) r Unit -- TODO: r looks ugly\nfastForeachOhST = unsafeCoerce fastForeachOhE\n\n-- | A fast fold over an object\nfoldObj :: forall a b c. (forall r. STObject r b -> a -> ST r c) -> Event a -> Event c\nfoldObj f e = makeEvent \\s -> do\n  o <- STObject.new\n  let\n    go :: a -> EventfulProgram c\n    go a = do\n      justOneM (f o a)\n  c <- s e go\n  pure c\n\n-- | A fast fold over an array\nfoldArr :: forall a b c. (forall r. STArray r b -> a -> ST r c) -> Event a -> Event c\nfoldArr f e = makeEvent \\s -> do\n  o <- STArray.new\n  let\n    go :: a -> EventfulProgram c\n    go a = do\n      justOneM (f o a)\n  c <- s e go\n  pure c\n\nuntil :: \u2200 a. Event a -> Event Unit -> Event a\nuntil (Event value) stopE = Event $ mkSTFn1 \\effectfulCallback -> do\n  let Event stop = once stopE\n  unsubscribeValue <- runSTFn1 value $ mkEffectFn1 \\a -> do\n    runEffectFn1 effectfulCallback a\n  unsubscribeStop <- runSTFn1 stop $ mkEffectFn1 \\_ -> do\n    liftST unsubscribeValue\n  pure do\n    unsubscribeValue\n    unsubscribeStop\n", "module Data.Profunctor where\n\nimport Prelude\nimport Data.Newtype (class Newtype, wrap, unwrap)\n\n-- | A `Profunctor` is a `Functor` from the pair category `(Type^op, Type)`\n-- | to `Type`.\n-- |\n-- | In other words, a `Profunctor` is a type constructor of two type\n-- | arguments, which is contravariant in its first argument and covariant\n-- | in its second argument.\n-- |\n-- | The `dimap` function can be used to map functions over both arguments\n-- | simultaneously.\n-- |\n-- | A straightforward example of a profunctor is the function arrow `(->)`.\n-- |\n-- | Laws:\n-- |\n-- | - Identity: `dimap identity identity = identity`\n-- | - Composition: `dimap f1 g1 <<< dimap f2 g2 = dimap (f1 >>> f2) (g1 <<< g2)`\nclass Profunctor p where\n  dimap :: forall a b c d. (a -> b) -> (c -> d) -> p b c -> p a d\n\n-- | Map a function over the (contravariant) first type argument only.\nlcmap :: forall a b c p. Profunctor p => (a -> b) -> p b c -> p a c\nlcmap a2b = dimap a2b identity\n\n-- | Map a function over the (covariant) second type argument only.\nrmap :: forall a b c p. Profunctor p => (b -> c) -> p a b -> p a c\nrmap b2c = dimap identity b2c\n\n-- | Lift a pure function into any `Profunctor` which is also a `Category`.\narr :: forall a b p. Category p => Profunctor p => (a -> b) -> p a b\narr f = rmap f identity\n\nunwrapIso :: forall p t a. Profunctor p => Newtype t a => p t t -> p a a\nunwrapIso = dimap wrap unwrap\n\nwrapIso :: forall p t a. Profunctor p => Newtype t a => (a -> t) -> p a a -> p t t\nwrapIso _ = dimap unwrap wrap\n\ninstance profunctorFn :: Profunctor (->) where\n  dimap a2b c2d b2c = a2b >>> b2c >>> c2d\n", "const windowImpl = function () {\n  return window;\n};\nexport { windowImpl as window };\n", "export function _unsafeReadProtoTagged(nothing, just, name, value) {\n  if (typeof window !== \"undefined\") {\n    var ty = window[name];\n    if (ty != null && value instanceof ty) {\n      return just(value);\n    }\n  }\n  var obj = value;\n  while (obj != null) {\n    var proto = Object.getPrototypeOf(obj);\n    var constructorName = proto.constructor.name;\n    if (constructorName === name) {\n      return just(value);\n    } else if (constructorName === \"Object\") {\n      return nothing;\n    }\n    obj = proto;\n  }\n  return nothing;\n}\n", "module Web.Internal.FFI (unsafeReadProtoTagged) where\n\nimport Data.Function.Uncurried (Fn4, runFn4)\nimport Data.Maybe (Maybe(..))\n\nunsafeReadProtoTagged :: forall a b. String -> a -> Maybe b\nunsafeReadProtoTagged name value =\n  runFn4 _unsafeReadProtoTagged Nothing Just name value\n\nforeign import _unsafeReadProtoTagged\n  :: forall a b\n   . Fn4\n      (forall x. Maybe x)\n      (forall x. x -> Maybe x)\n      String\n      a\n      (Maybe b)\n", "export function autofocus(button) {\n  return function () {\n    return button.autofocus;\n  };\n}\n\nexport function setAutofocus(autofocus) {\n  return function (button) {\n    return function () {\n      button.autofocus = autofocus;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function disabled(button) {\n  return function () {\n    return button.disabled;\n  };\n}\n\nexport function setDisabled(disabled) {\n  return function (button) {\n    return function () {\n      button.disabled = disabled;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function _form(button) {\n  return function () {\n    return button.form;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function formAction(button) {\n  return function () {\n    return button.formAction;\n  };\n}\n\nexport function setFormAction(formAction) {\n  return function (button) {\n    return function () {\n      button.formAction = formAction;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function formEnctype(button) {\n  return function () {\n    return button.formEnctype;\n  };\n}\n\nexport function setFormEnctype(formEnctype) {\n  return function (button) {\n    return function () {\n      button.formEnctype = formEnctype;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function formMethod(button) {\n  return function () {\n    return button.formMethod;\n  };\n}\n\nexport function setFormMethod(formMethod) {\n  return function (button) {\n    return function () {\n      button.formMethod = formMethod;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function formNoValidate(button) {\n  return function () {\n    return button.formNoValidate;\n  };\n}\n\nexport function setFormNoValidate(formNoValidate) {\n  return function (button) {\n    return function () {\n      button.formNoValidate = formNoValidate;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function formTarget(button) {\n  return function () {\n    return button.formTarget;\n  };\n}\n\nexport function setFormTarget(formTarget) {\n  return function (button) {\n    return function () {\n      button.formTarget = formTarget;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function name(button) {\n  return function () {\n    return button.name;\n  };\n}\n\nexport function setName(name) {\n  return function (button) {\n    return function () {\n      button.name = name;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function type_(button) {\n  return function () {\n    return button.type;\n  };\n}\n\nexport function setType(type) {\n  return function (button) {\n    return function () {\n      button.type = type;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function value(button) {\n  return function () {\n    return button.value;\n  };\n}\n\nexport function setValue(value) {\n  return function (button) {\n    return function () {\n      button.value = value;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function willValidate(button) {\n  return function () {\n    return button.willValidate;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function validity(button) {\n  return function () {\n    return button.validity;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function validationMessage(button) {\n  return function () {\n    return button.validationMessage;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function checkValidity(button) {\n  return function () {\n    return button.checkValidity();\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function reportValidity(button) {\n  return function () {\n    return button.reportValidity();\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function setCustomValidity(value) {\n  return function (button) {\n    return function () {\n      button.setCustomValidity(value);\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function labels(button) {\n  return function () {\n    return button.labels;\n  };\n}\n", "module Web.HTML.HTMLButtonElement\n  ( HTMLButtonElement\n  , fromHTMLElement\n  , fromElement\n  , fromNode\n  , fromChildNode\n  , fromNonDocumentTypeChildNode\n  , fromParentNode\n  , fromEventTarget\n  , toHTMLElement\n  , toElement\n  , toNode\n  , toChildNode\n  , toNonDocumentTypeChildNode\n  , toParentNode\n  , toEventTarget\n  , autofocus\n  , setAutofocus\n  , disabled\n  , setDisabled\n  , form\n  , formAction\n  , setFormAction\n  , formEnctype\n  , setFormEnctype\n  , formMethod\n  , setFormMethod\n  , formNoValidate\n  , setFormNoValidate\n  , formTarget\n  , setFormTarget\n  , name\n  , setName\n  , type_\n  , setType\n  , value\n  , setValue\n  , willValidate\n  , validity\n  , validationMessage\n  , checkValidity\n  , reportValidity\n  , setCustomValidity\n  , labels\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM (ChildNode, Element, Node, NonDocumentTypeChildNode, ParentNode)\nimport Web.DOM.NodeList (NodeList)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.HTML.HTMLFormElement (HTMLFormElement)\nimport Web.HTML.ValidityState (ValidityState)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nforeign import data HTMLButtonElement :: Type\n\nfromHTMLElement :: HTMLElement -> Maybe HTMLButtonElement\nfromHTMLElement = unsafeReadProtoTagged \"HTMLButtonElement\"\n\nfromElement :: Element -> Maybe HTMLButtonElement\nfromElement = unsafeReadProtoTagged \"HTMLButtonElement\"\n\nfromNode :: Node -> Maybe HTMLButtonElement\nfromNode = unsafeReadProtoTagged \"HTMLButtonElement\"\n\nfromChildNode :: ChildNode -> Maybe HTMLButtonElement\nfromChildNode = unsafeReadProtoTagged \"HTMLButtonElement\"\n\nfromNonDocumentTypeChildNode :: NonDocumentTypeChildNode -> Maybe HTMLButtonElement\nfromNonDocumentTypeChildNode = unsafeReadProtoTagged \"HTMLButtonElement\"\n\nfromParentNode :: ParentNode -> Maybe HTMLButtonElement\nfromParentNode = unsafeReadProtoTagged \"HTMLButtonElement\"\n\nfromEventTarget :: EventTarget -> Maybe HTMLButtonElement\nfromEventTarget = unsafeReadProtoTagged \"HTMLButtonElement\"\n\ntoHTMLElement :: HTMLButtonElement -> HTMLElement\ntoHTMLElement = unsafeCoerce\n\ntoElement :: HTMLButtonElement -> Element\ntoElement = unsafeCoerce\n\ntoNode :: HTMLButtonElement -> Node\ntoNode = unsafeCoerce\n\ntoChildNode :: HTMLButtonElement -> ChildNode\ntoChildNode = unsafeCoerce\n\ntoNonDocumentTypeChildNode :: HTMLButtonElement -> NonDocumentTypeChildNode\ntoNonDocumentTypeChildNode = unsafeCoerce\n\ntoParentNode :: HTMLButtonElement -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoEventTarget :: HTMLButtonElement -> EventTarget\ntoEventTarget = unsafeCoerce\n\nforeign import autofocus :: HTMLButtonElement -> Effect Boolean\nforeign import setAutofocus :: Boolean -> HTMLButtonElement -> Effect Unit\n\nforeign import disabled :: HTMLButtonElement -> Effect Boolean\nforeign import setDisabled :: Boolean -> HTMLButtonElement -> Effect Unit\n\nform :: HTMLButtonElement -> Effect (Maybe HTMLFormElement)\nform = map toMaybe <<< _form\n\nforeign import _form :: HTMLButtonElement -> Effect (Nullable HTMLFormElement)\n\nforeign import formAction :: HTMLButtonElement -> Effect String\nforeign import setFormAction :: String -> HTMLButtonElement -> Effect Unit\n\nforeign import formEnctype :: HTMLButtonElement -> Effect String\nforeign import setFormEnctype :: String -> HTMLButtonElement -> Effect Unit\n\nforeign import formMethod :: HTMLButtonElement -> Effect String\nforeign import setFormMethod :: String -> HTMLButtonElement -> Effect Unit\n\nforeign import formNoValidate :: HTMLButtonElement -> Effect Boolean\nforeign import setFormNoValidate :: Boolean -> HTMLButtonElement -> Effect Unit\n\nforeign import formTarget :: HTMLButtonElement -> Effect String\nforeign import setFormTarget :: String -> HTMLButtonElement -> Effect Unit\n\nforeign import name :: HTMLButtonElement -> Effect String\nforeign import setName :: String -> HTMLButtonElement -> Effect Unit\n\nforeign import type_ :: HTMLButtonElement -> Effect String\nforeign import setType :: String -> HTMLButtonElement -> Effect Unit\n\nforeign import value :: HTMLButtonElement -> Effect String\nforeign import setValue :: String -> HTMLButtonElement -> Effect Unit\n\nforeign import willValidate :: HTMLButtonElement -> Effect Boolean\n\nforeign import validity :: HTMLButtonElement -> Effect ValidityState\n\nforeign import validationMessage :: HTMLButtonElement -> Effect String\n\nforeign import checkValidity :: HTMLButtonElement -> Effect Boolean\n\nforeign import reportValidity :: HTMLButtonElement -> Effect Boolean\n\nforeign import setCustomValidity :: String -> HTMLButtonElement -> Effect Unit\n\nforeign import labels :: HTMLButtonElement -> Effect NodeList\n", "export function _documentElement(doc) {\n  return doc.documentElement;\n}\n\nexport function _head(doc) {\n  return doc.head;\n}\n\nexport function _body(doc) {\n  return doc.body;\n}\n\nexport function _readyState(doc) {\n  return doc.readyState;\n}\n\nexport function _visibilityState(doc) {\n  return doc.readyState;\n}\n\nexport function _activeElement(doc) {\n  return doc.activeElement;\n}\n\nexport function _currentScript(doc) {\n  return doc.currentScript;\n}\n\nexport function _referrer(doc) {\n  return doc.referrer;\n}\n\nexport function _title(doc) {\n  return doc.title;\n}\n\nexport function _setTitle(title, doc) {\n  doc.title = title;\n}\n", "module Web.HTML.HTMLDocument\n  ( HTMLDocument\n  , fromDocument\n  , fromNode\n  , fromParentNode\n  , fromNonElementParentNode\n  , fromEventTarget\n  , toDocument\n  , toNode\n  , toParentNode\n  , toNonElementParentNode\n  , toEventTarget\n  , documentElement\n  , head\n  , body\n  , readyState\n  , visibilityState\n  , activeElement\n  , currentScript\n  , referrer\n  , title\n  , setTitle\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe, fromMaybe)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Effect.Uncurried (EffectFn1, EffectFn2, runEffectFn1, runEffectFn2)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Document (Document)\nimport Web.DOM.Internal.Types (Node)\nimport Web.DOM.NonElementParentNode (NonElementParentNode)\nimport Web.DOM.ParentNode (ParentNode)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.HTML.HTMLDocument.ReadyState (ReadyState)\nimport Web.HTML.HTMLDocument.ReadyState as ReadyState\nimport Web.HTML.HTMLDocument.VisibilityState (VisibilityState)\nimport Web.HTML.HTMLDocument.VisibilityState as VisibilityState\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.HTML.HTMLHtmlElement (HTMLHtmlElement)\nimport Web.HTML.HTMLScriptElement (HTMLScriptElement)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nforeign import data HTMLDocument :: Type\n\nfromDocument :: Document -> Maybe HTMLDocument\nfromDocument = unsafeReadProtoTagged \"HTMLDocument\"\n\nfromNode :: Node -> Maybe HTMLDocument\nfromNode = unsafeReadProtoTagged \"HTMLDocument\"\n\nfromParentNode :: ParentNode -> Maybe HTMLDocument\nfromParentNode = unsafeReadProtoTagged \"HTMLDocument\"\n\nfromNonElementParentNode :: NonElementParentNode -> Maybe HTMLDocument\nfromNonElementParentNode = unsafeReadProtoTagged \"HTMLDocument\"\n\nfromEventTarget :: EventTarget -> Maybe HTMLDocument\nfromEventTarget = unsafeReadProtoTagged \"HTMLDocument\"\n\ntoDocument :: HTMLDocument -> Document\ntoDocument = unsafeCoerce\n\ntoNode :: HTMLDocument -> Node\ntoNode = unsafeCoerce\n\ntoParentNode :: HTMLDocument -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoNonElementParentNode :: HTMLDocument -> NonElementParentNode\ntoNonElementParentNode = unsafeCoerce\n\ntoEventTarget :: HTMLDocument -> EventTarget\ntoEventTarget = unsafeCoerce\n\nforeign import _documentElement :: EffectFn1 HTMLDocument (Nullable HTMLHtmlElement)\n\ndocumentElement :: HTMLDocument -> Effect (Maybe HTMLHtmlElement)\ndocumentElement doc = toMaybe <$> runEffectFn1 _documentElement doc\n\nforeign import _head :: EffectFn1 HTMLDocument (Nullable HTMLElement)\n\nhead :: HTMLDocument -> Effect (Maybe HTMLElement)\nhead doc = toMaybe <$> runEffectFn1 _head doc\n\nforeign import _body :: EffectFn1 HTMLDocument (Nullable HTMLElement)\n\nbody :: HTMLDocument -> Effect (Maybe HTMLElement)\nbody doc = toMaybe <$> runEffectFn1 _body doc\n\nforeign import _readyState :: EffectFn1 HTMLDocument String\n\nreadyState :: HTMLDocument -> Effect ReadyState\nreadyState doc = (fromMaybe ReadyState.Loading <<< ReadyState.parse) <$> (runEffectFn1 _readyState doc)\n\nforeign import _visibilityState :: EffectFn1 HTMLDocument String\n\nvisibilityState :: HTMLDocument -> Effect VisibilityState\nvisibilityState doc = (fromMaybe VisibilityState.Visible <<< VisibilityState.parse) <$> (runEffectFn1 _visibilityState doc)\n\nforeign import _activeElement :: EffectFn1 HTMLDocument (Nullable HTMLElement)\n\nactiveElement :: HTMLDocument -> Effect (Maybe HTMLElement)\nactiveElement doc = toMaybe <$> (runEffectFn1 _activeElement doc)\n\nforeign import _currentScript :: EffectFn1 HTMLDocument (Nullable HTMLScriptElement)\n\ncurrentScript :: HTMLDocument -> Effect (Maybe HTMLScriptElement)\ncurrentScript doc = toMaybe <$> (runEffectFn1 _currentScript doc)\n\nforeign import _referrer :: EffectFn1 HTMLDocument String\n\nreferrer :: HTMLDocument -> Effect String\nreferrer doc = runEffectFn1 _referrer doc\n\nforeign import _title :: EffectFn1 HTMLDocument String\n\ntitle :: HTMLDocument -> Effect String\ntitle doc = runEffectFn1 _title doc\n\nforeign import _setTitle :: EffectFn2 String HTMLDocument Unit\n\nsetTitle :: String -> HTMLDocument -> Effect Unit\nsetTitle newTitle doc = runEffectFn2 _setTitle newTitle doc\n", "module Web.HTML.HTMLElement\n  ( HTMLElement\n  , fromElement\n  , fromNode\n  , fromChildNode\n  , fromNonDocumentTypeChildNode\n  , fromParentNode\n  , fromEventTarget\n  , toElement\n  , toNode\n  , toChildNode\n  , toNonDocumentTypeChildNode\n  , toParentNode\n  , toEventTarget\n  , title\n  , setTitle\n  , lang\n  , setLang\n  , dir\n  , setDir\n  , hidden\n  , setHidden\n  , tabIndex\n  , setTabIndex\n  , draggable\n  , setDraggable\n  , contentEditable\n  , setContentEditable\n  , isContentEditable\n  , spellcheck\n  , setSpellcheck\n  , click\n  , focus\n  , blur\n  , offsetParent\n  , offsetTop\n  , offsetLeft\n  , offsetWidth\n  , offsetHeight\n  ) where\n\nimport Prelude\n\nimport Data.Function.Uncurried (Fn3, runFn3)\nimport Data.Maybe (Maybe(..))\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM (ChildNode)\nimport Web.DOM.Element (Element)\nimport Web.DOM.Internal.Types (Node)\nimport Web.DOM.NonDocumentTypeChildNode (NonDocumentTypeChildNode)\nimport Web.DOM.ParentNode (ParentNode)\nimport Web.Event.EventTarget (EventTarget)\n\nforeign import data HTMLElement :: Type\n\nforeign import _read :: forall a. Fn3 (forall x. Maybe x) (forall x. x -> Maybe x) a (Maybe HTMLElement)\n\nfromElement :: Element -> Maybe HTMLElement\nfromElement x = runFn3 _read Nothing Just x\n\nfromNode :: Node -> Maybe HTMLElement\nfromNode x = runFn3 _read Nothing Just x\n\nfromChildNode :: ChildNode -> Maybe HTMLElement\nfromChildNode x = runFn3 _read Nothing Just x\n\nfromNonDocumentTypeChildNode :: NonDocumentTypeChildNode -> Maybe HTMLElement\nfromNonDocumentTypeChildNode x = runFn3 _read Nothing Just x\n\nfromParentNode :: ParentNode -> Maybe HTMLElement\nfromParentNode x = runFn3 _read Nothing Just x\n\nfromEventTarget :: EventTarget -> Maybe HTMLElement\nfromEventTarget x = runFn3 _read Nothing Just x\n\ntoElement :: HTMLElement -> Element\ntoElement = unsafeCoerce\n\ntoNode :: HTMLElement -> Node\ntoNode = unsafeCoerce\n\ntoChildNode :: HTMLElement -> ChildNode\ntoChildNode = unsafeCoerce\n\ntoNonDocumentTypeChildNode :: HTMLElement -> NonDocumentTypeChildNode\ntoNonDocumentTypeChildNode = unsafeCoerce\n\ntoParentNode :: HTMLElement -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoEventTarget :: HTMLElement -> EventTarget\ntoEventTarget = unsafeCoerce\n\nforeign import title :: HTMLElement -> Effect String\nforeign import setTitle :: String -> HTMLElement -> Effect Unit\n\nforeign import lang :: HTMLElement -> Effect String\nforeign import setLang :: String -> HTMLElement -> Effect Unit\n\nforeign import dir :: HTMLElement -> Effect String\nforeign import setDir :: String -> HTMLElement -> Effect Unit\n\nforeign import hidden :: HTMLElement -> Effect Boolean\nforeign import setHidden :: Boolean -> HTMLElement -> Effect Unit\n\nforeign import tabIndex :: HTMLElement -> Effect Int\nforeign import setTabIndex :: Int -> HTMLElement -> Effect Unit\n\nforeign import draggable :: HTMLElement -> Effect Boolean\nforeign import setDraggable :: Boolean -> HTMLElement -> Effect Unit\n\nforeign import contentEditable :: HTMLElement -> Effect String\nforeign import setContentEditable :: String -> HTMLElement -> Effect Unit\nforeign import isContentEditable :: HTMLElement -> Effect Boolean\n\nforeign import spellcheck :: HTMLElement -> Effect Boolean\nforeign import setSpellcheck :: Boolean -> HTMLElement -> Effect Unit\n\nforeign import click :: HTMLElement -> Effect Unit\nforeign import focus :: HTMLElement -> Effect Unit\nforeign import blur :: HTMLElement -> Effect Unit\n\nforeign import _offsetParent :: HTMLElement -> Effect (Nullable Element)\n\noffsetParent :: HTMLElement -> Effect (Maybe Element)\noffsetParent = map toMaybe <<< _offsetParent\n\nforeign import offsetTop :: HTMLElement -> Effect Number\nforeign import offsetLeft :: HTMLElement -> Effect Number\nforeign import offsetWidth :: HTMLElement -> Effect Number\nforeign import offsetHeight :: HTMLElement -> Effect Number\n", "export function disabled(fieldset) {\n  return function () {\n    return fieldset.disabled;\n  };\n}\n\nexport function setDisabled(disabled) {\n  return function (fieldset) {\n    return function () {\n      fieldset.disabled = disabled;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function _form(fieldset) {\n  return function () {\n    return fieldset.form;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function name(fieldset) {\n  return function () {\n    return fieldset.name;\n  };\n}\n\nexport function setName(name) {\n  return function (fieldset) {\n    return function () {\n      fieldset.name = name;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function type_(fieldset) {\n  return function () {\n    return fieldset.type;\n  };\n}\n\nexport function setType(type) {\n  return function (fieldset) {\n    return function () {\n      fieldset.type = type;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function willValidate(fieldset) {\n  return function () {\n    return fieldset.willValidate;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function validity(fieldset) {\n  return function () {\n    return fieldset.validity;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function validationMessage(fieldset) {\n  return function () {\n    return fieldset.validationMessage;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function checkValidity(fieldset) {\n  return function () {\n    return fieldset.checkValidity();\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function reportValidity(fieldset) {\n  return function () {\n    return fieldset.reportValidity();\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function setCustomValidity(value) {\n  return function (fieldset) {\n    return function () {\n      fieldset.setCustomValidity(value);\n    };\n  };\n}\n", "module Web.HTML.HTMLFieldSetElement\n  ( HTMLFieldSetElement\n  , fromHTMLElement\n  , fromElement\n  , fromNode\n  , fromChildNode\n  , fromNonDocumentTypeChildNode\n  , fromParentNode\n  , fromEventTarget\n  , toHTMLElement\n  , toElement\n  , toNode\n  , toChildNode\n  , toNonDocumentTypeChildNode\n  , toParentNode\n  , toEventTarget\n  , disabled\n  , setDisabled\n  , form\n  , name\n  , setName\n  , type_\n  , setType\n  , willValidate\n  , validity\n  , validationMessage\n  , checkValidity\n  , reportValidity\n  , setCustomValidity\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM (ChildNode, Element, Node, NonDocumentTypeChildNode, ParentNode)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.HTML.HTMLFormElement (HTMLFormElement)\nimport Web.HTML.ValidityState (ValidityState)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nforeign import data HTMLFieldSetElement :: Type\n\nfromHTMLElement :: HTMLElement -> Maybe HTMLFieldSetElement\nfromHTMLElement = unsafeReadProtoTagged \"HTMLFieldSetElement\"\n\nfromElement :: Element -> Maybe HTMLFieldSetElement\nfromElement = unsafeReadProtoTagged \"HTMLFieldSetElement\"\n\nfromNode :: Node -> Maybe HTMLFieldSetElement\nfromNode = unsafeReadProtoTagged \"HTMLFieldSetElement\"\n\nfromChildNode :: ChildNode -> Maybe HTMLFieldSetElement\nfromChildNode = unsafeReadProtoTagged \"HTMLFieldSetElement\"\n\nfromNonDocumentTypeChildNode :: NonDocumentTypeChildNode -> Maybe HTMLFieldSetElement\nfromNonDocumentTypeChildNode = unsafeReadProtoTagged \"HTMLFieldSetElement\"\n\nfromParentNode :: ParentNode -> Maybe HTMLFieldSetElement\nfromParentNode = unsafeReadProtoTagged \"HTMLFieldSetElement\"\n\nfromEventTarget :: EventTarget -> Maybe HTMLFieldSetElement\nfromEventTarget = unsafeReadProtoTagged \"HTMLFieldSetElement\"\n\ntoHTMLElement :: HTMLFieldSetElement -> HTMLElement\ntoHTMLElement = unsafeCoerce\n\ntoElement :: HTMLFieldSetElement -> Element\ntoElement = unsafeCoerce\n\ntoNode :: HTMLFieldSetElement -> Node\ntoNode = unsafeCoerce\n\ntoChildNode :: HTMLFieldSetElement -> ChildNode\ntoChildNode = unsafeCoerce\n\ntoNonDocumentTypeChildNode :: HTMLFieldSetElement -> NonDocumentTypeChildNode\ntoNonDocumentTypeChildNode = unsafeCoerce\n\ntoParentNode :: HTMLFieldSetElement -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoEventTarget :: HTMLFieldSetElement -> EventTarget\ntoEventTarget = unsafeCoerce\n\nforeign import disabled :: HTMLFieldSetElement -> Effect Boolean\nforeign import setDisabled :: Boolean -> HTMLFieldSetElement -> Effect Unit\n\nforeign import _form :: HTMLFieldSetElement -> Effect (Nullable HTMLFormElement)\n\nform :: HTMLFieldSetElement -> Effect (Maybe HTMLFormElement)\nform = map toMaybe <<< _form\n\nforeign import name :: HTMLFieldSetElement -> Effect String\nforeign import setName :: String -> HTMLFieldSetElement -> Effect Unit\n\nforeign import type_ :: HTMLFieldSetElement -> Effect String\nforeign import setType :: String -> HTMLFieldSetElement -> Effect Unit\n\n--   readonly attribute HTMLFormControlsCollection elements;\n\nforeign import willValidate :: HTMLFieldSetElement -> Effect Boolean\n\nforeign import validity :: HTMLFieldSetElement -> Effect ValidityState\n\nforeign import validationMessage :: HTMLFieldSetElement -> Effect String\n\nforeign import checkValidity :: HTMLFieldSetElement -> Effect Boolean\n\nforeign import reportValidity :: HTMLFieldSetElement -> Effect Boolean\n\nforeign import setCustomValidity :: String -> HTMLFieldSetElement -> Effect Unit\n", "export function accept(input) {\n  return function () {\n    return input.accept;\n  };\n}\n\nexport function setAccept(accept) {\n  return function (input) {\n    return function () {\n      input.accept = accept;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function alt(input) {\n  return function () {\n    return input.alt;\n  };\n}\n\nexport function setAlt(alt) {\n  return function (input) {\n    return function () {\n      input.alt = alt;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function autocomplete(input) {\n  return function () {\n    return input.autocomplete;\n  };\n}\n\nexport function setAutocomplete(autocomplete) {\n  return function (input) {\n    return function () {\n      input.autocomplete = autocomplete;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function autofocus(input) {\n  return function () {\n    return input.autofocus;\n  };\n}\n\nexport function setAutofocus(autofocus) {\n  return function (input) {\n    return function () {\n      input.autofocus = autofocus;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function defaultChecked(input) {\n  return function () {\n    return input.defaultChecked;\n  };\n}\n\nexport function setDefaultChecked(defaultChecked) {\n  return function (input) {\n    return function () {\n      input.defaultChecked = defaultChecked;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function checked(input) {\n  return function () {\n    return input.checked;\n  };\n}\n\nexport function setChecked(checked) {\n  return function (input) {\n    return function () {\n      input.checked = checked;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function dirName(input) {\n  return function () {\n    return input.dirName;\n  };\n}\n\nexport function setDirName(dirName) {\n  return function (input) {\n    return function () {\n      input.dirName = dirName;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function disabled(input) {\n  return function () {\n    return input.disabled;\n  };\n}\n\nexport function setDisabled(disabled) {\n  return function (input) {\n    return function () {\n      input.disabled = disabled;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function _form(input) {\n  return function () {\n    return input.form;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function _files(input) {\n  return function () {\n    return input.files;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function formAction(input) {\n  return function () {\n    return input.formAction;\n  };\n}\n\nexport function setFormAction(formAction) {\n  return function (input) {\n    return function () {\n      input.formAction = formAction;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function formEnctype(input) {\n  return function () {\n    return input.formEnctype;\n  };\n}\n\nexport function setFormEnctype(formEnctype) {\n  return function (input) {\n    return function () {\n      input.formEnctype = formEnctype;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function formMethod(input) {\n  return function () {\n    return input.formMethod;\n  };\n}\n\nexport function setFormMethod(formMethod) {\n  return function (input) {\n    return function () {\n      input.formMethod = formMethod;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function formNoValidate(input) {\n  return function () {\n    return input.formNoValidate;\n  };\n}\n\nexport function setFormNoValidate(formNoValidate) {\n  return function (input) {\n    return function () {\n      input.formNoValidate = formNoValidate;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function formTarget(input) {\n  return function () {\n    return input.formTarget;\n  };\n}\n\nexport function setFormTarget(formTarget) {\n  return function (input) {\n    return function () {\n      input.formTarget = formTarget;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function height(input) {\n  return function () {\n    return input.height;\n  };\n}\n\nexport function setHeight(height) {\n  return function (input) {\n    return function () {\n      input.height = height;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function indeterminate(input) {\n  return function () {\n    return input.indeterminate;\n  };\n}\n\nexport function setIndeterminate(indeterminate) {\n  return function (input) {\n    return function () {\n      input.indeterminate = indeterminate;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function _list(input) {\n  return function () {\n    return input.list;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function max(input) {\n  return function () {\n    return input.max;\n  };\n}\n\nexport function setMax(max) {\n  return function (input) {\n    return function () {\n      input.max = max;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function maxLength(input) {\n  return function () {\n    return input.maxLength;\n  };\n}\n\nexport function setMaxLength(maxLength) {\n  return function (input) {\n    return function () {\n      input.maxLength = maxLength;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function min(input) {\n  return function () {\n    return input.min;\n  };\n}\n\nexport function setMin(min) {\n  return function (input) {\n    return function () {\n      input.min = min;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function minLength(input) {\n  return function () {\n    return input.minLength;\n  };\n}\n\nexport function setMinLength(minLength) {\n  return function (input) {\n    return function () {\n      input.minLength = minLength;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function multiple(input) {\n  return function () {\n    return input.multiple;\n  };\n}\n\nexport function setMultiple(multiple) {\n  return function (input) {\n    return function () {\n      input.multiple = multiple;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function name(input) {\n  return function () {\n    return input.name;\n  };\n}\n\nexport function setName(name) {\n  return function (input) {\n    return function () {\n      input.name = name;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function pattern(input) {\n  return function () {\n    return input.pattern;\n  };\n}\n\nexport function setPattern(pattern) {\n  return function (input) {\n    return function () {\n      input.pattern = pattern;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function placeholder(input) {\n  return function () {\n    return input.placeholder;\n  };\n}\n\nexport function setPlaceholder(placeholder) {\n  return function (input) {\n    return function () {\n      input.placeholder = placeholder;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function readOnly(input) {\n  return function () {\n    return input.readOnly;\n  };\n}\n\nexport function setReadOnly(readOnly) {\n  return function (input) {\n    return function () {\n      input.readOnly = readOnly;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function required(input) {\n  return function () {\n    return input.required;\n  };\n}\n\nexport function setRequired(required) {\n  return function (input) {\n    return function () {\n      input.required = required;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function size(input) {\n  return function () {\n    return input.size;\n  };\n}\n\nexport function setSize(size) {\n  return function (input) {\n    return function () {\n      input.size = size;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function src(input) {\n  return function () {\n    return input.src;\n  };\n}\n\nexport function setSrc(src) {\n  return function (input) {\n    return function () {\n      input.src = src;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function step(input) {\n  return function () {\n    return input.step;\n  };\n}\n\nexport function setStep(step) {\n  return function (input) {\n    return function () {\n      input.step = step;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function type_(input) {\n  return function () {\n    return input.type;\n  };\n}\n\nexport function setType(type) {\n  return function (input) {\n    return function () {\n      input.type = type;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function defaultValue(input) {\n  return function () {\n    return input.defaultValue;\n  };\n}\n\nexport function setDefaultValue(defaultValue) {\n  return function (input) {\n    return function () {\n      input.defaultValue = defaultValue;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function value(input) {\n  return function () {\n    return input.value;\n  };\n}\n\nexport function setValue(value) {\n  return function (input) {\n    return function () {\n      input.value = value;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function valueAsDate(input) {\n  return function () {\n    return input.valueAsDate;\n  };\n}\n\nexport function setValueAsDate(valueAsDate) {\n  return function (input) {\n    return function () {\n      input.valueAsDate = valueAsDate;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function valueAsNumber(input) {\n  return function () {\n    return input.valueAsNumber;\n  };\n}\n\nexport function setValueAsNumber(valueAsNumber) {\n  return function (input) {\n    return function () {\n      input.valueAsNumber = valueAsNumber;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function width(input) {\n  return function () {\n    return input.width;\n  };\n}\n\nexport function setWidth(width) {\n  return function (input) {\n    return function () {\n      input.width = width;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function stepUpBy(n) {\n  return function (input) {\n    return function () {\n      input.stepUp(n);\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function stepDownBy(n) {\n  return function (input) {\n    return function () {\n      input.stepDown(n);\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function willValidate(input) {\n  return function () {\n    return input.willValidate;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function validity(input) {\n  return function () {\n    return input.validity;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function validationMessage(input) {\n  return function () {\n    return input.validationMessage;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function checkValidity(input) {\n  return function () {\n    return input.checkValidity();\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function reportValidity(input) {\n  return function () {\n    return input.reportValidity();\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function setCustomValidity(value) {\n  return function (input) {\n    return function () {\n      input.setCustomValidity(value);\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function labels(input) {\n  return function () {\n    return input.labels;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function select(input) {\n  return function () {\n    input.select();\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function selectionStart(input) {\n  return function () {\n    return input.selectionStart;\n  };\n}\n\nexport function setSelectionStart(selectionStart) {\n  return function (input) {\n    return function () {\n      input.selectionStart = selectionStart;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function selectionEnd(input) {\n  return function () {\n    return input.selectionEnd;\n  };\n}\n\nexport function setSelectionEnd(selectionEnd) {\n  return function (input) {\n    return function () {\n      input.selectionEnd = selectionEnd;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function selectionDirection(input) {\n  return function () {\n    return input.selectionDirection;\n  };\n}\n\nexport function setSelectionDirection(selectionDirection) {\n  return function (input) {\n    return function () {\n      input.selectionDirection = selectionDirection;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function setRangeText(replacement) {\n  return function (input) {\n    return function () {\n      input.setRangeText(replacement);\n    };\n  };\n}\n\nexport function _setRangeText(replacement, start, end, selectionMode, textarea) {\n  textarea.setRangeText(replacement, start, end, selectionMode);\n}\n\n// ----------------------------------------------------------------------------\n\nexport function setSelectionRange(start) {\n  return function (end) {\n    return function (direction) {\n      return function (input) {\n        return function () {\n          input.setSelectionRange(start, end, direction, input);\n        };\n      };\n    };\n  };\n}\n", "module Web.HTML.HTMLInputElement\n  ( HTMLInputElement\n  , fromHTMLElement\n  , fromElement\n  , fromNode\n  , fromChildNode\n  , fromNonDocumentTypeChildNode\n  , fromParentNode\n  , fromEventTarget\n  , toHTMLElement\n  , toElement\n  , toNode\n  , toChildNode\n  , toNonDocumentTypeChildNode\n  , toParentNode\n  , toEventTarget\n  , accept\n  , setAccept\n  , alt\n  , setAlt\n  , autocomplete\n  , setAutocomplete\n  , autofocus\n  , setAutofocus\n  , defaultChecked\n  , setDefaultChecked\n  , checked\n  , setChecked\n  , dirName\n  , setDirName\n  , disabled\n  , setDisabled\n  , form\n  , files\n  , formAction\n  , setFormAction\n  , formEnctype\n  , setFormEnctype\n  , formMethod\n  , setFormMethod\n  , formNoValidate\n  , setFormNoValidate\n  , formTarget\n  , setFormTarget\n  , height\n  , setHeight\n  , indeterminate\n  , setIndeterminate\n  , list\n  , max\n  , setMax\n  , maxLength\n  , setMaxLength\n  , min\n  , setMin\n  , minLength\n  , setMinLength\n  , multiple\n  , setMultiple\n  , name\n  , setName\n  , pattern\n  , setPattern\n  , placeholder\n  , setPlaceholder\n  , readOnly\n  , setReadOnly\n  , required\n  , setRequired\n  , size\n  , setSize\n  , src\n  , setSrc\n  , step\n  , setStep\n  , type_\n  , setType\n  , defaultValue\n  , setDefaultValue\n  , value\n  , setValue\n  , valueAsDate\n  , setValueAsDate\n  , valueAsNumber\n  , setValueAsNumber\n  , width\n  , setWidth\n  , stepUp\n  , stepUp'\n  , stepDown\n  , stepDown'\n  , willValidate\n  , validity\n  , validationMessage\n  , checkValidity\n  , reportValidity\n  , setCustomValidity\n  , labels\n  , select\n  , selectionStart\n  , setSelectionStart\n  , selectionEnd\n  , setSelectionEnd\n  , selectionDirection\n  , setSelectionDirection\n  , setRangeText\n  , setRangeText'\n  , setSelectionRange\n  ) where\n\nimport Prelude\n\nimport Data.JSDate (JSDate)\nimport Data.Maybe (Maybe)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Effect.Uncurried (EffectFn5, runEffectFn5)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM (ChildNode, Element, Node, NonDocumentTypeChildNode, ParentNode)\nimport Web.DOM.NodeList (NodeList)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.File.FileList (FileList)\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.HTML.HTMLFormElement (HTMLFormElement)\nimport Web.HTML.SelectionMode (SelectionMode)\nimport Web.HTML.SelectionMode as SelectionMode\nimport Web.HTML.ValidityState (ValidityState)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nforeign import data HTMLInputElement :: Type\n\nfromHTMLElement :: HTMLElement -> Maybe HTMLInputElement\nfromHTMLElement = unsafeReadProtoTagged \"HTMLInputElement\"\n\nfromElement :: Element -> Maybe HTMLInputElement\nfromElement = unsafeReadProtoTagged \"HTMLInputElement\"\n\nfromNode :: Node -> Maybe HTMLInputElement\nfromNode = unsafeReadProtoTagged \"HTMLInputElement\"\n\nfromChildNode :: ChildNode -> Maybe HTMLInputElement\nfromChildNode = unsafeReadProtoTagged \"HTMLInputElement\"\n\nfromNonDocumentTypeChildNode :: NonDocumentTypeChildNode -> Maybe HTMLInputElement\nfromNonDocumentTypeChildNode = unsafeReadProtoTagged \"HTMLInputElement\"\n\nfromParentNode :: ParentNode -> Maybe HTMLInputElement\nfromParentNode = unsafeReadProtoTagged \"HTMLInputElement\"\n\nfromEventTarget :: EventTarget -> Maybe HTMLInputElement\nfromEventTarget = unsafeReadProtoTagged \"HTMLInputElement\"\n\ntoHTMLElement :: HTMLInputElement -> HTMLElement\ntoHTMLElement = unsafeCoerce\n\ntoElement :: HTMLInputElement -> Element\ntoElement = unsafeCoerce\n\ntoNode :: HTMLInputElement -> Node\ntoNode = unsafeCoerce\n\ntoChildNode :: HTMLInputElement -> ChildNode\ntoChildNode = unsafeCoerce\n\ntoNonDocumentTypeChildNode :: HTMLInputElement -> NonDocumentTypeChildNode\ntoNonDocumentTypeChildNode = unsafeCoerce\n\ntoParentNode :: HTMLInputElement -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoEventTarget :: HTMLInputElement -> EventTarget\ntoEventTarget = unsafeCoerce\n\nforeign import accept :: HTMLInputElement -> Effect String\nforeign import setAccept :: String -> HTMLInputElement -> Effect Unit\n\nforeign import alt :: HTMLInputElement -> Effect Boolean\nforeign import setAlt :: Boolean -> HTMLInputElement -> Effect Unit\n\nforeign import autocomplete :: HTMLInputElement -> Effect String\nforeign import setAutocomplete :: String -> HTMLInputElement -> Effect Unit\n\nforeign import autofocus :: HTMLInputElement -> Effect Boolean\nforeign import setAutofocus :: Boolean -> HTMLInputElement -> Effect Unit\n\nforeign import defaultChecked :: HTMLInputElement -> Effect Boolean\nforeign import setDefaultChecked :: Boolean -> HTMLInputElement -> Effect Unit\n\nforeign import checked :: HTMLInputElement -> Effect Boolean\nforeign import setChecked :: Boolean -> HTMLInputElement -> Effect Unit\n\nforeign import dirName :: HTMLInputElement -> Effect String\nforeign import setDirName :: String -> HTMLInputElement -> Effect Unit\n\nforeign import disabled :: HTMLInputElement -> Effect Boolean\nforeign import setDisabled :: Boolean -> HTMLInputElement -> Effect Unit\n\nform :: HTMLInputElement -> Effect (Maybe HTMLFormElement)\nform = map toMaybe <<< _form\n\nforeign import _form :: HTMLInputElement -> Effect (Nullable HTMLFormElement)\n\nfiles :: HTMLInputElement -> Effect (Maybe FileList)\nfiles = map toMaybe <<< _files\n\nforeign import _files :: HTMLInputElement -> Effect (Nullable FileList)\n\nforeign import formAction :: HTMLInputElement -> Effect String\nforeign import setFormAction :: String -> HTMLInputElement -> Effect Unit\n\nforeign import formEnctype :: HTMLInputElement -> Effect String\nforeign import setFormEnctype :: String -> HTMLInputElement -> Effect Unit\n\nforeign import formMethod :: HTMLInputElement -> Effect String\nforeign import setFormMethod :: String -> HTMLInputElement -> Effect Unit\n\nforeign import formNoValidate :: HTMLInputElement -> Effect Boolean\nforeign import setFormNoValidate :: Boolean -> HTMLInputElement -> Effect Unit\n\nforeign import formTarget :: HTMLInputElement -> Effect String\nforeign import setFormTarget :: String -> HTMLInputElement -> Effect Unit\n\nforeign import height :: HTMLInputElement -> Effect Int\nforeign import setHeight :: Int -> HTMLInputElement -> Effect Unit\n\nforeign import indeterminate :: HTMLInputElement -> Effect Boolean\nforeign import setIndeterminate :: Boolean -> HTMLInputElement -> Effect Unit\n\nlist :: HTMLInputElement -> Effect (Maybe HTMLElement)\nlist = map toMaybe <<< _list\n\nforeign import _list :: HTMLInputElement -> Effect (Nullable HTMLElement)\n\nforeign import max :: HTMLInputElement -> Effect String\nforeign import setMax :: String -> HTMLInputElement -> Effect Unit\n\nforeign import maxLength :: HTMLInputElement -> Effect Int\nforeign import setMaxLength :: Int -> HTMLInputElement -> Effect Unit\n\nforeign import min :: HTMLInputElement -> Effect String\nforeign import setMin :: String -> HTMLInputElement -> Effect Unit\n\nforeign import minLength :: HTMLInputElement -> Effect Int\nforeign import setMinLength :: Int -> HTMLInputElement -> Effect Unit\n\nforeign import multiple :: HTMLInputElement -> Effect Boolean\nforeign import setMultiple :: Boolean -> HTMLInputElement -> Effect Unit\n\nforeign import name :: HTMLInputElement -> Effect String\nforeign import setName :: String -> HTMLInputElement -> Effect Unit\n\nforeign import pattern :: HTMLInputElement -> Effect String\nforeign import setPattern :: String -> HTMLInputElement -> Effect Unit\n\nforeign import placeholder :: HTMLInputElement -> Effect String\nforeign import setPlaceholder :: String -> HTMLInputElement -> Effect Unit\n\nforeign import readOnly :: HTMLInputElement -> Effect Boolean\nforeign import setReadOnly :: Boolean -> HTMLInputElement -> Effect Unit\n\nforeign import required :: HTMLInputElement -> Effect Boolean\nforeign import setRequired :: Boolean -> HTMLInputElement -> Effect Unit\n\nforeign import size :: HTMLInputElement -> Effect Int\nforeign import setSize :: Int -> HTMLInputElement -> Effect Unit\n\nforeign import src :: HTMLInputElement -> Effect String\nforeign import setSrc :: String -> HTMLInputElement -> Effect Unit\n\nforeign import step :: HTMLInputElement -> Effect String\nforeign import setStep :: String -> HTMLInputElement -> Effect Unit\n\nforeign import type_ :: HTMLInputElement -> Effect String\nforeign import setType :: String -> HTMLInputElement -> Effect Unit\n\nforeign import defaultValue :: HTMLInputElement -> Effect String\nforeign import setDefaultValue :: String -> HTMLInputElement -> Effect Unit\n\nforeign import value :: HTMLInputElement -> Effect String\nforeign import setValue :: String -> HTMLInputElement -> Effect Unit\n\nforeign import valueAsDate :: HTMLInputElement -> Effect JSDate\nforeign import setValueAsDate :: JSDate -> HTMLInputElement -> Effect Unit\n\nforeign import valueAsNumber :: HTMLInputElement -> Effect Number\nforeign import setValueAsNumber :: Number -> HTMLInputElement -> Effect Unit\n\nforeign import width :: HTMLInputElement -> Effect Int\nforeign import setWidth :: Int -> HTMLInputElement -> Effect Unit\n\nstepUp :: HTMLInputElement -> Effect Unit\nstepUp = stepUp' 1\n\nforeign import stepUpBy :: Int -> HTMLInputElement -> Effect Unit\n\nstepUp' :: Int -> HTMLInputElement -> Effect Unit\nstepUp' = stepUpBy\n\nstepDown :: HTMLInputElement -> Effect Unit\nstepDown = stepDown' 1\n\nforeign import stepDownBy :: Int -> HTMLInputElement -> Effect Unit\n\nstepDown' :: Int -> HTMLInputElement -> Effect Unit\nstepDown' = stepDownBy\n\nforeign import willValidate :: HTMLInputElement -> Effect Boolean\n\nforeign import validity :: HTMLInputElement -> Effect ValidityState\n\nforeign import validationMessage :: HTMLInputElement -> Effect String\n\nforeign import checkValidity :: HTMLInputElement -> Effect Boolean\n\nforeign import reportValidity :: HTMLInputElement -> Effect Boolean\n\nforeign import setCustomValidity :: String -> HTMLInputElement -> Effect Unit\n\nforeign import labels :: HTMLInputElement -> Effect NodeList\n\nforeign import select :: HTMLInputElement -> Effect Unit\n\nforeign import selectionStart :: HTMLInputElement -> Effect Int\nforeign import setSelectionStart :: Int -> HTMLInputElement -> Effect Unit\n\nforeign import selectionEnd :: HTMLInputElement -> Effect Int\nforeign import setSelectionEnd :: Int -> HTMLInputElement -> Effect Unit\n\nforeign import selectionDirection :: HTMLInputElement -> Effect String\nforeign import setSelectionDirection :: String -> HTMLInputElement -> Effect Unit\n\nforeign import setRangeText :: String -> HTMLInputElement -> Effect Unit\n\nsetRangeText' :: String -> Int -> Int -> SelectionMode -> HTMLInputElement -> Effect Unit\nsetRangeText' rpl s e mode area =\n  runEffectFn5 _setRangeText rpl s e (SelectionMode.print mode) area\n\nforeign import _setRangeText :: EffectFn5 String Int Int String HTMLInputElement Unit\n\nforeign import setSelectionRange :: Int -> Int -> String -> HTMLInputElement -> Effect Unit\n", "export function autofocus(keygen) {\n  return function () {\n    return keygen.autofocus;\n  };\n}\n\nexport function setAutofocus(autofocus) {\n  return function (keygen) {\n    return function () {\n      keygen.autofocus = autofocus;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function challenge(keygen) {\n  return function () {\n    return keygen.challenge;\n  };\n}\n\nexport function setChallenge(challenge) {\n  return function (keygen) {\n    return function () {\n      keygen.challenge = challenge;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function disabled(keygen) {\n  return function () {\n    return keygen.disabled;\n  };\n}\n\nexport function setDisabled(disabled) {\n  return function (keygen) {\n    return function () {\n      keygen.disabled = disabled;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function _form(keygen) {\n  return function () {\n    return keygen.form;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function keytype(keygen) {\n  return function () {\n    return keygen.keytype;\n  };\n}\n\nexport function setKeytype(keytype) {\n  return function (keygen) {\n    return function () {\n      keygen.keytype = keytype;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function name(keygen) {\n  return function () {\n    return keygen.name;\n  };\n}\n\nexport function setName(name) {\n  return function (keygen) {\n    return function () {\n      keygen.name = name;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function type_(keygen) {\n  return function () {\n    return keygen.type;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function willValidate(keygen) {\n  return function () {\n    return keygen.willValidate;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function validity(keygen) {\n  return function () {\n    return keygen.validity;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function validationMessage(keygen) {\n  return function () {\n    return keygen.validationMessage;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function checkValidity(keygen) {\n  return function () {\n    return keygen.checkValidity();\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function reportValidity(keygen) {\n  return function () {\n    return keygen.reportValidity();\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function setCustomValidity(value) {\n  return function (keygen) {\n    return function () {\n      keygen.setCustomValidity(value);\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function labels(keygen) {\n  return function () {\n    return keygen.labels;\n  };\n}\n", "module Web.HTML.HTMLKeygenElement\n  ( HTMLKeygenElement\n  , fromHTMLElement\n  , fromElement\n  , fromNode\n  , fromChildNode\n  , fromNonDocumentTypeChildNode\n  , fromParentNode\n  , fromEventTarget\n  , toHTMLElement\n  , toElement\n  , toNode\n  , toChildNode\n  , toNonDocumentTypeChildNode\n  , toParentNode\n  , toEventTarget\n  , autofocus\n  , setAutofocus\n  , challenge\n  , setChallenge\n  , disabled\n  , setDisabled\n  , form\n  , keytype\n  , setKeytype\n  , name\n  , setName\n  , type_\n  , willValidate\n  , validity\n  , validationMessage\n  , checkValidity\n  , reportValidity\n  , setCustomValidity\n  , labels\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM (ChildNode, Element, Node, NonDocumentTypeChildNode, ParentNode)\nimport Web.DOM.NodeList (NodeList)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.HTML.HTMLFormElement (HTMLFormElement)\nimport Web.HTML.ValidityState (ValidityState)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nforeign import data HTMLKeygenElement :: Type\n\nfromHTMLElement :: HTMLElement -> Maybe HTMLKeygenElement\nfromHTMLElement = unsafeReadProtoTagged \"HTMLKeygenElement\"\n\nfromElement :: Element -> Maybe HTMLKeygenElement\nfromElement = unsafeReadProtoTagged \"HTMLKeygenElement\"\n\nfromNode :: Node -> Maybe HTMLKeygenElement\nfromNode = unsafeReadProtoTagged \"HTMLKeygenElement\"\n\nfromChildNode :: ChildNode -> Maybe HTMLKeygenElement\nfromChildNode = unsafeReadProtoTagged \"HTMLKeygenElement\"\n\nfromNonDocumentTypeChildNode :: NonDocumentTypeChildNode -> Maybe HTMLKeygenElement\nfromNonDocumentTypeChildNode = unsafeReadProtoTagged \"HTMLKeygenElement\"\n\nfromParentNode :: ParentNode -> Maybe HTMLKeygenElement\nfromParentNode = unsafeReadProtoTagged \"HTMLKeygenElement\"\n\nfromEventTarget :: EventTarget -> Maybe HTMLKeygenElement\nfromEventTarget = unsafeReadProtoTagged \"HTMLKeygenElement\"\n\ntoHTMLElement :: HTMLKeygenElement -> HTMLElement\ntoHTMLElement = unsafeCoerce\n\ntoElement :: HTMLKeygenElement -> Element\ntoElement = unsafeCoerce\n\ntoNode :: HTMLKeygenElement -> Node\ntoNode = unsafeCoerce\n\ntoChildNode :: HTMLKeygenElement -> ChildNode\ntoChildNode = unsafeCoerce\n\ntoNonDocumentTypeChildNode :: HTMLKeygenElement -> NonDocumentTypeChildNode\ntoNonDocumentTypeChildNode = unsafeCoerce\n\ntoParentNode :: HTMLKeygenElement -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoEventTarget :: HTMLKeygenElement -> EventTarget\ntoEventTarget = unsafeCoerce\n\nforeign import autofocus :: HTMLKeygenElement -> Effect Boolean\nforeign import setAutofocus :: Boolean -> HTMLKeygenElement -> Effect Unit\n\nforeign import challenge :: HTMLKeygenElement -> Effect String\nforeign import setChallenge :: String -> HTMLKeygenElement -> Effect Unit\n\nforeign import disabled :: HTMLKeygenElement -> Effect Boolean\nforeign import setDisabled :: Boolean -> HTMLKeygenElement -> Effect Unit\n\nform :: HTMLKeygenElement -> Effect (Maybe HTMLFormElement)\nform = map toMaybe <<< _form\n\nforeign import _form :: HTMLKeygenElement -> Effect (Nullable HTMLFormElement)\n\nforeign import keytype :: HTMLKeygenElement -> Effect String\nforeign import setKeytype :: String -> HTMLKeygenElement -> Effect Unit\n\nforeign import name :: HTMLKeygenElement -> Effect String\nforeign import setName :: String -> HTMLKeygenElement -> Effect Unit\n\nforeign import type_ :: HTMLKeygenElement -> Effect String\n\nforeign import willValidate :: HTMLKeygenElement -> Effect Boolean\n\nforeign import validity :: HTMLKeygenElement -> Effect ValidityState\n\nforeign import validationMessage :: HTMLKeygenElement -> Effect String\n\nforeign import checkValidity :: HTMLKeygenElement -> Effect Boolean\n\nforeign import reportValidity :: HTMLKeygenElement -> Effect Boolean\n\nforeign import setCustomValidity :: String -> HTMLKeygenElement -> Effect Unit\n\nforeign import labels :: HTMLKeygenElement -> Effect NodeList\n", "export function disabled(link) {\n  return function () {\n    return link.disabled;\n  };\n}\n\nexport function setDisabled(disabled) {\n  return function (link) {\n    return function () {\n      link.disabled = disabled;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function href(link) {\n  return function () {\n    return link.href;\n  };\n}\n\nexport function setHref(href) {\n  return function (link) {\n    return function () {\n      link.href = href;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function crossOrigin(link) {\n  return function () {\n    return link.crossOrigin;\n  };\n}\n\nexport function setCrossOrigin(crossOrigin) {\n  return function (link) {\n    return function () {\n      link.crossOrigin = crossOrigin;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function rel(link) {\n  return function () {\n    return link.rel;\n  };\n}\n\nexport function setRel(rel) {\n  return function (link) {\n    return function () {\n      link.rel = rel;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function rev(link) {\n  return function () {\n    return link.rev;\n  };\n}\n\nexport function setRev(rev) {\n  return function (link) {\n    return function () {\n      link.rev = rev;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function relList(link) {\n  return function () {\n    return link.relList;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function media(link) {\n  return function () {\n    return link.media;\n  };\n}\n\nexport function setMedia(media) {\n  return function (link) {\n    return function () {\n      link.media = media;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function hreflang(link) {\n  return function () {\n    return link.hreflang;\n  };\n}\n\nexport function setHreflang(hreflang) {\n  return function (link) {\n    return function () {\n      link.hreflang = hreflang;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function type_(link) {\n  return function () {\n    return link.type;\n  };\n}\n\nexport function setType(type) {\n  return function (link) {\n    return function () {\n      link.type = type;\n    };\n  };\n}\n", "module Web.HTML.HTMLLinkElement where\n\nimport Data.Maybe (Maybe)\nimport Effect (Effect)\nimport Prelude (Unit)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM (ChildNode, Element, Node, NonDocumentTypeChildNode, ParentNode)\nimport Web.DOM.DOMTokenList (DOMTokenList)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nforeign import data HTMLLinkElement :: Type\n\nfromHTMLElement :: HTMLElement -> Maybe HTMLLinkElement\nfromHTMLElement = unsafeReadProtoTagged \"HTMLLinkElement\"\n\nfromElement :: Element -> Maybe HTMLLinkElement\nfromElement = unsafeReadProtoTagged \"HTMLLinkElement\"\n\nfromNode :: Node -> Maybe HTMLLinkElement\nfromNode = unsafeReadProtoTagged \"HTMLLinkElement\"\n\nfromChildNode :: ChildNode -> Maybe HTMLLinkElement\nfromChildNode = unsafeReadProtoTagged \"HTMLLinkElement\"\n\nfromNonDocumentTypeChildNode :: NonDocumentTypeChildNode -> Maybe HTMLLinkElement\nfromNonDocumentTypeChildNode = unsafeReadProtoTagged \"HTMLLinkElement\"\n\nfromParentNode :: ParentNode -> Maybe HTMLLinkElement\nfromParentNode = unsafeReadProtoTagged \"HTMLLinkElement\"\n\nfromEventTarget :: EventTarget -> Maybe HTMLLinkElement\nfromEventTarget = unsafeReadProtoTagged \"HTMLLinkElement\"\n\ntoHTMLElement :: HTMLLinkElement -> HTMLElement\ntoHTMLElement = unsafeCoerce\n\ntoElement :: HTMLLinkElement -> Element\ntoElement = unsafeCoerce\n\ntoNode :: HTMLLinkElement -> Node\ntoNode = unsafeCoerce\n\ntoChildNode :: HTMLLinkElement -> ChildNode\ntoChildNode = unsafeCoerce\n\ntoNonDocumentTypeChildNode :: HTMLLinkElement -> NonDocumentTypeChildNode\ntoNonDocumentTypeChildNode = unsafeCoerce\n\ntoParentNode :: HTMLLinkElement -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoEventTarget :: HTMLLinkElement -> EventTarget\ntoEventTarget = unsafeCoerce\n\nforeign import disabled :: HTMLLinkElement -> Effect Boolean\nforeign import setDisabled :: Boolean -> HTMLLinkElement -> Effect Unit\n\nforeign import href :: HTMLLinkElement -> Effect String\nforeign import setHref :: String -> HTMLLinkElement -> Effect Unit\n\nforeign import crossOrigin :: HTMLLinkElement -> Effect String\nforeign import setCrossOrigin :: String -> HTMLLinkElement -> Effect Unit\n\nforeign import rel :: HTMLLinkElement -> Effect String\nforeign import setRel :: String -> HTMLLinkElement -> Effect Unit\n\nforeign import rev :: HTMLLinkElement -> Effect String\nforeign import setRev :: String -> HTMLLinkElement -> Effect Unit\n\nforeign import relList :: HTMLLinkElement -> Effect DOMTokenList\n\nforeign import media :: HTMLLinkElement -> Effect String\nforeign import setMedia :: String -> HTMLLinkElement -> Effect Unit\n\nforeign import hreflang :: HTMLLinkElement -> Effect String\nforeign import setHreflang :: String -> HTMLLinkElement -> Effect Unit\n\nforeign import type_ :: HTMLLinkElement -> Effect String\nforeign import setType :: String -> HTMLLinkElement -> Effect Unit\n\n--   [PutForwards=value] readonly attribute DOMSettableTokenList sizes;\n\n-- HTMLLinkElement implements LinkStyle;\n", "export function disabled(optgroup) {\n  return function () {\n    return optgroup.disabled;\n  };\n}\n\nexport function setDisabled(disabled) {\n  return function (optgroup) {\n    return function () {\n      optgroup.disabled = disabled;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function label(optgroup) {\n  return function () {\n    return optgroup.label;\n  };\n}\n\nexport function setLabel(label) {\n  return function (optgroup) {\n    return function () {\n      optgroup.label = label;\n    };\n  };\n}\n", "module Web.HTML.HTMLOptGroupElement where\n\nimport Data.Maybe (Maybe)\nimport Effect (Effect)\nimport Prelude (Unit)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM (ChildNode, Element, Node, NonDocumentTypeChildNode, ParentNode)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nforeign import data HTMLOptGroupElement :: Type\n\nfromHTMLElement :: HTMLElement -> Maybe HTMLOptGroupElement\nfromHTMLElement = unsafeReadProtoTagged \"HTMLOptGroupElement\"\n\nfromElement :: Element -> Maybe HTMLOptGroupElement\nfromElement = unsafeReadProtoTagged \"HTMLOptGroupElement\"\n\nfromNode :: Node -> Maybe HTMLOptGroupElement\nfromNode = unsafeReadProtoTagged \"HTMLOptGroupElement\"\n\nfromChildNode :: ChildNode -> Maybe HTMLOptGroupElement\nfromChildNode = unsafeReadProtoTagged \"HTMLOptGroupElement\"\n\nfromNonDocumentTypeChildNode :: NonDocumentTypeChildNode -> Maybe HTMLOptGroupElement\nfromNonDocumentTypeChildNode = unsafeReadProtoTagged \"HTMLOptGroupElement\"\n\nfromParentNode :: ParentNode -> Maybe HTMLOptGroupElement\nfromParentNode = unsafeReadProtoTagged \"HTMLOptGroupElement\"\n\nfromEventTarget :: EventTarget -> Maybe HTMLOptGroupElement\nfromEventTarget = unsafeReadProtoTagged \"HTMLOptGroupElement\"\n\ntoHTMLElement :: HTMLOptGroupElement -> HTMLElement\ntoHTMLElement = unsafeCoerce\n\ntoElement :: HTMLOptGroupElement -> Element\ntoElement = unsafeCoerce\n\ntoNode :: HTMLOptGroupElement -> Node\ntoNode = unsafeCoerce\n\ntoChildNode :: HTMLOptGroupElement -> ChildNode\ntoChildNode = unsafeCoerce\n\ntoNonDocumentTypeChildNode :: HTMLOptGroupElement -> NonDocumentTypeChildNode\ntoNonDocumentTypeChildNode = unsafeCoerce\n\ntoParentNode :: HTMLOptGroupElement -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoEventTarget :: HTMLOptGroupElement -> EventTarget\ntoEventTarget = unsafeCoerce\n\nforeign import disabled :: HTMLOptGroupElement -> Effect Boolean\nforeign import setDisabled :: Boolean -> HTMLOptGroupElement -> Effect Unit\n\nforeign import label :: HTMLOptGroupElement -> Effect String\nforeign import setLabel :: String -> HTMLOptGroupElement -> Effect Unit\n", "export function disabled(option) {\n  return function () {\n    return option.disabled;\n  };\n}\n\nexport function setDisabled(disabled) {\n  return function (option) {\n    return function () {\n      option.disabled = disabled;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function _form(option) {\n  return function () {\n    return option.form;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function label(option) {\n  return function () {\n    return option.label;\n  };\n}\n\nexport function setLabel(label) {\n  return function (option) {\n    return function () {\n      option.label = label;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function defaultSelected(option) {\n  return function () {\n    return option.defaultSelected;\n  };\n}\n\nexport function setDefaultSelected(defaultSelected) {\n  return function (option) {\n    return function () {\n      option.defaultSelected = defaultSelected;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function selected(option) {\n  return function () {\n    return option.selected;\n  };\n}\n\nexport function setSelected(selected) {\n  return function (option) {\n    return function () {\n      option.selected = selected;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function value(option) {\n  return function () {\n    return option.value;\n  };\n}\n\nexport function setValue(value) {\n  return function (option) {\n    return function () {\n      option.value = value;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function text(option) {\n  return function () {\n    return option.text;\n  };\n}\n\nexport function setText(text) {\n  return function (option) {\n    return function () {\n      option.text = text;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function index(option) {\n  return function () {\n    return option.index;\n  };\n}\n", "module Web.HTML.HTMLOptionElement\n  ( HTMLOptionElement\n  , fromHTMLElement\n  , fromElement\n  , fromNode\n  , fromChildNode\n  , fromNonDocumentTypeChildNode\n  , fromParentNode\n  , fromEventTarget\n  , toHTMLElement\n  , toElement\n  , toNode\n  , toChildNode\n  , toNonDocumentTypeChildNode\n  , toParentNode\n  , toEventTarget\n  , disabled\n  , setDisabled\n  , form\n  , label\n  , setLabel\n  , defaultSelected\n  , setDefaultSelected\n  , selected\n  , setSelected\n  , value\n  , setValue\n  , text\n  , setText\n  , index\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM (ChildNode, Element, Node, NonDocumentTypeChildNode, ParentNode)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.HTML.HTMLFormElement (HTMLFormElement)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nforeign import data HTMLOptionElement :: Type\n\nfromHTMLElement :: HTMLElement -> Maybe HTMLOptionElement\nfromHTMLElement = unsafeReadProtoTagged \"HTMLOptionElement\"\n\nfromElement :: Element -> Maybe HTMLOptionElement\nfromElement = unsafeReadProtoTagged \"HTMLOptionElement\"\n\nfromNode :: Node -> Maybe HTMLOptionElement\nfromNode = unsafeReadProtoTagged \"HTMLOptionElement\"\n\nfromChildNode :: ChildNode -> Maybe HTMLOptionElement\nfromChildNode = unsafeReadProtoTagged \"HTMLOptionElement\"\n\nfromNonDocumentTypeChildNode :: NonDocumentTypeChildNode -> Maybe HTMLOptionElement\nfromNonDocumentTypeChildNode = unsafeReadProtoTagged \"HTMLOptionElement\"\n\nfromParentNode :: ParentNode -> Maybe HTMLOptionElement\nfromParentNode = unsafeReadProtoTagged \"HTMLOptionElement\"\n\nfromEventTarget :: EventTarget -> Maybe HTMLOptionElement\nfromEventTarget = unsafeReadProtoTagged \"HTMLOptionElement\"\n\ntoHTMLElement :: HTMLOptionElement -> HTMLElement\ntoHTMLElement = unsafeCoerce\n\ntoElement :: HTMLOptionElement -> Element\ntoElement = unsafeCoerce\n\ntoNode :: HTMLOptionElement -> Node\ntoNode = unsafeCoerce\n\ntoChildNode :: HTMLOptionElement -> ChildNode\ntoChildNode = unsafeCoerce\n\ntoNonDocumentTypeChildNode :: HTMLOptionElement -> NonDocumentTypeChildNode\ntoNonDocumentTypeChildNode = unsafeCoerce\n\ntoParentNode :: HTMLOptionElement -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoEventTarget :: HTMLOptionElement -> EventTarget\ntoEventTarget = unsafeCoerce\n\n-- [NamedConstructor=Option(optional DOMString text = \"\", optional DOMString value, optional boolean defaultSelected = false, optional boolean selected = false)]\n\nforeign import disabled :: HTMLOptionElement -> Effect Boolean\nforeign import setDisabled :: Boolean -> HTMLOptionElement -> Effect Unit\n\nform :: HTMLOptionElement -> Effect (Maybe HTMLFormElement)\nform = map toMaybe <<< _form\n\nforeign import _form :: HTMLOptionElement -> Effect (Nullable HTMLFormElement)\n\nforeign import label :: HTMLOptionElement -> Effect String\nforeign import setLabel :: String -> HTMLOptionElement -> Effect Unit\n\nforeign import defaultSelected :: HTMLOptionElement -> Effect Boolean\nforeign import setDefaultSelected :: Boolean -> HTMLOptionElement -> Effect Unit\n\nforeign import selected :: HTMLOptionElement -> Effect Boolean\nforeign import setSelected :: Boolean -> HTMLOptionElement -> Effect Unit\n\nforeign import value :: HTMLOptionElement -> Effect String\nforeign import setValue :: String -> HTMLOptionElement -> Effect Unit\n\nforeign import text :: HTMLOptionElement -> Effect String\nforeign import setText :: String -> HTMLOptionElement -> Effect Unit\n\nforeign import index :: HTMLOptionElement -> Effect Int\n", "export function autofocus(select) {\n  return function () {\n    return select.autofocus;\n  };\n}\n\nexport function setAutofocus(autofocus) {\n  return function (select) {\n    return function () {\n      select.autofocus = autofocus;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function disabled(select) {\n  return function () {\n    return select.disabled;\n  };\n}\n\nexport function setDisabled(disabled) {\n  return function (select) {\n    return function () {\n      select.disabled = disabled;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function multiple(select) {\n  return function () {\n    return select.multiple;\n  };\n}\n\nexport function setMultiple(multiple) {\n  return function (select) {\n    return function () {\n      select.multiple = multiple;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function _form(select) {\n  return function () {\n    return select.form;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function name(select) {\n  return function () {\n    return select.name;\n  };\n}\n\nexport function setName(name) {\n  return function (select) {\n    return function () {\n      select.name = name;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function required(select) {\n  return function () {\n    return select.required;\n  };\n}\n\nexport function setRequired(required) {\n  return function (select) {\n    return function () {\n      select.required = required;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function size(select) {\n  return function () {\n    return select.size;\n  };\n}\n\nexport function setSize(size) {\n  return function (select) {\n    return function () {\n      select.size = size;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function type_(select) {\n  return function () {\n    return select.type;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function length(select) {\n  return function () {\n    return select.length;\n  };\n}\n\nexport function setLength(length) {\n  return function (select) {\n    return function () {\n      select.length = length;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function selectedOptions(select) {\n  return function () {\n    return select.selectedOptions;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function selectedIndex(select) {\n  return function () {\n    return select.selectedIndex;\n  };\n}\n\nexport function setSelectedIndex(selectedIndex) {\n  return function (select) {\n    return function () {\n      select.selectedIndex = selectedIndex;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function value(select) {\n  return function () {\n    return select.value;\n  };\n}\n\nexport function setValue(value) {\n  return function (select) {\n    return function () {\n      select.value = value;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function willValidate(select) {\n  return function () {\n    return select.willValidate;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function validity(select) {\n  return function () {\n    return select.validity;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function validationMessage(select) {\n  return function () {\n    return select.validationMessage;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function checkValidity(select) {\n  return function () {\n    return select.checkValidity();\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function reportValidity(select) {\n  return function () {\n    return select.reportValidity();\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function setCustomValidity(value) {\n  return function (select) {\n    return function () {\n      select.setCustomValidity(value);\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function labels(select) {\n  return function () {\n    return select.labels;\n  };\n}\n", "module Web.HTML.HTMLSelectElement\n  ( HTMLSelectElement\n  , fromHTMLElement\n  , fromElement\n  , fromNode\n  , fromChildNode\n  , fromNonDocumentTypeChildNode\n  , fromParentNode\n  , fromEventTarget\n  , toHTMLElement\n  , toElement\n  , toNode\n  , toChildNode\n  , toNonDocumentTypeChildNode\n  , toParentNode\n  , toEventTarget\n  , autofocus\n  , setAutofocus\n  , disabled\n  , setDisabled\n  , form\n  , multiple\n  , setMultiple\n  , name\n  , setName\n  , required\n  , setRequired\n  , size\n  , setSize\n  , type_\n  , length\n  , setLength\n  , selectedOptions\n  , selectedIndex\n  , setSelectedIndex\n  , value\n  , setValue\n  , willValidate\n  , validity\n  , validationMessage\n  , checkValidity\n  , reportValidity\n  , setCustomValidity\n  , labels\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM (ChildNode, Element, Node, NonDocumentTypeChildNode, ParentNode)\nimport Web.DOM.HTMLCollection (HTMLCollection)\nimport Web.DOM.NodeList (NodeList)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.HTML.HTMLFormElement (HTMLFormElement)\nimport Web.HTML.ValidityState (ValidityState)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nforeign import data HTMLSelectElement :: Type\n\nfromHTMLElement :: HTMLElement -> Maybe HTMLSelectElement\nfromHTMLElement = unsafeReadProtoTagged \"HTMLSelectElement\"\n\nfromElement :: Element -> Maybe HTMLSelectElement\nfromElement = unsafeReadProtoTagged \"HTMLSelectElement\"\n\nfromNode :: Node -> Maybe HTMLSelectElement\nfromNode = unsafeReadProtoTagged \"HTMLSelectElement\"\n\nfromChildNode :: ChildNode -> Maybe HTMLSelectElement\nfromChildNode = unsafeReadProtoTagged \"HTMLSelectElement\"\n\nfromNonDocumentTypeChildNode :: NonDocumentTypeChildNode -> Maybe HTMLSelectElement\nfromNonDocumentTypeChildNode = unsafeReadProtoTagged \"HTMLSelectElement\"\n\nfromParentNode :: ParentNode -> Maybe HTMLSelectElement\nfromParentNode = unsafeReadProtoTagged \"HTMLSelectElement\"\n\nfromEventTarget :: EventTarget -> Maybe HTMLSelectElement\nfromEventTarget = unsafeReadProtoTagged \"HTMLSelectElement\"\n\ntoHTMLElement :: HTMLSelectElement -> HTMLElement\ntoHTMLElement = unsafeCoerce\n\ntoElement :: HTMLSelectElement -> Element\ntoElement = unsafeCoerce\n\ntoNode :: HTMLSelectElement -> Node\ntoNode = unsafeCoerce\n\ntoChildNode :: HTMLSelectElement -> ChildNode\ntoChildNode = unsafeCoerce\n\ntoNonDocumentTypeChildNode :: HTMLSelectElement -> NonDocumentTypeChildNode\ntoNonDocumentTypeChildNode = unsafeCoerce\n\ntoParentNode :: HTMLSelectElement -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoEventTarget :: HTMLSelectElement -> EventTarget\ntoEventTarget = unsafeCoerce\n\nforeign import autofocus :: HTMLSelectElement -> Effect Boolean\nforeign import setAutofocus :: Boolean -> HTMLSelectElement -> Effect Unit\n\nforeign import disabled :: HTMLSelectElement -> Effect Boolean\nforeign import setDisabled :: Boolean -> HTMLSelectElement -> Effect Unit\n\nform :: HTMLSelectElement -> Effect (Maybe HTMLFormElement)\nform = map toMaybe <<< _form\n\nforeign import _form :: HTMLSelectElement -> Effect (Nullable HTMLFormElement)\n\nforeign import multiple :: HTMLSelectElement -> Effect Boolean\nforeign import setMultiple :: Boolean -> HTMLSelectElement -> Effect Unit\n\nforeign import name :: HTMLSelectElement -> Effect String\nforeign import setName :: String -> HTMLSelectElement -> Effect Unit\n\nforeign import required :: HTMLSelectElement -> Effect Boolean\nforeign import setRequired :: Boolean -> HTMLSelectElement -> Effect Unit\n\nforeign import size :: HTMLSelectElement -> Effect Int\nforeign import setSize :: Int -> HTMLSelectElement -> Effect Unit\n\nforeign import type_ :: HTMLSelectElement -> Effect String\n\n--   readonly attribute HTMLOptionsCollection options;\n\nforeign import length :: HTMLSelectElement -> Effect Int\nforeign import setLength :: Int -> HTMLSelectElement -> Effect Unit\n\n--   getter Element? item(unsigned long index);\n--   HTMLOptionElement? namedItem(DOMString name);\n--   void add((HTMLOptionElement or HTMLOptGroupElement) element, optional (HTMLElement or long)? before = null);\n--   void remove(); // ChildNode overload\n--   void remove(long index);\n--   setter creator void (unsigned long index, HTMLOptionElement? option);\n\nforeign import selectedOptions :: HTMLSelectElement -> Effect HTMLCollection\n\nforeign import selectedIndex :: HTMLSelectElement -> Effect Int\nforeign import setSelectedIndex :: Int -> HTMLSelectElement -> Effect Unit\n\nforeign import value :: HTMLSelectElement -> Effect String\nforeign import setValue :: String -> HTMLSelectElement -> Effect Unit\n\nforeign import willValidate :: HTMLSelectElement -> Effect Boolean\n\nforeign import validity :: HTMLSelectElement -> Effect ValidityState\n\nforeign import validationMessage :: HTMLSelectElement -> Effect String\n\nforeign import checkValidity :: HTMLSelectElement -> Effect Boolean\n\nforeign import reportValidity :: HTMLSelectElement -> Effect Boolean\n\nforeign import setCustomValidity :: String -> HTMLSelectElement -> Effect Unit\n\nforeign import labels :: HTMLSelectElement -> Effect NodeList\n", "export function autocomplete(textarea) {\n  return function () {\n    return textarea.autocomplete;\n  };\n}\n\nexport function setAutocomplete(autocomplete) {\n  return function (textarea) {\n    return function () {\n      textarea.autocomplete = autocomplete;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function autofocus(textarea) {\n  return function () {\n    return textarea.autofocus;\n  };\n}\n\nexport function setAutofocus(autofocus) {\n  return function (textarea) {\n    return function () {\n      textarea.autofocus = autofocus;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function cols(textarea) {\n  return function () {\n    return textarea.cols;\n  };\n}\n\nexport function setCols(cols) {\n  return function (textarea) {\n    return function () {\n      textarea.cols = cols;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function dirName(textarea) {\n  return function () {\n    return textarea.dirName;\n  };\n}\n\nexport function setDirName(dirName) {\n  return function (textarea) {\n    return function () {\n      textarea.dirName = dirName;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function disabled(textarea) {\n  return function () {\n    return textarea.disabled;\n  };\n}\n\nexport function setDisabled(disabled) {\n  return function (textarea) {\n    return function () {\n      textarea.disabled = disabled;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function _form(textarea) {\n  return function () {\n    return textarea.form;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function maxLength(textarea) {\n  return function () {\n    return textarea.maxLength;\n  };\n}\n\nexport function setMaxLength(maxLength) {\n  return function (textarea) {\n    return function () {\n      textarea.maxLength = maxLength;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function minLength(textarea) {\n  return function () {\n    return textarea.minLength;\n  };\n}\n\nexport function setMinLength(minLength) {\n  return function (textarea) {\n    return function () {\n      textarea.minLength = minLength;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function name(textarea) {\n  return function () {\n    return textarea.name;\n  };\n}\n\nexport function setName(name) {\n  return function (textarea) {\n    return function () {\n      textarea.name = name;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function placeholder(textarea) {\n  return function () {\n    return textarea.placeholder;\n  };\n}\n\nexport function setPlaceholder(placeholder) {\n  return function (textarea) {\n    return function () {\n      textarea.placeholder = placeholder;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function readOnly(textarea) {\n  return function () {\n    return textarea.readOnly;\n  };\n}\n\nexport function setReadOnly(readOnly) {\n  return function (textarea) {\n    return function () {\n      textarea.readOnly = readOnly;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function required(textarea) {\n  return function () {\n    return textarea.required;\n  };\n}\n\nexport function setRequired(required) {\n  return function (textarea) {\n    return function () {\n      textarea.required = required;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function rows(textarea) {\n  return function () {\n    return textarea.rows;\n  };\n}\n\nexport function setRows(rows) {\n  return function (textarea) {\n    return function () {\n      textarea.rows = rows;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function wrap(textarea) {\n  return function () {\n    return textarea.wrap;\n  };\n}\n\nexport function setWrap(wrap) {\n  return function (textarea) {\n    return function () {\n      textarea.wrap = wrap;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function type_(textarea) {\n  return function () {\n    return textarea.type;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function defaultValue(textarea) {\n  return function () {\n    return textarea.defaultValue;\n  };\n}\n\nexport function setDefaultValue(defaultValue) {\n  return function (textarea) {\n    return function () {\n      textarea.defaultValue = defaultValue;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function value(textarea) {\n  return function () {\n    return textarea.value;\n  };\n}\n\nexport function setValue(value) {\n  return function (textarea) {\n    return function () {\n      textarea.value = value;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function textLength(textarea) {\n  return function () {\n    return textarea.textLength;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function willValidate(textarea) {\n  return function () {\n    return textarea.willValidate;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function validity(textarea) {\n  return function () {\n    return textarea.validity;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function validationMessage(textarea) {\n  return function () {\n    return textarea.validationMessage;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function checkValidity(textarea) {\n  return function () {\n    return textarea.checkValidity();\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function reportValidity(textarea) {\n  return function () {\n    return textarea.reportValidity();\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function setCustomValidity(value) {\n  return function (textarea) {\n    return function () {\n      textarea.setCustomValidity(value);\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function labels(textarea) {\n  return function () {\n    return textarea.labels;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function select(textarea) {\n  return function () {\n    textarea.select();\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function selectionStart(textarea) {\n  return function () {\n    return textarea.selectionStart;\n  };\n}\n\nexport function setSelectionStart(selectionStart) {\n  return function (textarea) {\n    return function () {\n      textarea.selectionStart = selectionStart;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function selectionEnd(textarea) {\n  return function () {\n    return textarea.selectionEnd;\n  };\n}\n\nexport function setSelectionEnd(selectionEnd) {\n  return function (textarea) {\n    return function () {\n      textarea.selectionEnd = selectionEnd;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function selectionDirection(textarea) {\n  return function () {\n    return textarea.selectionDirection;\n  };\n}\n\nexport function setSelectionDirection(selectionDirection) {\n  return function (textarea) {\n    return function () {\n      textarea.selectionDirection = selectionDirection;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function setRangeText(replacement) {\n  return function (textarea) {\n    return function () {\n      textarea.setRangeText(replacement);\n    };\n  };\n}\n\nexport function _setRangeText(replacement, start, end, selectionMode, textarea) {\n  textarea.setRangeText(replacement, start, end, selectionMode);\n}\n\n// ----------------------------------------------------------------------------\n\nexport function setSelectionRange(start) {\n  return function (end) {\n    return function (direction) {\n      return function (textarea) {\n        return function () {\n          textarea.setSelectionRange(start, end, direction);\n        };\n      };\n    };\n  };\n}\n", "module Web.HTML.HTMLTextAreaElement\n  ( HTMLTextAreaElement\n  , fromHTMLElement\n  , fromElement\n  , fromNode\n  , fromChildNode\n  , fromNonDocumentTypeChildNode\n  , fromParentNode\n  , fromEventTarget\n  , toHTMLElement\n  , toElement\n  , toNode\n  , toChildNode\n  , toNonDocumentTypeChildNode\n  , toParentNode\n  , toEventTarget\n  , autocomplete\n  , setAutocomplete\n  , autofocus\n  , setAutofocus\n  , cols\n  , setCols\n  , dirName\n  , setDirName\n  , disabled\n  , setDisabled\n  , form\n  , maxLength\n  , setMaxLength\n  , minLength\n  , setMinLength\n  , name\n  , setName\n  , placeholder\n  , setPlaceholder\n  , readOnly\n  , setReadOnly\n  , required\n  , setRequired\n  , rows\n  , setRows\n  , wrap\n  , setWrap\n  , type_\n  , defaultValue\n  , setDefaultValue\n  , value\n  , setValue\n  , textLength\n  , willValidate\n  , validity\n  , validationMessage\n  , checkValidity\n  , reportValidity\n  , setCustomValidity\n  , labels\n  , select\n  , selectionStart\n  , setSelectionStart\n  , selectionEnd\n  , setSelectionEnd\n  , selectionDirection\n  , setSelectionDirection\n  , setRangeText\n  , setRangeText'\n  , setSelectionRange\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Effect.Uncurried (EffectFn5, runEffectFn5)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM (ChildNode, Element, Node, NonDocumentTypeChildNode, ParentNode)\nimport Web.DOM.NodeList (NodeList)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.HTML.HTMLFormElement (HTMLFormElement)\nimport Web.HTML.SelectionMode (SelectionMode)\nimport Web.HTML.SelectionMode as SelectionMode\nimport Web.HTML.ValidityState (ValidityState)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nforeign import data HTMLTextAreaElement :: Type\n\nfromHTMLElement :: HTMLElement -> Maybe HTMLTextAreaElement\nfromHTMLElement = unsafeReadProtoTagged \"HTMLTextAreaElement\"\n\nfromElement :: Element -> Maybe HTMLTextAreaElement\nfromElement = unsafeReadProtoTagged \"HTMLTextAreaElement\"\n\nfromNode :: Node -> Maybe HTMLTextAreaElement\nfromNode = unsafeReadProtoTagged \"HTMLTextAreaElement\"\n\nfromChildNode :: ChildNode -> Maybe HTMLTextAreaElement\nfromChildNode = unsafeReadProtoTagged \"HTMLTextAreaElement\"\n\nfromNonDocumentTypeChildNode :: NonDocumentTypeChildNode -> Maybe HTMLTextAreaElement\nfromNonDocumentTypeChildNode = unsafeReadProtoTagged \"HTMLTextAreaElement\"\n\nfromParentNode :: ParentNode -> Maybe HTMLTextAreaElement\nfromParentNode = unsafeReadProtoTagged \"HTMLTextAreaElement\"\n\nfromEventTarget :: EventTarget -> Maybe HTMLTextAreaElement\nfromEventTarget = unsafeReadProtoTagged \"HTMLTextAreaElement\"\n\ntoHTMLElement :: HTMLTextAreaElement -> HTMLElement\ntoHTMLElement = unsafeCoerce\n\ntoElement :: HTMLTextAreaElement -> Element\ntoElement = unsafeCoerce\n\ntoNode :: HTMLTextAreaElement -> Node\ntoNode = unsafeCoerce\n\ntoChildNode :: HTMLTextAreaElement -> ChildNode\ntoChildNode = unsafeCoerce\n\ntoNonDocumentTypeChildNode :: HTMLTextAreaElement -> NonDocumentTypeChildNode\ntoNonDocumentTypeChildNode = unsafeCoerce\n\ntoParentNode :: HTMLTextAreaElement -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoEventTarget :: HTMLTextAreaElement -> EventTarget\ntoEventTarget = unsafeCoerce\n\nforeign import autocomplete :: HTMLTextAreaElement -> Effect String\nforeign import setAutocomplete :: String -> HTMLTextAreaElement -> Effect Unit\n\nforeign import autofocus :: HTMLTextAreaElement -> Effect Boolean\nforeign import setAutofocus :: Boolean -> HTMLTextAreaElement -> Effect Unit\n\nforeign import cols :: HTMLTextAreaElement -> Effect Int\nforeign import setCols :: Int -> HTMLTextAreaElement -> Effect Unit\n\nforeign import dirName :: HTMLTextAreaElement -> Effect String\nforeign import setDirName :: String -> HTMLTextAreaElement -> Effect Unit\n\nforeign import disabled :: HTMLTextAreaElement -> Effect Boolean\nforeign import setDisabled :: Boolean -> HTMLTextAreaElement -> Effect Unit\n\nform :: HTMLTextAreaElement -> Effect (Maybe HTMLFormElement)\nform = map toMaybe <<< _form\n\nforeign import _form :: HTMLTextAreaElement -> Effect (Nullable HTMLFormElement)\n\nforeign import maxLength :: HTMLTextAreaElement -> Effect Int\nforeign import setMaxLength :: Int -> HTMLTextAreaElement -> Effect Unit\n\nforeign import minLength :: HTMLTextAreaElement -> Effect Int\nforeign import setMinLength :: Int -> HTMLTextAreaElement -> Effect Unit\n\nforeign import name :: HTMLTextAreaElement -> Effect String\nforeign import setName :: String -> HTMLTextAreaElement -> Effect Unit\n\nforeign import placeholder :: HTMLTextAreaElement -> Effect String\nforeign import setPlaceholder :: String -> HTMLTextAreaElement -> Effect Unit\n\nforeign import readOnly :: HTMLTextAreaElement -> Effect Boolean\nforeign import setReadOnly :: Boolean -> HTMLTextAreaElement -> Effect Unit\n\nforeign import required :: HTMLTextAreaElement -> Effect Boolean\nforeign import setRequired :: Boolean -> HTMLTextAreaElement -> Effect Unit\n\nforeign import rows :: HTMLTextAreaElement -> Effect Int\nforeign import setRows :: Int -> HTMLTextAreaElement -> Effect Unit\n\nforeign import wrap :: HTMLTextAreaElement -> Effect String\nforeign import setWrap :: String -> HTMLTextAreaElement -> Effect Unit\n\nforeign import type_ :: HTMLTextAreaElement -> Effect String\n\nforeign import defaultValue :: HTMLTextAreaElement -> Effect String\nforeign import setDefaultValue :: String -> HTMLTextAreaElement -> Effect Unit\n\nforeign import value :: HTMLTextAreaElement -> Effect String\nforeign import setValue :: String -> HTMLTextAreaElement -> Effect Unit\n\nforeign import textLength :: HTMLTextAreaElement -> Effect Int\n\nforeign import willValidate :: HTMLTextAreaElement -> Effect Boolean\n\nforeign import validity :: HTMLTextAreaElement -> Effect ValidityState\n\nforeign import validationMessage :: HTMLTextAreaElement -> Effect String\n\nforeign import checkValidity :: HTMLTextAreaElement -> Effect Boolean\n\nforeign import reportValidity :: HTMLTextAreaElement -> Effect Boolean\n\nforeign import setCustomValidity :: String -> HTMLTextAreaElement -> Effect Unit\n\nforeign import labels :: HTMLTextAreaElement -> Effect NodeList\n\nforeign import select :: HTMLTextAreaElement -> Effect Unit\n\nforeign import selectionStart :: HTMLTextAreaElement -> Effect Int\nforeign import setSelectionStart :: Int -> HTMLTextAreaElement -> Effect Unit\n\nforeign import selectionEnd :: HTMLTextAreaElement -> Effect Int\nforeign import setSelectionEnd :: Int -> HTMLTextAreaElement -> Effect Unit\n\nforeign import selectionDirection :: HTMLTextAreaElement -> Effect String\nforeign import setSelectionDirection :: String -> HTMLTextAreaElement -> Effect Unit\n\nforeign import setRangeText :: String -> HTMLTextAreaElement -> Effect Unit\n\nsetRangeText' :: String -> Int -> Int -> SelectionMode -> HTMLTextAreaElement -> Effect Unit\nsetRangeText' rpl s e mode area =\n  runEffectFn5 _setRangeText rpl s e (SelectionMode.print mode) area\n\nforeign import _setRangeText :: EffectFn5 String Int Int String HTMLTextAreaElement Unit\n\nforeign import setSelectionRange :: Int -> Int -> String -> HTMLTextAreaElement -> Effect Unit\n", "export function document(window) {\n  return function () {\n    return window.document;\n  };\n}\n\nexport function navigator(window) {\n  return function () {\n    return window.navigator;\n  };\n}\n\nexport function location(window) {\n  return function () {\n    return window.location;\n  };\n}\n\nexport function history(window) {\n  return function() {\n    return window.history;\n  };\n}\n\nexport function innerWidth(window) {\n  return function () {\n    return window.innerWidth;\n  };\n}\n\nexport function innerHeight(window) {\n  return function () {\n    return window.innerHeight;\n  };\n}\n\nexport function alert(str) {\n  return function (window) {\n    return function () {\n      window.alert(str);\n    };\n  };\n}\n\nexport function confirm(str) {\n  return function (window) {\n    return function () {\n      return window.confirm(str);\n    };\n  };\n}\n\nexport function moveBy(xDelta) {\n  return function (yDelta) {\n    return function (window) {\n      return function () {\n        window.moveBy(xDelta, yDelta);\n      };\n    };\n  };\n}\n\nexport function moveTo(width) {\n  return function (height) {\n    return function (window) {\n      return function () {\n        window.moveTo(width, height);\n      };\n    };\n  };\n}\n\nexport function _open(url) {\n  return function (name) {\n    return function (features) {\n      return function (window) {\n        return function () {\n          return window.open(url, name, features);\n        };\n      };\n    };\n  };\n}\n\nexport function close(window) {\n  return function () {\n    return window.close();\n  };\n}\n\nexport function outerHeight(window) {\n  return function () {\n    return window.outerHeight;\n  };\n}\n\nexport function outerWidth(window) {\n  return function () {\n    return window.outerWidth;\n  };\n}\n\nexport function print(window) {\n  return function () {\n    window.print();\n  };\n}\n\nexport function _prompt(str) {\n  return function (defaultText) {\n    return function (window) {\n      return function () {\n        return window.prompt(str, defaultText);\n      };\n    };\n  };\n}\n\nexport function resizeBy(xDelta) {\n  return function (yDelta) {\n    return function (window) {\n      return function () {\n        window.resizeBy(xDelta, yDelta);\n      };\n    };\n  };\n}\n\nexport function resizeTo(width) {\n  return function (height) {\n    return function (window) {\n      return function () {\n        window.resizeTo(width, height);\n      };\n    };\n  };\n}\n\nexport function screenX(window) {\n  return function () {\n    return window.screenX;\n  };\n}\n\nexport function screenY(window) {\n  return function () {\n    return window.screenY;\n  };\n}\n\nexport function scroll(xCoord) {\n  return function (yCoord) {\n    return function (window) {\n      return function () {\n        window.scroll(xCoord, yCoord);\n      };\n    };\n  };\n}\n\nexport function scrollBy(xCoord) {\n  return function (yCoord) {\n    return function (window) {\n      return function () {\n        window.scrollBy(xCoord, yCoord);\n      };\n    };\n  };\n}\n\nexport function scrollX(window) {\n  return function () {\n    return window.scrollX;\n  };\n}\n\nexport function scrollY(window) {\n  return function () {\n    return window.scrollY;\n  };\n}\n\nexport function localStorage(window) {\n  return function () {\n    return window.localStorage;\n  };\n}\n\nexport function sessionStorage(window) {\n  return function () {\n    return window.sessionStorage;\n  };\n}\n\nexport function requestAnimationFrame(fn) {\n  return function(window) {\n    return function() {\n      return window.requestAnimationFrame(fn);\n    };\n  };\n}\n\nexport function cancelAnimationFrame(id) {\n  return function(window) {\n    return function() {\n      return window.cancelAnimationFrame(id);\n    };\n  };\n}\n\nexport function requestIdleCallback(opts) {\n  return function(fn) {\n    return function(window) {\n      return function() {\n        return window.requestIdleCallback(fn, opts);\n      };\n    };\n  };\n}\n\nexport function cancelIdleCallback(id) {\n  return function(window) {\n    return function() {\n      return window.cancelIdleCallback(id);\n    };\n  };\n}\n\nexport function parent(window) {\n  return function() {\n    return window.parent;\n  };\n}\n\nexport function _opener(window) {\n  return function() {\n    return window.opener;\n  };\n}\n", "module FRP.Poll.Unoptimized\n  ( APoll\n  , Poll\n  , animate\n  , class Pollable\n  , create\n  , createPure\n  , createTagged\n  , deflect\n  , derivative\n  , derivative'\n  , dredge\n  , fixB\n  , gate\n  , gateBy\n  , integral\n  , integral'\n  , listen_\n  , mailbox\n  , mailboxS\n  , merge\n  , mergeMap\n  , poll\n  , rant\n  , sample\n  , sampleBy\n  , sample_\n  , sham\n  , solve\n  , solve'\n  , solve2\n  , solve2'\n  , stRefToPoll\n  , stToPoll\n  , step\n  , switcher\n  , unfold\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt, alt)\nimport Control.Apply (lift2)\nimport Control.Monad.ST.Class (liftST)\nimport Control.Monad.ST.Global (Global)\nimport Control.Monad.ST.Internal (ST)\nimport Control.Monad.ST.Internal as STRef\nimport Control.Plus (class Plus, empty)\nimport Control.Semigroupoid (composeFlipped)\nimport Data.Array as Array\nimport Data.Either (Either, either)\nimport Data.Filterable (eitherBool, maybeBool)\nimport Data.Filterable as Filterable\nimport Data.Foldable (oneOf)\nimport Data.Function (applyFlipped)\nimport Data.FunctorWithIndex (class FunctorWithIndex)\nimport Data.HeytingAlgebra (ff, implies, tt)\nimport Data.Maybe (Maybe(..))\nimport Data.Tuple (Tuple(..), fst)\nimport Effect (Effect)\nimport FRP.Event (class IsEvent, Event, EventfulProgram, ProgramfulEvent, fold, justManyM, justNone, justOne, justOneM, makeEvent, subscribe, withLast)\nimport FRP.Event as Event\nimport FRP.Event.AnimationFrame (animationFrame)\nimport FRP.Event.Class as EClass\n\n-- | `APoll` is the more general type of `Poll`, which is parameterized\n-- | over some underlying `event` type.\n-- |\n-- | Normally, you should use `Poll` instead, but this type\n-- | can also be used with other types of events, including the ones in the\n-- | `Semantic` module.\nnewtype APoll event a = APoll (forall r. event (a -> r) -> event r)\n\n-- | A `Poll` acts like a survey or poll. We get a series of questions in time\n-- | of form `a -> r`, and we respond with `r`.\n-- |\n-- | We can construct a `Poll` from some `Event`, combine `Poll`s\n-- | using `Applicative`, and sample a final `Poll` on some other `Event`.\n-- |\n-- | Very similar to Yoneda `newtype Yoneda f a = Yoneda (forall b. (a -> r) -> f r)`.\n-- | Yoneda lemma tells that `(a -> r) -> r` is same as having just `a`\n-- | and `(a -> r) -> f r` is same as having just `f a`.\ntype Poll = APoll Event\n\ninstance functorAPoll :: Functor event => Functor (APoll event) where\n  map f (APoll b) = APoll \\e -> b (map (_ <<< f) e)\n\ninstance functorWithIndexAPoll :: (IsEvent event, Pollable event event) => FunctorWithIndex Int (APoll event) where\n  mapWithIndex f e = EClass.mapAccum (\\a b -> Tuple (a + 1) (f a b)) 0 e\n\ninstance applyAPoll :: Apply event => Apply (APoll event) where\n  apply (APoll f) (APoll a) = APoll \\e -> (map (\\ff (Tuple bc aaa) -> bc (ff aaa)) (f (e $> identity))) <*> a (map Tuple e)\n\n-- Intuitively works like a highly dense infinite stream\n-- `List (Cow, Time) = [ (C1,0), (C1,1), ... ]`\n--\n-- will repeat for each push\n--\n-- ```purescript\n-- data Cow = C1 | C2\n-- test = do\n--   surveymonger <- liftST $ createPure -- List (Cow -> MichlenStars, Time)\n--   let\n--     (whoWantsToAnswer :: Poll Cow) = pure C1 <|> pure C2 -- will give to callback both immediately, on ofter another\n--     (answers :: Event Int) = sample whoWantsToAnswer surveymonger.event\n--   _ <- subscribe answers \\v ->  log $ \"answers GOT \" <> show v\n--   surveymonger.push(...)\n-- ```\n--\n-- push to `surveymonger` | C1->1       C1->11\n--                        | C2->2       C2->12\n-- get in `answers`       | 1      2    11      12\ninstance applicativeAPoll :: Apply event => Applicative (APoll event) where\n  pure a = APoll \\e -> applyFlipped a <$> e\n\ninstance semigroupAPoll :: (Apply event, Semigroup a) => Semigroup (APoll event a) where\n  append = lift2 append\n\ninstance monoidAPoll :: (Apply event, Monoid a) => Monoid (APoll event a) where\n  mempty = pure mempty\n\ninstance heytingAlgebraAPoll :: (Apply event, HeytingAlgebra a) => HeytingAlgebra (APoll event a) where\n  tt = pure tt\n  ff = pure ff\n  not = map not\n  implies = lift2 implies\n  conj = lift2 conj\n  disj = lift2 disj\n\ninstance semiringAPoll :: (Apply event, Semiring a) => Semiring (APoll event a) where\n  zero = pure zero\n  one = pure one\n  add = lift2 add\n  mul = lift2 mul\n\ninstance ringAPoll :: (Apply event, Ring a) => Ring (APoll event a) where\n  sub = lift2 sub\n\n-- | Construct a `Poll` from its sampling function.\npoll :: forall event a. (forall r. event (a -> r) -> event r) -> APoll event a\npoll = APoll\n\n-- | Create a `Poll` which is updated when an `Event` fires, by providing\n-- | an initial value.\n-- |\n-- | ```\n-- | push to `cowSupplier`                              |                   C2\n-- | push to `surveymonger`                             | C1->1   C1->11          C1->21\n-- |                                                    | C2->2   C2->12          C2->22\n-- |                                                    | C3->3   C3->13          C3->23\n-- | get in `sample (step C1 cowSupplier) surveymonger` | 1       11        _     22\n-- | ```\nstep :: forall event a. IsEvent event => a -> event a -> APoll event a\nstep a e = APoll (\\e0 -> EClass.sampleOnRight ((EClass.once e0 $> a) `alt` e) e0)\n\n-- | Create a `Poll` which is updated when an `Event` fires, by providing\n-- | an initial value and a function to combine the current value with a new event\n-- | to create a new value.\nunfold :: forall event a b. IsEvent event => (b -> a -> b) -> b -> event a -> APoll event b\nunfold f a e = step a (fold f a e)\n\ninstance Alt event => Alt (APoll event) where\n  alt (APoll a) (APoll b) = APoll \\e -> a e `alt` b e\n\ninstance Plus event => Plus (APoll event) where\n  empty = APoll \\_ -> empty\n\n-- | Merge together several polls. This has the same functionality\n-- | as `oneOf`, but it is faster and less prone to stack explosions.\nmerge :: forall a. Array (Poll a) \u2192 Poll a\nmerge a = APoll \\e -> Event.mergeMap (flip sample e) a\n\nmergeMap :: forall a b. (a -> Poll b) -> Array a \u2192 Poll b\nmergeMap f a = APoll \\e -> Event.mergeMap (flip sample e <<< f) a\n\n-- | A poll where the answers are rigged (influenced/given by) by the nefarious `Event a`\n-- | `sham` (fake) because \"poll is not fair, because it is controlled by an event\"\n-- |\n-- | # Example\n-- |\n-- | ```purescript\n-- | data Cow = C1 | C2 | C3\n-- | test = do\n-- |   cowSupplier <- liftST $ create -- List (Cow, Time)\n-- |   surveymonger <- liftST $ create -- List (Cow -> MichlenStars, Time)\n-- |   let\n-- |     (whoWantsToAnswer :: Poll Cow) = sham cowSupplier.event\n-- |     (answers :: Event Int) = sample whoWantsToAnswer surveymonger.event\n-- |   _ <- subscribe answers \\v ->  log $ \"answers GOT \" <> show v\n-- |   cowSupplier.push(...)\n-- |   surveymonger.push(...)\n-- | ```\n-- |\n-- | ```\n-- | push to `cowSupplier`                           |                   C1             C2\n-- | push to `surveymonger`                          | C1->1   C1->11          C1->21\n-- |                                                 | C2->2   C2->12          C2->22\n-- |                                                 | C3->3   C3->13          C3->23\n-- | get in `sample (sham cowSupplier) surveymonger` | _       _         11    _        22\n-- | ```\n-- |\n-- | or\n-- |\n-- | ```\n-- | push to `cowSupplier`                           | C1                      C2             C3\n-- | push to `surveymonger`                          |       C1->1   C1->11          C1->21\n-- |                                                 |       C2->2   C2->12          C2->22\n-- |                                                 |       C3->3   C3->13          C3->23\n-- | get in `sample (sham cowSupplier) surveymonger` | _     _       _         12    _        23\n-- | ```\n-- |\n-- | # If sham is listening for sham\n-- |\n-- | Eta expansion\n-- |\n-- | ```\n-- | x :: Event Int\n-- | x = sample_ (sham event1) event1\n-- | x = sample (map const $ sham event1) (map applyFlipped event1)\n-- | x = sample (map const $ APoll \\e -> EClass.sampleOnLeft event1 e) (map applyFlipped event1)\n-- | x = EClass.sampleOnLeft event1 (map (_ <<< const) (map applyFlipped event1))\n-- | x = EClass.sampleOnLeft event1 (map (const identity) event1 :: Event (Int -> Int))\n-- | ```\n-- |\n-- | Result\n-- |\n-- | ```\n-- | push to `event1`                      | 1     2     3\n-- | get in `sample_ (sham event1) event1` | _     2     3\n-- | ```\nsham :: forall event. IsEvent event => event ~> APoll event\nsham i = poll \\e -> EClass.sampleOnLeft i e\n\n-- | Turn a function over events into a function over polls.\ndredge :: forall a b event. Apply event => (event a -> event b) -> APoll event a -> APoll event b\ndredge f (APoll ea) = APoll \\eb -> eb <*> f (ea (eb $> identity))\n\nclass Pollable event pollable | pollable -> event where\n  -- | Sample a `Poll` on some `Event`.\n  sample :: forall a r. APoll event a -> pollable (a -> r) -> pollable r\n\n-- `sample poll poll = sampleOnRight poll poll`\n-- `sample poll event = poll event`\ninstance (IsEvent event, Pollable event event) => Pollable event (APoll event) where\n  sample = EClass.sampleOnRight\nelse instance IsEvent event => Pollable event event where\n  sample (APoll a) ab = a ab\n\n-- | Sample a `Poll` on some `Event` by providing a combining function.\nsampleBy :: forall event pollable a b c. Pollable event pollable => Functor event => Functor pollable => (a -> b -> c) -> APoll event a -> pollable b -> pollable c\nsampleBy f apollA pollableB = sample (map f apollA :: APoll event (b -> c)) (map applyFlipped pollableB :: pollable ((b -> c) -> c))\n\n-- | Sample a `Poll` on some `Event`, discarding the event's values.\nsample_ :: forall event pollable a b. Pollable event pollable => Functor event => Functor pollable => APoll event a -> pollable b -> pollable a\nsample_ = (sampleBy :: (a -> b -> a) -> APoll event a -> pollable b -> pollable a) const\n\n-- | Switch `Poll`s based on an `Event`.\n-- |\n-- | ```purescript\n-- | data Cow = C1 | C2\n-- | data Horse = H1 | H2\n-- | type Animals = Either Horse Cow\n-- | test = do\n-- |   pollSupplier <- liftST $ createPure\n-- |   surveymonger <- liftST $ createPure\n-- |   let\n-- |     (onlyCowsAnswer :: Poll Animals) = pure (Right C1) <|> pure (Right C2)\n-- |     (onlyHorsesAnswer :: Poll Animals) = pure (Left H1) <|> pure (Left H2)\n-- |     (whoWantsToAnswer :: Poll Animals) = switcher onlyCowsAnswer pollSupplier.event\n-- |     (answers :: Event Int) = sample whoWantsToAnswer surveymonger.event\n-- |   _ <- subscribe answers \\v -> do log $ \"answers GOT \" <> show v\n-- |   surveymonger.push(...)\n-- |   pollSupplier.push(...)\n-- | ```\n-- |\n-- | ```\n-- | push to `pollSupplier` |                         onlyHorsesAnswer\n-- | push to `surveymonger` | C1->1     C1->11                             C1->21\n-- |                        | C2->2     C2->12                             C2->22\n-- |                        | H1->3     H1->13                             H1->23\n-- |                        | H2->4     H2->14                             H2->24\n-- | get in `answers`       | 1     2   11      12    _                    23       24\n-- | ```\nswitcher :: forall event a. Pollable event event => IsEvent event => APoll event a -> event (APoll event a) -> APoll event a\nswitcher initialPoll e = poll \\s ->\n  EClass.keepLatest ((EClass.once s $> (sample initialPoll s)) `alt` map (\\p -> sample p s) e)\n\n-- | Sample a `Poll` on some `Event` by providing a predicate function.\ngateBy :: forall event p a. Pollable event event => Filterable.Filterable event => (p -> a -> Boolean) -> APoll event p -> event a -> event a\ngateBy f ps xs = Filterable.compact (sampleBy (\\p x -> if f p x then Just x else Nothing) ps xs)\n\n-- | Filter an `Event` by the boolean value of a `Poll`.\ngate :: forall event a. Pollable event event => Filterable.Filterable event => APoll event Boolean -> event a -> event a\ngate = gateBy const\n\n-- | Integrate with respect to some measure of time.\n-- |\n-- | This function approximates the integral using the trapezium rule at the\n-- | implicit sampling interval.\n-- |\n-- | The `Semiring` `a` should be a vector field over the field `t`. To represent\n-- | this, the user should provide a _grate_ which lifts a multiplication\n-- | function on `t` to a function on `a`. Simple examples where `t ~ a` can use\n-- | the `integral'` function instead.\nintegral\n  :: forall event a t\n   . IsEvent event\n  => Pollable event event\n  => Field t\n  => Semiring a\n  => (((a -> t) -> t) -> a)\n  -> a\n  -> APoll event t\n  -> APoll event a\n  -> APoll event a\nintegral g initial pollT pollA =\n  APoll \\e ->\n    let\n      x = sample pollA (e $> identity)\n      y = withLast (sampleBy Tuple pollT x)\n      z = fold approx initial y\n    in\n      EClass.sampleOnRight z e\n  where\n  approx s { last: Nothing } = s\n  approx s { now: Tuple t1 a1, last: Just (Tuple t0 a0) } = s + g (\\f -> f (a0 + a1) * (t1 - t0) / two)\n\n  two :: t\n  two = one + one\n\n-- | Integrate with respect to some measure of time.\n-- |\n-- | This function is a simpler version of `integral` where the function being\n-- | integrated takes values in the same field used to represent time.\n-- |\n-- | ```purescript\n-- | test = do\n-- |   timeSupplier <- liftST $ createPure\n-- |   heightSupplier <- liftST $ createPure\n-- |   surveymonger <- liftST $ createPure\n-- |   let\n-- |     (area :: Poll Number) = integral' 0.0 (step 10.0 timeSupplier.event) (step 100.0 heightSupplier.event)\n-- |     (answers :: Event Int) = sample area surveymonger.event\n-- |   _ <- subscribe answers \\v -> do log $ \"answers GOT \" <> show v\n-- |   timeSupplier.push(...)\n-- |   heightSupplier.push(...)\n-- | ```\n-- |\n-- | ```\n-- | push to `surveymonger`   | show         show           show            show          show\n-- | push to `timeSupplier`   |        11.0         13.0                           14.0\n-- | push to `heightSupplier` |                                       1.0\n-- | get in `answers`         | \"0.0\"        \"100.0\"        \"300.0\"         \"300.0\"       \"301.0\"\n-- | ```\n-- |\n-- | ```purescript\n-- | (area :: Poll Number) = integral' 0.0 (sham timeSupplier.event) (sham heightSupplier.event)\n-- | ```\n-- |\n-- | ```\n-- | push to `surveymonger`   | show         show        show          show   show         show\n-- | push to `timeSupplier`   |        1.0                      2.0                  3.0\n-- | push to `heightSupplier` |                    1.0\n-- | get in `answers`         |                                        \"0.0\"  \"0.0\"        \"1.0\"\n-- | ```\nintegral'\n  :: forall event t\n   . IsEvent event\n  => Pollable event event\n  => Field t\n  => t\n  -> APoll event t\n  -> APoll event t\n  -> APoll event t\nintegral' = integral (_ $ identity)\n\n-- | Differentiate with respect to some measure of time.\n-- |\n-- | This function approximates the derivative using a quotient of differences at the\n-- | implicit sampling interval.\n-- |\n-- | The `Semiring` `a` should be a vector field over the field `t`. To represent\n-- | this, the user should provide a grate which lifts a division\n-- | function on `t` to a function on `a`. Simple examples where `t ~ a` can use\n-- | the `derivative'` function.\nderivative\n  :: forall event a t\n   . IsEvent event\n  => Pollable event event\n  => Field t\n  => Ring a\n  => (((a -> t) -> t) -> a)\n  -> APoll event t\n  -> APoll event a\n  -> APoll event a\nderivative g pollT pollA =\n  APoll \\e ->\n    let\n      x = sample pollA (e $> identity)\n      y = withLast (sampleBy Tuple pollT x)\n      z = map approx y\n    in\n      EClass.sampleOnRight z e\n  where\n  approx { last: Nothing } = zero\n  approx { now: Tuple t1 a1, last: Just (Tuple t0 a0) } = g (\\f -> f (a1 - a0) / (t1 - t0))\n\n-- | Differentiate with respect to some measure of time.\n-- |\n-- | This function is a simpler version of `derivative` where the function being\n-- | differentiated takes values in the same field used to represent time.\nderivative'\n  :: forall event t\n   . IsEvent event\n  => Pollable event event\n  => Field t\n  => APoll event t\n  -> APoll event t\n  -> APoll event t\nderivative' = derivative (_ $ identity)\n\n-- | Solve a first order differential equation of the form\n-- |\n-- | ```\n-- | da/dt = f a\n-- | ```\n-- |\n-- | by integrating once (specifying the initial conditions).\n-- |\n-- | For example, the exponential function with growth rate `\u237A`:\n-- |\n-- | ```purescript\n-- | exp = solve' 1.0 Time.seconds (\u237A * _)\n-- | ```\nsolve\n  :: forall t a\n   . Field t\n  => Semiring a\n  => (((a -> t) -> t) -> a)\n  -> a\n  -> Poll t\n  -> (Poll a -> Poll a)\n  -> Poll a\nsolve g a0 pollT f = fixB a0 \\pollA -> integral g a0 pollT (f pollA)\n\n-- | Solve a first order differential equation.\n-- |\n-- | This function is a simpler version of `solve` where the function being\n-- | integrated takes values in the same field used to represent time.\nsolve'\n  :: forall a\n   . Field a\n  => a\n  -> Poll a\n  -> (Poll a -> Poll a)\n  -> Poll a\nsolve' = solve (_ $ identity)\n\n-- | Solve a second order differential equation of the form\n-- |\n-- | ```\n-- | d^2a/dt^2 = f a (da/dt)\n-- | ```\n-- |\n-- | by integrating twice (specifying the initial conditions).\n-- |\n-- | For example, an (damped) oscillator:\n-- |\n-- | ```purescript\n-- | oscillate = solve2' 1.0 0.0 Time.seconds (\\x dx -> -\u237A * x - \u03B4 * dx)\n-- | ```\nsolve2\n  :: forall t a\n   . Field t\n  => Semiring a\n  => (((a -> t) -> t) -> a)\n  -> a\n  -> a\n  -> Poll t\n  -> (Poll a -> Poll a -> Poll a)\n  -> Poll a\nsolve2 g a0 da0 pollT f =\n  fixB a0 \\pollA ->\n    integral g a0 pollT\n      ( fixB da0 \\pollDa ->\n          integral g da0 pollT (f pollA pollDa)\n      )\n\n-- | Solve a second order differential equation.\n-- |\n-- | This function is a simpler version of `solve2` where the function being\n-- | integrated takes values in the same field used to represent time.\nsolve2'\n  :: forall a\n   . Field a\n  => a\n  -> a\n  -> Poll a\n  -> (Poll a -> Poll a -> Poll a)\n  -> Poll a\nsolve2' = solve2 (_ $ identity)\n\n-- | Animate a `Poll` by providing a rendering function.\nanimate\n  :: forall scene\n   . Poll scene\n  -> (scene -> Effect Unit)\n  -> Effect (Effect Unit)\nanimate scenePoll render = do\n  { event, unsubscribe } <- animationFrame\n  u2 <- subscribe (sample_ scenePoll event) render\n  pure do\n    unsubscribe\n    u2\n\n-- | Turn an ST Ref into a poll\nstRefToPoll :: STRef.STRef Global ~> Poll\nstRefToPoll r = do\n  poll \\e -> makeEvent \\s -> s e \\f -> justOneM do\n    i <- STRef.read r\n    pure (f i)\n\n-- | Turn an ST Global into a poll\nstToPoll :: ST Global ~> Poll\nstToPoll r = do\n  poll \\e -> makeEvent \\s -> s e \\f -> justOneM do\n    i <- r\n    pure (f i)\n\nfilterMap\n  :: forall event a b\n   . Filterable.Compactable event\n  => Pollable event event\n  => Functor event\n  => (a -> Maybe b)\n  -> APoll event a\n  -> APoll event b\nfilterMap f pollA = poll \\e -> Filterable.compact\n  $ sampleBy (\\a ff -> map ff $ f a) pollA e\n\npartitionMap :: forall event a b c. Pollable event event => Filterable.Compactable event => Functor event => (a -> Either b c) -> APoll event a -> { left :: APoll event b, right :: APoll event c }\npartitionMap f pollA = { left: filterMap (either Just (const Nothing)) fb, right: filterMap (either (const Nothing) Just) fb }\n  where\n  fb = f <$> pollA\n\ninstance (Functor event, Filterable.Compactable event, Pollable event event) => Filterable.Compactable (APoll event) where\n  compact = filterMap identity\n  separate = partitionMap identity\n\ninstance (Functor event, Filterable.Compactable event, Pollable event event) => Filterable.Filterable (APoll event) where\n  filterMap = filterMap\n  filter = filterMap <<< maybeBool\n  partitionMap = partitionMap\n  partition p xs = do\n    let o = partitionMap (eitherBool p) xs\n    { no: o.left, yes: o.right }\n\n-- |\n-- | # sampleOnRight + pure\n-- |\n-- | ```purescript\n-- | (pollCows :: Poll String) = pure \"C1\" <|> pure \"C2\"\n-- | (pollCowToOwner :: Poll (String -> String)) = pure (_ <> \"_foo\") <|> pure (_ <> \"_bar\")\n-- | ```\n-- |\n-- | ```\n-- | push to `surveymonger`                         | (_<>\"--1\")                     (_<>\"--2\")                                            (_<>\"--3\")\n-- | get in `sampleOnRight pollCows pollCowToOwner` | \"C2_foo--1\" \"C2_bar--1\"        \"C2_foo--2\" \"C2_bar--2\"                               \"C2_foo--3\" \"C2_bar--3\"\n-- | get in `sampleOnLeft pollCows pollCowToOwner`  | _                              \"C1_bar--1\" \"C2_bar--1\"                               \"C1_bar--2\" \"C2_bar--2\"\n-- | get in `flip apply pollCows pollCowToOwner`    | \"C1_bar--1\" \"C2_bar--1\"        \"C2_foo--1\" \"C2_bar--1\" \"C1_bar--2\" \"C2_bar--2\"       \"C2_foo--2\" \"C2_bar--2\" \"C1_bar--3\" \"C2_bar--3\"\n-- | ```\n-- |\n-- | # sampleOnRight + step\n-- |\n-- | ```purescript\n-- | (pollCows :: Poll String) = step \"C1\" cowSupplier.event\n-- | (pollCowToOwner :: Poll (String -> String)) = step (_ <> \"_foo\") cowToOwner.event\n-- | ```\n-- |\n-- | ```\n-- | push to `surveymonger`                         | (_<>\"--1\")         (_<>\"--2\")                 (_<>\"--3\")                             (_<>\"--4\")                 (_<>\"--5\")                                   (_<>\"--6\")                     (_<>\"--7\")\n-- | push to `cowSupplier`                          |                                                                           \"C2\"\n-- | push to `cowToOwner`                           |                                                                                                                                            (_<>\"_bar\")\n-- | get in `sampleOnRight pollCows pollCowToOwner` | \"C1_foo--1\"        \"C1_foo--2\"                \"C1_foo--3\"                 _          \"C2_foo--4\"                \"C2_foo--5\"                _                 \"C2_bar--6\"                    \"C2_bar--7\"\n-- | get in `sampleOnLeft pollCows pollCowToOwner`  | _                  \"C1_foo--1\"                \"C1_foo--2\"                 _          \"C2_foo--3\"                \"C2_foo--4\"                _                 \"C2_foo--5\"                    \"C2_bar--6\"\n-- | get in `flip apply pollCows pollCowToOwner`    | \"C1_bar--1\"        \"C1_foo--1\" \"C1_foo--2\"    \"C1_foo--2\" \"C1_foo--3\"     _          \"C1_foo--3\" \"C2_foo--4\"    \"C2_foo--4\" \"C2_foo--5\"    _                 \"C2_bar--5\" \"C2_bar--6\"        \"C2_bar--6\" \"C2_bar--7\"\n-- | ```\nsampleOnRight\n  :: forall event a b\n   . Pollable event event\n  => IsEvent event\n  => APoll event a\n  -> APoll event (a -> b)\n  -> APoll event b\nsampleOnRight pollA pollAB = poll \\e -> EClass.sampleOnRight (sample_ pollA e) (sampleBy composeFlipped pollAB e)\n\nsampleOnLeft :: forall event a b. Pollable event event => IsEvent event => APoll event a -> APoll event (a -> b) -> APoll event b\nsampleOnLeft pollA pollAB = poll \\e -> EClass.sampleOnLeft (sample_ pollA e) (sampleBy composeFlipped pollAB e)\n\n-- | Compute a fixed point\n-- |\n-- | # fixB + identity\n-- |\n-- | ```\n-- | push to `surveymonger`                                    | C1->1\n-- |                                                           | C2->2\n-- |                                                           | C3->3\n-- | get in `sample (fixB C1 identity) surveymonger` | 1\n-- | ```\n-- |\n-- | # fixB + pure\n-- |\n-- | ```\n-- | push to `surveymonger`                                                 | C1->1\n-- |                                                                        | C2->2\n-- |                                                                        | C3->3\n-- | get in `sample (fixB C1 (\\i -> i <|> pure C2)) surveymonger` | 2\n-- | ```\n-- |\n-- | # fixB + step\n-- |\n-- | ```\n-- | push to `cowSupplier`                                                              | C0                 C3          C4\n-- | push to `surveymonger`                                                             |                        C1->1        C1->11\n-- |                                                                                    |                        C2->2        C2->12\n-- |                                                                                    |                        C3->3        C3->13\n-- |                                                                                    |                        C4->4        C4->14\n-- | get in `sample (fixB C1 (\\i -> i <|> step C2 cowSupplier)) surveymonger` | _     (subscribe)  _   2       _    14\n-- | get in `sample (fixB C1 (\\i -> step C2 cowSupplier <|> i)) surveymonger` | _     (subscribe)  _   1       _    14\n-- | ```\n-- |\n-- | # fixB + sham\n-- |\n-- | ```\n-- | push to `cowSupplier`                                                              | C0                C2         C3\n-- | push to `surveymonger`                                                             |                       C0->0       C0->10\n-- |                                                                                    |                       C1->1       C1->11\n-- |                                                                                    |                       C2->2       C2->12\n-- |                                                                                    |                       C3->3       C3->13\n-- |                                                                                    |                       C4->4       C4->14\n-- | get in `sample (fixB C1 (\\i -> i <|> sham cowSupplier)) surveymonger`    | _     (subscribe) _   1       _   13\n-- | get in `sample (fixB C1 (\\i -> sham cowSupplier <|> i)) surveymonger`    | _     (subscribe) _   1       _   13\n-- | ```\nfixB :: forall event a. Pollable event event => IsEvent event => a -> (APoll event a -> APoll event a) -> APoll event a\nfixB a f =\n  poll \\s ->\n    EClass.sampleOnRight\n      ( EClass.fix \\event ->\n          let\n            pollA = f (step a event)\n          in\n            sample_ pollA s\n      )\n      s\n\n-- | Compute a fixed point\n-- |\n-- | # Fix + identity\n-- |\n-- | ```\n-- | push to `surveymonger`                      | C1->1\n-- |                                             | C2->2\n-- |                                             | C3->3\n-- | get in `sample (fix identity) surveymonger` | ....nothing\n-- | ```\n-- |\n-- | # Fix + Pure\n-- |\n-- | ```\n-- | push to `surveymonger`                                   | C1->1\n-- |                                                          | C2->2\n-- |                                                          | C3->3\n-- | get in `sample (fix (\\i -> i <|> pure C1)) surveymonger` | 1  1  1  1...\n-- | ```\n-- |\n-- | # fix + step\n-- |\n-- | ```\n-- | push to `cowSupplier`                                                | C0                            C2\n-- | push to `surveymonger`                                               |                    C0->0           C0->10\n-- |                                                                      |                    C1->1           C1->11\n-- |                                                                      |                    C2->2           C2->12\n-- |                                                                      |                    C3->3           C3->13\n-- | get in `sample (fix (\\i -> i <|> step C1 cowSupplier)) surveymonger` | _                  1 1 1 1 1 1 1.....\n-- | get in `sample (fix (\\i -> step C1 cowSupplier <|> i)) surveymonger` | _   (subscribe)    1          _    2 2 2 2 2 2.....\n-- | ```\n-- |\n-- | all cows before first survey are ignored\n-- |\n-- | ```\n-- | push to `cowSupplier`                                                | C0              C2              C3\n-- | push to `surveymonger`                                               |                      C0->0           C0->10\n-- |                                                                      |                      C1->1           C1->11\n-- |                                                                      |                      C2->2           C2->12\n-- |                                                                      |                      C3->3           C3->13\n-- | get in `sample (fix (\\i -> i <|> step C1 cowSupplier)) surveymonger` | _               _    1 1 1 1 1 1 1.....\n-- | get in `sample (fix (\\i -> step C1 cowSupplier <|> i)) surveymonger` | _   (subscribe) _    1          _    13 3 3 3 3 3 3 3 3.....\n-- | ```\n-- |\n-- | # fix + sham\n-- |\n-- | ```\n-- | push to `cowSupplier`                                             | C0               C1           C2\n-- | push to `surveymonger`                                            |                       C0->0\n-- |                                                                   |                       C1->1\n-- |                                                                   |                       C2->2\n-- |                                                                   |                       C3->3\n-- |                                                                   |                       C4->4\n-- | get in `sample (fix (\\i -> i <|> sham cowSupplier)) surveymonger` | _   (subscribe)  _    _       2 2 2 2 2 2 2.....\n-- | get in `sample (fix (\\i -> sham cowSupplier <|> i)) surveymonger` | _   (subscribe)  _    _       2 2 2 2 2 2 2.....\n-- | ```\nfix\n  :: forall event a\n   . Pollable event event\n  => IsEvent event\n  => (APoll event a -> APoll event a)\n  -> APoll event a\nfix f = poll\n  let\n    innerPoll :: forall r. event (a -> r) -> event r\n    innerPoll e =\n\n      let\n        fixed :: event (Tuple a (a -> r))\n        fixed = EClass.fix \\ee -> sampleBy Tuple (f (sham (fst <$> ee)) :: APoll event a) e\n      in\n        (\\(Tuple a ff) -> ff a) <$> fixed\n  in\n    innerPoll\n\n-- | # Once + pure\n-- |\n-- | ```\n-- | push to `surveymonger`                                    | C1->1       C1->11\n-- |                                                           | C2->2       C2->12\n-- | get in `sample (once (pure C1 <|> pure C2)) surveymonger` | 1           _\n-- | ```\n-- |\n-- | # Once + sham\n-- |\n-- | ```\n-- | push to `cowSupplier`                                  | C1                      C2             C3\n-- | push to `surveymonger`                                 |       C1->1   C1->11          C1->21\n-- | ```\n-- |                                                        |       C2->2   C2->12          C2->22\n-- |                                                        |       C3->3   C3->13          C3->23\n-- | get in `sample (once (sham cowSupplier)) surveymonger` | _     _       _         12    _        _\n-- | ```\n-- |\n-- | # Once + step\n-- |\n-- | ```\n-- | push to `cowSupplier`                                     |                   C2\n-- | push to `surveymonger`                                    | C1->1   C1->11          C1->21\n-- |                                                           | C2->2   C2->12          C2->22\n-- |                                                           | C3->3   C3->13          C3->23\n-- | get in `sample (once (step C1 cowSupplier)) surveymonger` | 1       _         _     _\n-- | ```\nonce :: forall event a. Pollable event event => IsEvent event => APoll event a -> APoll event a\nonce a = poll \\e -> EClass.once (sample a e)\n\ninstance (IsEvent event, Plus event, Pollable event event) => IsEvent (APoll event) where\n  sampleOnRight = sampleOnRight\n  sampleOnLeft = sampleOnLeft\n  keepLatest = keepLatest\n  fix = fix\n  once = once\n\ntype PollIO a = { poll :: Poll a, push :: a -> Effect Unit }\ntype PurePollIO a = { poll :: Poll a, push :: a -> ST Global Unit }\n\ncreate\n  :: forall a\n   . ST Global (PollIO a)\ncreate = do\n  { event, push } <- Event.create\n  { poll: p } <- rant (sham event)\n  pure { poll: p, push }\n\ncreateTagged\n  :: forall a\n   . String\n  -> ST Global (PollIO a)\ncreateTagged tag = do\n  { event, push } <- Event.createTagged tag\n  { poll: p } <- rant (sham event) -- TODO: why not export unsubscribe?\n  pure { poll: p, push }\n\ncreatePure\n  :: forall a\n   . ST Global (PurePollIO a)\ncreatePure = do\n  { event, push } <- Event.createPure\n  pure { poll: sham event, push }\n\nmailbox\n  :: forall a b\n   . Ord a\n  => ST Global { push :: { address :: a, payload :: b } -> Effect Unit, poll :: a -> Poll b }\nmailbox = do\n  { push, event } <- Event.mailbox\n  pure { poll: map sham event, push }\n\nmailboxS\n  :: forall b\n   . ST Global { push :: { address :: String, payload :: b } -> Effect Unit, poll :: String -> Poll b }\nmailboxS = do\n  { push, event } <- Event.mailboxS\n  pure { poll: map sham event, push }\n\n-- | Once an event comes in, it just goes on and on and on and on (a rant) without listening to future events.\n-- | Rant ignores the initial event and broadcasts all the others.\n-- |\n-- | # rant + pure\n-- |\n-- | ```\n-- | push to `surveymonger`                                    | C1->1     C1->11\n-- |                                                           | C2->2     C2->12\n-- | get in `sample (rant (pure C1 <|> pure C2)) surveymonger` | _         _\n-- | ```\n-- |\n-- | # rant + sham\n-- |\n-- | ```\n-- | push to `cowSupplier`                                        | C0             C1                    C2             C3\n-- | push to `surveymonger`                                       |                    C1->1   C1->11          C1->21\n-- |                                                              |                    C2->2   C2->12          C2->22\n-- |                                                              |                    C3->3   C3->13          C3->23\n-- | get in `sample (rant (sham cowSupplier.event)) surveymonger` | _ (subscribe)  _   _       _         12    _        23\n-- | ```\n-- |\n-- | `unsubscribe` makes poll ignore `cowSupplier`\n-- |\n-- | ```\n-- | push to `cowSupplier`                                        | C0             C1                    C2                           C3\n-- | push to `surveymonger`                                       |                    C1->1   C1->11          C1->21\n-- |                                                              |                    C2->2   C2->12          C2->22\n-- |                                                              |                    C3->3   C3->13          C3->23\n-- | get in `sample (rant (sham cowSupplier.event)) surveymonger` | _ (subscribe)  _   _       _         12    _       (unsubscribe)  _\n-- | ```\n-- |\n-- | # rant + step\n-- |\n-- | ```\n-- | push to `cowSupplier`                                           | C0             C2                    C3\n-- | push to `surveymonger`                                          |                    C1->1   C1->11          C1->21\n-- |                                                                 |                    C2->2   C2->12          C2->22\n-- |                                                                 |                    C3->3   C3->13          C3->23\n-- | get in `sample (rant (step C1 cowSupplier.event)) surveymonger` | _  (subscribe) _   _       _         _     _\n-- | get in `...` (but without `EClass.once requesterEvent`)         | _  (subscribe) _   _       1         _     13\n-- | ```\nrant\n  :: forall a\n   . Poll a\n  -> ST Global { poll :: Poll a, unsubscribe :: ST Global Unit }\nrant a = do\n  ep <- Event.createPure\n  maybeUnsubscribe <- STRef.new Nothing\n  pure\n    { unsubscribe: do\n        STRef.read maybeUnsubscribe >>= case _ of\n          Nothing -> pure unit\n          Just unsubscribe -> unsubscribe\n    , poll: poll \\requesterEvent -> makeEvent \\responseEventCallback -> do\n        STRef.read maybeUnsubscribe >>= case _ of\n          Nothing -> do\n            unsubscribe <- responseEventCallback (sample_ a (EClass.once requesterEvent) :: Event a) \\(i :: a) -> justNone (ep.push i)\n            void $ flip STRef.write maybeUnsubscribe (Just unsubscribe)\n          Just _ -> pure unit\n        u3 <- responseEventCallback (EClass.sampleOnRightOp requesterEvent ep.event) justOne\n        pure u3\n    }\n\n-- | Deflect saves all initial events (events from `pure` for example) and ignores others\n-- | Rant and deflect can be considered opposites.\n-- |\n-- | # Deflect + pure\n-- |\n-- | ```\n-- | push to `surveymonger`                                       | C1->1       C1->11\n-- |                                                              | C2->2       C2->12\n-- | get in `sample (deflect (pure C1 <|> pure C2)) surveymonger` | 1      2    11      12\n-- | ```\n-- |\n-- | # Deflect + sham\n-- |\n-- | ```\n-- | push to `cowSupplier`                                     | C1                      C2             C3\n-- | push to `surveymonger`                                    |       C1->1   C1->11          C1->21\n-- |                                                           |       C2->2   C2->12          C2->22\n-- |                                                           |       C3->3   C3->13          C3->23\n-- | get in `sample (deflect (sham cowSupplier)) surveymonger` | _     _       _         _     _        _\n-- | ```\n-- |\n-- | # Deflect + step\n-- |\n-- | ```\n-- | push to `cowSupplier`                                        | C0             C2                    C3\n-- | push to `surveymonger`                                       |                    C1->1   C1->11          C1->21\n-- |                                                              |                    C2->2   C2->12          C2->22\n-- |                                                              |                    C3->3   C3->13          C3->23\n-- | get in `sample (deflect (step C1 cowSupplier)) surveymonger` | _  (subscribe) _   1       11        _     21\n-- | ```\ndeflect\n  :: forall a\n   . Poll a\n  -> ST Global (Poll a)\ndeflect pollA = do\n  ep <- STRef.new []\n  maybeUnsubscribe <- STRef.new Nothing\n  let\n    innerPoll :: forall r. Event (a -> r) -> Event r\n    innerPoll = \\e ->\n      let\n        innerEvent :: (forall x. Event x -> (x -> EventfulProgram r) -> ST Global (ST Global Unit)) -> ST Global (ST Global Unit)\n        innerEvent s = do\n          STRef.read maybeUnsubscribe >>= case _ of\n            Nothing -> do\n              unsubscribe <- (s :: Event a -> (a -> ProgramfulEvent Unit) -> ST Global (ST Global Unit)) (sample_ pollA (EClass.once e) :: Event a) \\i -> justNone do\n                void $ liftST $ flip STRef.modify ep $ flip Array.snoc i\n              void $ STRef.write (Just unsubscribe) maybeUnsubscribe\n            Just _ -> do\n              pure unit\n          u3 <- (s :: Event (a -> r) -> ((a -> r) -> EventfulProgram r) -> ST Global (ST Global Unit)) (e :: Event (a -> r)) \\f -> justManyM do\n            STRef.read maybeUnsubscribe >>= case _ of\n              Nothing -> do\n                pure unit\n              Just unsubscribe -> do\n                unsubscribe\n            r <- STRef.read ep\n            pure $ map f r\n          pure do\n            u3\n      in\n        makeEvent innerEvent\n  pure $ poll innerPoll\n\ndata KeepLatestOrder event a b\n  = KeepLatestStart (APoll event a) (a -> b)\n  | KeepLatestLast b\n\nkeepLatest\n  :: forall event a\n   . Filterable.Filterable event\n  => EClass.IsEvent event\n  => Pollable event event\n  => APoll event (APoll event a)\n  -> APoll event a\nkeepLatest a = APoll \\e ->\n  Filterable.filterMap\n    ( case _ of\n        KeepLatestLast b -> Just b\n        _ -> Nothing\n    ) $ EClass.fix \\ie -> oneOf\n    [ sampleBy KeepLatestStart a e\n    , EClass.keepLatest $ flip Filterable.filterMap ie case _ of\n        KeepLatestStart b ff -> Just (sampleBy (\\bb _ -> KeepLatestLast (ff bb)) b (EClass.once ie))\n        _ -> empty\n    ]\n\nlisten_\n  :: forall a\n   . Poll a\n  -> (a -> Effect Unit)\n  -> Effect (Effect Unit)\nlisten_ p f = do\n  { event, push } <- liftST Event.create\n  Event.subscribe (sample_ p event) f <* push unit\n", "module FRP.Poll\n  ( Poll(..)\n  , PollIO\n  , PurePollIO\n  , animate\n  , class Pollable\n  , create\n  , createPure\n  , createTagged\n  , deflect\n  , derivative\n  , derivative'\n  , dredge\n  , fixB\n  , gate\n  , gateBy\n  , integral\n  , integral'\n  , mailbox\n  , mailboxS\n  , merge\n  , mergeMap\n  , mergeMapPure\n  , mergePure\n  , poll\n  , pollFromEvent\n  , pollFromOptimizedRep\n  , pollFromPoll\n  , rant\n  , sample\n  , sampleBy\n  , sample_\n  , listen_\n  , sham\n  , solve\n  , solve'\n  , solve2\n  , solve2'\n  , stRefToPoll\n  , stToPoll\n  , step\n  , switcher\n  , toPoll\n  , unfold\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt, alt, (<|>))\nimport Control.Apply (lift2)\nimport Control.Monad.ST.Class (liftST)\nimport Control.Monad.ST.Global (Global)\nimport Control.Monad.ST.Internal (ST)\nimport Control.Monad.ST.Internal as STRef\nimport Control.Plus (class Plus, empty)\nimport Data.Array as Array\nimport Data.Either (Either(..), either)\nimport Data.Filterable (eitherBool, maybeBool)\nimport Data.Filterable as Filterable\nimport Data.Foldable (foldr, oneOfMap)\nimport Data.Function (applyFlipped)\nimport Data.FunctorWithIndex (class FunctorWithIndex, mapWithIndex)\nimport Data.HeytingAlgebra (ff, implies, tt)\nimport Data.Maybe (Maybe(..))\nimport Data.Profunctor (dimap)\nimport Data.Tuple (Tuple(..), uncurry)\nimport Effect (Effect)\nimport FRP.Event (class IsEvent, Event, fold, justMany, justNone, justOne, makeEvent, subscribe)\nimport FRP.Event as Event\nimport FRP.Event.AnimationFrame (animationFrame)\nimport FRP.Event.Class as EClass\nimport FRP.Poll.Unoptimized as Poll\nimport Partial.Unsafe (unsafePartial)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | `Poll` is an optimized version of poll fine-tuned for `Event`.\ndata Poll a\n  = OnlyPure (Array a)\n  | OnlyPoll (Poll.APoll Event a)\n  | OnlyEvent (Event a)\n  | PureAndEvent (Array a) (Event a)\n  | PureAndPoll (Array a) (Poll.APoll Event a)\n\ninstance functorAPoll :: Functor Poll where\n  map f (PureAndPoll x y) = PureAndPoll (map f x) (map f y)\n  map f (PureAndEvent x y) = PureAndEvent (map f x) (map f y)\n  map f (OnlyPure x) = OnlyPure (map f x)\n  map f (OnlyEvent x) = OnlyEvent (map f x)\n  map f (OnlyPoll y) = OnlyPoll (map f y)\n\ninstance functorWithIndexAPoll :: FunctorWithIndex Int Poll where\n  mapWithIndex f (PureAndPoll x y) = PureAndPoll (mapWithIndex f x) (EClass.mapAccum (\\a b -> Tuple (a + 1) (f a b)) (Array.length x) y)\n  mapWithIndex f (PureAndEvent x y) = PureAndEvent (mapWithIndex f x) (EClass.mapAccum (\\a b -> Tuple (a + 1) (f a b)) (Array.length x) y)\n  mapWithIndex f (OnlyPure x) = OnlyPure (mapWithIndex f x)\n  mapWithIndex f (OnlyEvent x) = OnlyEvent (mapWithIndex f x)\n  mapWithIndex f (OnlyPoll y) = OnlyPoll (EClass.mapAccum (\\a b -> Tuple (a + 1) (f a b)) (0) y)\n\ninstance applyAPoll :: Apply Poll where\n  apply (OnlyEvent a) (OnlyEvent b) = OnlyEvent (a <*> b)\n  apply a b = pollFromPoll (toPoll a <*> toPoll b)\n\ninstance applicativeAPoll :: Applicative Poll where\n  pure a = OnlyPure [ a ]\n\ninstance semigroupAPoll :: Semigroup a => Semigroup (Poll a) where\n  append = lift2 append\n\ninstance monoidAPoll :: Monoid a => Monoid (Poll a) where\n  mempty = pure mempty\n\ninstance heytingAlgebraAPoll :: HeytingAlgebra a => HeytingAlgebra (Poll a) where\n  tt = pure tt\n  ff = pure ff\n  not = map not\n  implies = lift2 implies\n  conj = lift2 conj\n  disj = lift2 disj\n\ninstance semiringAPoll :: Semiring a => Semiring (Poll a) where\n  zero = pure zero\n  one = pure one\n  add = lift2 add\n  mul = lift2 mul\n\ninstance ringAPoll :: Ring a => Ring (Poll a) where\n  sub = lift2 sub\n\npollFromPoll :: Poll.Poll ~> Poll\npollFromPoll i = OnlyPoll i\n\n-- | Construct a `Poll` from its sampling function.\npollFromEvent :: Event ~> Poll\npollFromEvent = OnlyEvent\n\npollFromOptimizedRep :: forall a. Array a -> Event a -> Poll a\npollFromOptimizedRep a i = PureAndPoll a (Poll.sham i)\n\npoll :: forall a. (forall b. Event (a -> b) -> Event b) -> Poll a\npoll f = OnlyPoll (Poll.poll f)\n\ntoPoll :: Poll ~> Poll.Poll\ntoPoll (PureAndPoll a b) = oneOfMap pure a <|> b\ntoPoll (PureAndEvent a b) = oneOfMap pure a <|> Poll.sham b\ntoPoll (OnlyEvent a) = Poll.sham a\ntoPoll (OnlyPure a) = oneOfMap pure a\ntoPoll (OnlyPoll b) = b\n\n-- | Create a `Poll` which is updated when an `Event` fires, by providing\n-- | an initial value.\nstep :: forall a. a -> Event a -> Poll a\nstep a e = PureAndPoll [ a ] $ Poll.poll \\e0 -> EClass.sampleOnRight e e0\n\n-- | Create a `Poll` which is updated when an `Event` fires, by providing\n-- | an initial value and a function to combine the current value with a new event\n-- | to create a new value.\nunfold :: forall a b. (b -> a -> b) -> b -> Event a -> Poll b\nunfold f a e = step a (fold f a e)\n\ninstance Alt Poll where\n  alt (OnlyPure a) (OnlyPure x) = OnlyPure (a <> x)\n  alt (OnlyPure a) (OnlyEvent y) = PureAndEvent a y\n  alt (OnlyPure a) (OnlyPoll y) = PureAndPoll a y\n  alt (OnlyPure a) (PureAndEvent x y) = PureAndEvent (a <> x) y\n  alt (OnlyPure a) (PureAndPoll x y) = PureAndPoll (a <> x) y\n  --\n  alt (OnlyEvent b) (OnlyPure x) = PureAndPoll x (Poll.sham b)\n  alt (OnlyEvent b) (OnlyEvent y) = OnlyEvent (alt b y)\n  alt (OnlyEvent b) (OnlyPoll y) = OnlyPoll (alt (Poll.sham b) y)\n  alt (OnlyEvent b) (PureAndEvent x y) = PureAndEvent x (b <|> y)\n  alt (OnlyEvent b) (PureAndPoll x y) = PureAndPoll x (alt (Poll.sham b) y)\n  --\n  alt (OnlyPoll b) (OnlyPure x) = PureAndPoll x b\n  alt (OnlyPoll b) (OnlyEvent y) = OnlyPoll (alt b $ Poll.sham y)\n  alt (OnlyPoll b) (OnlyPoll y) = OnlyPoll (alt b y)\n  alt (OnlyPoll b) (PureAndEvent x y) = PureAndPoll x (alt b (Poll.sham y))\n  alt (OnlyPoll b) (PureAndPoll x y) = PureAndPoll x (alt b y)\n  --\n  alt (PureAndEvent a b) (OnlyPure x) = PureAndEvent (a <> x) b\n  alt (PureAndEvent a b) (OnlyEvent y) = PureAndEvent a (alt b y)\n  alt (PureAndEvent a b) (OnlyPoll y) = PureAndPoll a (alt (Poll.sham b) y)\n  alt (PureAndEvent a b) (PureAndEvent x y) = PureAndEvent (a <> x) (alt b y)\n  alt (PureAndEvent a b) (PureAndPoll x y) = PureAndPoll (a <> x) (alt (Poll.sham b) y)\n  --\n  alt (PureAndPoll a b) (OnlyPure x) = PureAndPoll (a <> x) b\n  alt (PureAndPoll a b) (OnlyEvent y) = PureAndPoll a (alt b $ Poll.sham y)\n  alt (PureAndPoll a b) (OnlyPoll y) = PureAndPoll a (alt b y)\n  alt (PureAndPoll a b) (PureAndEvent x y) = PureAndPoll (a <> x) (alt b $ Poll.sham y)\n  alt (PureAndPoll a b) (PureAndPoll x y) = PureAndPoll (a <> x) (alt b y)\n\ninstance Plus Poll where\n  empty = OnlyPure []\n\n-- | Merge together several polls. OnlyPure has the same functionality\n-- | as `oneOf`, but it is faster and less prone to stack explosions.\nmerge :: forall a. Array (Poll a) \u2192 Poll a\nmerge a = case foldr go { l: [], m: [], r: [] } a of\n  { l, m: [], r: [] } -> OnlyPure l\n  { l: [], m, r: [] } -> OnlyEvent (Event.merge m)\n  { l: [], m: [], r } -> OnlyPoll (Poll.merge r)\n  -- todo: is it problematic that this is out of l2r order?\n  { l, m, r } -> PureAndPoll l (Poll.sham (Event.merge m) <|> Poll.merge r)\n  where\n\n  go\n    :: Poll a\n    -> { l :: Array a\n       , m :: Array (Event a)\n       , r :: Array (Poll.Poll a)\n       }\n    -> { l :: Array a\n       , m :: Array (Event a)\n       , r :: Array (Poll.Poll a)\n       }\n  go (OnlyPure q) { l, m, r } = { l: q <> l, m, r }\n  go (OnlyEvent q) { l, m, r } = { l, m: [ q ] <> m, r }\n  go (PureAndEvent x y) { l, m, r } = { l: x <> l, m: [ y ] <> m, r }\n  go (OnlyPoll q) { l, m, r } = { l, m, r: [ q ] <> r }\n  go (PureAndPoll x y) { l, m, r } = { l: x <> l, m, r: [ y ] <> r }\n\nmergeMap :: forall a b. (a -> Poll b) -> Array a \u2192 Poll b\nmergeMap f a = merge (map f a)\n\nmergeMapPure :: forall a b. (a -> b) -> Array a \u2192 Poll b\nmergeMapPure f a = OnlyPure (map f a)\n\nmergePure :: forall a. Array a \u2192 Poll a\nmergePure = OnlyPure\n\n-- | A poll where the answers are rigged by the nefarious `Event a`\nsham :: Event ~> Poll\nsham = pollFromEvent\n\n-- | Turn a function over events into a function over polls.\ndredge :: forall a b. (Event a -> Event b) -> Poll a -> Poll b\ndredge f ea = pollFromPoll (Poll.dredge f (toPoll ea))\n\n-- | Switch `Poll`s based on an `Event`.\nswitcher :: forall a. Poll a -> Event (Poll a) -> Poll a\nswitcher b e = EClass.keepLatest (pollFromOptimizedRep [ b ] e)\n\n-- | Sample a `Poll` on some `Event` by providing a predicate function.\ngateBy :: forall p a. (p -> a -> Boolean) -> Poll p -> Event a -> Event a\ngateBy f ps xs = Filterable.compact (sampleBy (\\p x -> if f p x then Just x else Nothing) ps xs)\n\n-- | Filter an `Event` by the boolean value of a `Poll`.\ngate :: forall a. Poll Boolean -> Event a -> Event a\ngate = gateBy const\n\n-- | Integrate with respect to some measure of time.\n-- |\n-- | OnlyPure function approximates the integral using the trapezium rule at the\n-- | implicit sampling interval.\n-- |\n-- | The `Semiring` `a` should be a vector field over the field `t`. To represent\n-- | this, the user should provide a _grate_ which lifts a multiplication\n-- | function on `t` to a function on `a`. Simple examples where `t ~ a` can use\n-- | the `integral'` function instead.\nintegral\n  :: forall a t\n   . Field t\n  => Semiring a\n  => (((a -> t) -> t) -> a)\n  -> a\n  -> Poll t\n  -> Poll a\n  -> Poll a\nintegral g initial t b = pollFromPoll $ Poll.integral g initial (toPoll t) (toPoll b)\n\n-- | Integrate with respect to some measure of time.\n-- |\n-- | OnlyPure function is a simpler version of `integral` where the function being\n-- | integrated takes values in the same field used to represent time.\nintegral'\n  :: forall t\n   . Field t\n  => t\n  -> Poll t\n  -> Poll t\n  -> Poll t\nintegral' = integral (_ $ identity)\n\n-- | Differentiate with respect to some measure of time.\n-- |\n-- | OnlyPure function approximates the derivative using a quotient of differences at the\n-- | implicit sampling interval.\n-- |\n-- | The `Semiring` `a` should be a vector field over the field `t`. To represent\n-- | this, the user should provide a grate which lifts a division\n-- | function on `t` to a function on `a`. Simple examples where `t ~ a` can use\n-- | the `derivative'` function.\nderivative\n  :: forall a t\n   . Field t\n  => Ring a\n  => (((a -> t) -> t) -> a)\n  -> Poll t\n  -> Poll a\n  -> Poll a\nderivative g t b = pollFromPoll $ Poll.derivative g (toPoll t) (toPoll b)\n\n-- | Differentiate with respect to some measure of time.\n-- |\n-- | OnlyPure function is a simpler version of `derivative` where the function being\n-- | differentiated takes values in the same field used to represent time.\nderivative'\n  :: forall t\n   . Field t\n  => Poll t\n  -> Poll t\n  -> Poll t\nderivative' = derivative (_ $ identity)\n\n-- | Compute a fixed point\nfixB :: forall a. a -> (Poll a -> Poll a) -> Poll a\nfixB a f =\n  poll \\s ->\n    EClass.sampleOnRight\n      ( EClass.fix \\event ->\n          let\n            b = f (step a event)\n          in\n            sample_ b s\n      )\n      s\n\n-- | Solve a first order differential equation of the form\n-- |\n-- | ```\n-- | da/dt = f a\n-- | ```\n-- |\n-- | by integrating once (specifying the initial conditions).\n-- |\n-- | For example, the exponential function with growth rate `\u237A`:\n-- |\n-- | ```purescript\n-- | exp = solve' 1.0 Time.seconds (\u237A * _)\n-- | ```\nsolve\n  :: forall t a\n   . Field t\n  => Semiring a\n  => (((a -> t) -> t) -> a)\n  -> a\n  -> Poll t\n  -> (Poll a -> Poll a)\n  -> Poll a\nsolve g a0 t f = fixB a0 \\b -> integral g a0 t (f b)\n\n-- | Solve a first order differential equation.\n-- |\n-- | OnlyPure function is a simpler version of `solve` where the function being\n-- | integrated takes values in the same field used to represent time.\nsolve'\n  :: forall a\n   . Field a\n  => a\n  -> Poll a\n  -> (Poll a -> Poll a)\n  -> Poll a\nsolve' = solve (_ $ identity)\n\n-- | Solve a second order differential equation of the form\n-- |\n-- | ```\n-- | d^2a/dt^2 = f a (da/dt)\n-- | ```\n-- |\n-- | by integrating twice (specifying the initial conditions).\n-- |\n-- | For example, an (damped) oscillator:\n-- |\n-- | ```purescript\n-- | oscillate = solve2' 1.0 0.0 Time.seconds (\\x dx -> -\u237A * x - \u03B4 * dx)\n-- | ```\nsolve2\n  :: forall t a\n   . Field t\n  => Semiring a\n  => (((a -> t) -> t) -> a)\n  -> a\n  -> a\n  -> Poll t\n  -> (Poll a -> Poll a -> Poll a)\n  -> Poll a\nsolve2 g a0 da0 t f =\n  fixB a0 \\b ->\n    integral g a0 t\n      ( fixB da0 \\db ->\n          integral g da0 t (f b db)\n      )\n\n-- | Solve a second order differential equation.\n-- |\n-- | OnlyPure function is a simpler version of `solve2` where the function being\n-- | integrated takes values in the same field used to represent time.\nsolve2'\n  :: forall a\n   . Field a\n  => a\n  -> a\n  -> Poll a\n  -> (Poll a -> Poll a -> Poll a)\n  -> Poll a\nsolve2' = solve2 (_ $ identity)\n\n-- | Animate a `Poll` by providing a rendering function.\nanimate\n  :: forall scene\n   . Poll scene\n  -> (scene -> Effect Unit)\n  -> Effect (Effect Unit)\nanimate scene render = do\n  { event, unsubscribe } <- animationFrame\n  u2 <- subscribe (sample_ scene event) render\n  pure do\n    unsubscribe\n    u2\n\n-- | Turn an ST Ref into a poll\nstRefToPoll :: STRef.STRef Global ~> Poll\nstRefToPoll r = pollFromPoll (Poll.stRefToPoll r)\n\n-- | Turn an ST Global into a poll\nstToPoll :: ST Global ~> Poll\nstToPoll r = pollFromPoll (Poll.stToPoll r)\n\nfilterMap\n  :: forall a b\n   . (a -> Maybe b)\n  -> Poll a\n  -> Poll b\nfilterMap f (PureAndPoll x y) = PureAndPoll (Filterable.filterMap f x) (Filterable.filterMap f y)\nfilterMap f (PureAndEvent x y) = PureAndEvent (Filterable.filterMap f x) (Filterable.filterMap f y)\nfilterMap f (OnlyPure x) = OnlyPure (Filterable.filterMap f x)\nfilterMap f (OnlyEvent x) = OnlyEvent (Filterable.filterMap f x)\nfilterMap f (OnlyPoll y) = OnlyPoll (Filterable.filterMap f y)\n\npartitionMap :: forall a b c. (a -> Either b c) -> Poll a -> { left :: Poll b, right :: Poll c }\npartitionMap f b = { left: filterMap (either Just (const Nothing)) fb, right: filterMap (either (const Nothing) Just) fb }\n  where\n  fb = f <$> b\n\ninstance Filterable.Compactable Poll where\n  compact = filterMap identity\n  separate = partitionMap identity\n\ninstance Filterable.Filterable Poll where\n  filterMap = filterMap\n  filter = filterMap <<< maybeBool\n  partitionMap = partitionMap\n  partition p xs = do\n    let o = partitionMap (eitherBool p) xs\n    { no: o.left, yes: o.right }\n\nsampleOnRight\n  :: forall a b\n   . Poll a\n  -> Poll (a -> b)\n  -> Poll b\nsampleOnRight (OnlyEvent a) (OnlyEvent b) = OnlyEvent (a `EClass.sampleOnRight` b)\nsampleOnRight a b = pollFromPoll (toPoll a `EClass.sampleOnRight` toPoll b)\n\nsampleOnLeft :: forall a b. Poll a -> Poll (a -> b) -> Poll b\nsampleOnLeft (OnlyEvent a) (OnlyEvent b) = OnlyEvent (a `EClass.sampleOnLeft` b)\nsampleOnLeft a b = pollFromPoll (toPoll a `EClass.sampleOnLeft` toPoll b)\n\neventOrBust :: Poll ~> Event\neventOrBust (OnlyEvent a) = a\neventOrBust _ = empty\n\nfix\n  :: forall a\n   . (Poll a -> Poll a)\n  -> Poll a\nfix f = do\n  let o = f empty\n  case o of\n    OnlyEvent _ -> pollFromEvent $ EClass.fix (dimap pollFromEvent eventOrBust f)\n    _ -> pollFromPoll $ EClass.fix (dimap pollFromPoll toPoll f)\n\nonce :: Poll ~> Poll\nonce i = pollFromPoll $ EClass.once (toPoll i)\n\ninstance IsEvent Poll where\n  sampleOnRight = sampleOnRight\n  sampleOnLeft = sampleOnLeft\n  keepLatest = keepLatest\n  fix = fix\n  once = once\n\ntype PollIO a = { poll :: Poll a, push :: a -> Effect Unit }\ntype PurePollIO a = { poll :: Poll a, push :: a -> ST Global Unit }\n\ncreate\n  :: forall a\n   . ST Global (PollIO a)\ncreate = do\n  { event, push } <- Event.create\n  { poll: p } <- rant (sham event)\n  pure { poll: p, push }\n\ncreateTagged\n  :: forall a\n   . String\n  -> ST Global (PollIO a)\ncreateTagged tag = do\n  { event, push } <- Event.createTagged tag\n  { poll: p } <- rant (sham event)\n  pure { poll: p, push }\n\ncreatePure\n  :: forall a\n   . ST Global (PurePollIO a)\ncreatePure = do\n  { event, push } <- Event.createPure\n  pure { poll: sham event, push }\n\nmailbox\n  :: forall a b\n   . Ord a\n  => ST Global { push :: { address :: a, payload :: b } -> Effect Unit, poll :: a -> Poll b }\nmailbox = do\n  { push, event } <- Event.mailbox\n  pure { poll: map sham event, push }\n\nmailboxS\n  :: forall b\n   . ST Global { push :: { address :: String, payload :: b } -> Effect Unit, poll :: String -> Poll b }\nmailboxS = do\n  { push, event } <- Event.mailboxS\n  pure { poll: map sham event, push }\n\n-- Rant never emits the head, so we can just ignore it\nrant\n  :: forall a\n   . Poll a\n  -> ST Global { poll :: Poll a, unsubscribe :: ST Global Unit }\nrant (PureAndPoll _ i) = rant (OnlyPoll i)\nrant (PureAndEvent _ i) = rant (OnlyEvent i)\n-- todo: we should add or remove effect from some of these types\nrant (OnlyEvent i) =\n  ( unsafeCoerce\n      :: Effect\n           { poll :: Poll a\n           , unsubscribe :: Effect Unit\n           }\n      -> ST Global\n           { poll :: Poll a\n           , unsubscribe :: ST Global Unit\n           }\n  ) do\n    { event: e, unsubscribe } <- Event.memoize i\n    pure $ { poll: OnlyEvent e, unsubscribe }\nrant (OnlyPoll i) = do\n  { poll: p, unsubscribe } <- Poll.rant i\n  pure $ { poll: OnlyPoll p, unsubscribe }\nrant (OnlyPure _) = pure $ { poll: empty, unsubscribe: pure unit }\n\ndeflect\n  :: forall a\n   . Poll a\n  -> ST Global (Poll a)\ndeflect (PureAndPoll a b) = PureAndPoll a <$> Poll.deflect b\ndeflect (PureAndEvent a _) = pure (OnlyPure a)\ndeflect (OnlyPoll b) = OnlyPoll <$> Poll.deflect b\ndeflect (OnlyEvent _) = pure $ OnlyPure []\ndeflect (OnlyPure a) = pure (OnlyPure a)\n\nkeepLatest' :: forall a. Event (Poll a) -> Event a\nkeepLatest' e = makeEvent \\s -> do\n  cancelInner <- STRef.new (pure unit)\n  let\n    onPure p = do\n      justNone $ void $ liftST $ STRef.write (pure unit) cancelInner\n      justMany p\n    onPoll p = justNone do\n      ep <- Event.createPure\n      c <- s (Poll.sample p ep.event) justOne\n      ep.push identity\n      void $ liftST $ STRef.write c cancelInner\n    onEvent ev =\n      justNone do\n        c <- s ev justOne\n        void $ liftST $ STRef.write c cancelInner\n  let\n    treatMe i = case i of\n      OnlyPure p -> onPure p\n      OnlyEvent ev -> onEvent ev\n      OnlyPoll p -> onPoll p\n      PureAndEvent p q -> do\n        onPure p\n        onEvent q\n      PureAndPoll p q -> do\n        onPure p\n        onPoll q\n  cancelOuter <-\n    s e \\i -> do\n      justNone do\n        ci <- STRef.read cancelInner\n        ci\n      treatMe i\n  pure do\n    ci <- STRef.read cancelInner\n    ci\n    cancelOuter\n\nfoldlArr :: forall a b c. (b -> c) -> (b -> a -> Boolean -> (Unit -> Array a) -> Either b c) -> b -> Array a -> c\nfoldlArr bc arf bb arr = go 0 bb\n  where\n  go i b\n    | i == Array.length arr = bc b\n    | otherwise = case arf b (unsafePartial (Array.unsafeIndex arr i)) (i + 1 == Array.length arr) (\\_ -> Array.drop (i + 1) arr) of\n        Left b' -> go (i + 1) b'\n        Right c -> c\n\nreplayPollsForKeepLatest :: forall a. Array (Poll a) -> Poll a\nreplayPollsForKeepLatest = foldlArr OnlyPure\n  ( \\b a isLast x -> case a of\n      -- elide them\n      OnlyPure pp -> Left (b <> pp)\n      -- this event would have never emitted because we would have canceled it before it ever started\n      OnlyEvent _ -> Left b\n      PureAndEvent pp _ -> Left (b <> pp)\n      OnlyPoll pl -> Right $ PureAndPoll b (cnt isLast pl x)\n      PureAndPoll pp pl -> Right $ PureAndPoll (b <> pp) (cnt isLast pl x)\n  )\n  []\n  where\n  cnt isLast pl x = Poll.poll \\e -> makeEvent \\sub -> do\n    dfl <- (if isLast then pure else Poll.deflect) pl\n    sub ((Poll.sample dfl e) <|> sample (replayPollsForKeepLatest (x unit)) e) justOne\n\nkeepLatest\n  :: forall a\n   . Poll (Poll a)\n  -> Poll a\nkeepLatest (OnlyPure p) = replayPollsForKeepLatest p\nkeepLatest (OnlyEvent e) = OnlyEvent $ keepLatest' e\nkeepLatest (OnlyPoll p) = OnlyPoll $ Poll.poll \\e -> map (uncurry ($)) $ keepLatest' $ Poll.sampleBy (\\pl ff -> Tuple ff <$> pl) p e\nkeepLatest (PureAndEvent l r) = replayPollsForKeepLatest (l <> [ OnlyEvent $ keepLatest' r ])\nkeepLatest (PureAndPoll l r) = replayPollsForKeepLatest (l <> [ keepLatest (OnlyPoll r) ])\n\nclass Pollable pollable where\n  -- | Sample a `Poll` on some `Event`.\n  sample :: forall a b. Poll a -> pollable (a -> b) -> pollable b\n\ninstance Pollable Event where\n  sample (PureAndPoll x y) ab = e <|> Poll.sample y ab\n    where\n    e = makeEvent \\s -> s ab \\f -> justMany (map f x)\n  sample (PureAndEvent x y) ab = e <|> y `EClass.sampleOnLeft` ab\n    where\n    e = makeEvent \\s -> s ab \\f -> justMany (map f x)\n  sample (OnlyEvent y) ab = y `EClass.sampleOnLeft` ab\n  sample (OnlyPoll y) ab = Poll.sample y ab\n  sample (OnlyPure x) ab = e\n    where\n    e = makeEvent \\s -> s ab \\f -> justMany (map f x)\n\ninstance Pollable Poll where\n  sample = EClass.sampleOnRight\n\n-- | Sample a `Poll` on some `Event` by providing a combining function.\nsampleBy :: forall pollable a b c. Pollable pollable => Functor pollable => (a -> b -> c) -> Poll a -> pollable b -> pollable c\nsampleBy f b e = sample (map f b) (map applyFlipped e)\n\n-- | Sample a `Poll` on some `Event`, discarding the event's values.\nsample_ :: forall pollable a b. Pollable pollable => Functor pollable => Poll a -> pollable b -> pollable a\nsample_ = sampleBy const\n\nlisten_\n  :: forall a\n   . Poll a\n  -> (a -> Effect Unit)\n  -> Effect (Effect Unit)\nlisten_ p f = do\n  { event, push } <- liftST Event.create\n  Event.subscribe (sample_ p event) f <* push unit\n", "-- | `Region`s are used to figure out the bounds of collections of managed elements. The difficulty lies mostly in empty\n-- | managed regions, they have nothing to get a hold of and need to be managed outside of the DOM. To communicate the\n-- | presence or absence of elements, `Region`s have to use `Bump Just` to signal to their parents that they contain an\n-- | element that can be used to locate a region or `Bump Nothing` to signal that it contains no elements to locate.\n-- |\n-- | It is then the responsibilty of the parent to use the information of all its children to provide correct `Bound`\n-- | information to i.e. `DOMInterpret` to use `attachElement` or `beamRegion`. A `Bump Just` causes all following\n-- | `Region`s to update their begin(and their end when empty) until a new non-empty region is found. A `Bump Nothing`\n-- | causes the inverse. First a non-empty `Region` has be found which will be used to update the beginning of all\n-- | following empty `Region`s until a new non-empty `Region` is found.\nmodule Deku.Internal.Region\n  ( Anchor(..)\n  , Bound\n  , Region(..)\n  , StaticRegion(..)\n  , RegionSpan\n  , Bump\n  , fromParent\n  , newStaticRegion\n  , newSpan\n  , allocateRegion\n  , printSpan\n  ) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Monad.ST.Global (Global)\nimport Control.Monad.ST.Internal as ST\nimport Control.Monad.ST.Uncurried (STFn1, STFn2, STFn3, STFn4, mkSTFn1, mkSTFn2, mkSTFn3, mkSTFn4, runSTFn1, runSTFn2, runSTFn3, runSTFn4)\nimport Control.Plus (empty)\nimport Data.Array as Array\nimport Data.Array.ST as STArray\nimport Data.Foldable (traverse_)\nimport Data.Maybe (Maybe(..), isJust, maybe)\nimport Data.Newtype (class Newtype)\nimport Deku.Internal.Entities (DekuElement, DekuParent, DekuText)\nimport FRP.Event (createPure)\nimport FRP.Poll (Poll, pollFromEvent, stRefToPoll)\nimport Partial.Unsafe (unsafePartial)\n\ndata Anchor\n  = ParentStart DekuParent\n  | Element DekuElement\n  | Text DekuText\n\n-- | Hides how the `Anchor` is determined. Typically a region needs to check if it has any elements of its own and\n-- | defers to the parent when it has none. Otherwise we just return the last element of the region.\ntype Bound =\n  ST.ST Global Anchor\n\n-- | Signals to the parent that the endpoint of the region has changed. This can cascade up a tree of regions when the\n-- | child region was the last one or the parent is now empty.\ntype Bump =\n  STFn1 (Maybe Anchor) Global Unit\n\n-- | A dynamic `Region` that supports moving, removing, appending and clearing.\nnewtype Region = Region\n  { begin :: Bound\n  , end :: Bound\n\n  , position :: Poll Int\n  , sendTo :: STFn1 Int Global Unit\n  , remove :: ST.ST Global Unit\n\n  , bump :: Bump\n  }\n\nderive instance Newtype Region _\n\n-- | Region that supports adding new regions and elements.\nnewtype StaticRegion = StaticRegion\n  { end :: Bound\n  , region :: ST.ST Global Region\n  , element :: STFn1 Anchor Global Unit\n  }\n\nderive instance Newtype StaticRegion _\n\n-- | Contains information about which regions in a span\ntype SharedBound' =\n  { owner :: ST.STRef Global (ST.ST Global Int)\n  -- last element that uses this bound\n  , extent :: ST.STRef Global (ST.ST Global Int)\n  , bound :: Bound\n  , pushAnchor :: STFn1 Anchor Global Unit\n  }\n\ntype SharedBound =\n  ST.STRef Global SharedBound'\n\ntype ManagedRegion =\n  { ix :: ST.ST Global Int\n  , pushIx :: STFn1 Int Global Unit\n  , position :: Poll Int\n  , end :: SharedBound\n  }\n\ntype Children =\n  STArray.STArray Global ManagedRegion\n\nreadSharedBound :: STFn1 SharedBound Global Anchor\nreadSharedBound = mkSTFn1 \\shared -> do\n  { bound } <- ST.read shared\n  bound\n\n-- | The core of the Region system are RegionSpans. They manage sibling Regions and coordinate the insert, bump, move\n-- | and remove actions. They also provide a Bound implementation which lets Regions determine their begin and end\n-- | Anchors for beamRegion. The actual structure of the RegionSpan is just an array of regions. All regions track their\n-- | indices by using a reference that gets updated on every insert/splice.\n-- |\n-- | The begin of a Region is defined as the end of the previous region. A dummy region is inserted at the start which\n-- | contains the information provided by the parent. This makes the whole ix - 1 dance work out but we will have to\n-- | correct the indices for this at some points(see insertManaged and newSpan->sendTo).\n-- |\n-- | The end of a region is stored in a SharedBound. As the name suggests this bound can be shared among multiple\n-- | adjacent regions. The end is set by region pointed to by the owner field. All following empty regions use the same\n-- | SharedBound. The last region using the SharedBound is pointed to by the extent field.\n-- |\n-- | For a non-empty regions this works out to: begin is the end of the previous region, if it is empty this does not\n-- | matter because we read the end of the first non-empty region which is shared with the empty one.\n-- |\n-- | For an empty region we do the same, we find the end of the first non-empty region, read our own end which would be\n-- | the same SharedBound leading to the begin and end pointing to the same Node signalling an empty collection to\n-- | beamRegion.\n-- |\n-- | To split a SharedBound we can use the owner and extent pointer to find all empty regions using that bound. Then we\n-- | create a new SharedBound and update all following regions.\n-- |\n-- | The inverse happens when the region signals a clear. The we extend the preceding SharedBound and update the\n-- | following regions.\n-- |\n-- | The implementation detects if updating the preceding or following regions would be cheaper and uses that strategy.\nnewtype RegionSpan =\n  RegionSpan\n    { children :: Children\n    , bump :: Bump\n    }\n\n-- | Manages a span of `Region`s. \nnewSpan :: STFn2 Bound Bump Global RegionSpan\nnewSpan = mkSTFn2 \\parent parentBump -> do\n  children <- STArray.new\n\n  -- bound owned by an element outside of this span\n  parentBound <- do\n    owner <- ST.new $ pure 0\n    extent <- ST.new $ pure 0\n    let\n      -- we cant actually update the beginning given from the parent, so this dummy has to do\n      -- `bumpBound` and `clearBound` have safeguards to never call this effect\n      pushAnchor :: STFn1 Anchor Global Unit\n      pushAnchor =\n        mkSTFn1 \\_ -> pure unit -- unsafeThrow \"parent forced to update anchor\"\n\n    ST.new { owner, extent, bound: parent, pushAnchor }\n\n  let\n    parentRegion :: ManagedRegion\n    parentRegion =\n      { ix: pure 0\n      , pushIx: mkSTFn1 \\_ -> pure unit -- unsafeThrow \"parent forced to update index\"\n      , position: empty\n      , end: parentBound\n      }\n  void $ STArray.push parentRegion children\n  pure $ RegionSpan { children, bump: parentBump }\n\nprintSpan :: STFn1 RegionSpan Global String\nprintSpan = mkSTFn1 \\(RegionSpan { children }) -> do\n  arr <- STArray.freeze children\n  owner <- Array.foldM\n    (\\a r -> append a <<< show <$> join (ST.read <<< _.owner =<< ST.read r.end))\n    \"\"\n    arr\n  extent <- Array.foldM\n    ( \\a r -> append a <<< show <$> join\n        (ST.read <<< _.extent =<< ST.read r.end)\n    )\n    \"\"\n    arr\n  pure $ owner <> \"\\n\" <> extent\n\nallocateRegion :: STFn2 (Maybe Int) RegionSpan Global Region\nallocateRegion = mkSTFn2\n  \\givenPos span@(RegionSpan { children, bump: parentBump }) -> do\n    managed@{ position, ix } <- runSTFn2 insertManaged givenPos children\n    let\n      begin :: Bound\n      begin =\n        runSTFn2 beginBound managed children\n\n      end :: Bound\n      end =\n        runSTFn1 readSharedBound managed.end\n\n      bump :: Bump\n      bump = mkSTFn1 case _ of\n        Nothing -> do\n          wasLast <- runSTFn2 isLastBound managed children\n          runSTFn2 clearBound managed children\n          runSTFn3 updateParent wasLast managed span\n\n        b@(Just anchor) -> do\n          runSTFn3 bumpBound anchor managed children\n          whenM (runSTFn2 isLastBound managed children) do\n            runSTFn1 parentBump b\n\n      sendTo :: STFn1 Int Global Unit\n      sendTo = mkSTFn1 \\pos' -> do\n        let\n          -- correct shift by parent `SharedBound`\n          pos :: Int\n          pos =\n            pos' + 1\n\n        -- save old state of `ManagedRegion`\n        lastAnchor <- ST.new $ Nothing @Anchor\n        wasLast <- runSTFn2 isLastBound managed children\n        lastIx <- ix\n\n        -- clear the region so neighbouring `SharedBound`s coalesce\n        whenM (not <$> runSTFn1 isEmpty managed) do\n          anchor <- _.bound =<< ST.read managed.end\n          void $ ST.write (Just anchor) lastAnchor\n          runSTFn2 clearBound managed children\n\n        -- update `SharedBound` so the extent of the cleared bound does not point at us\n        do\n          sharedBound <- ST.read managed.end\n          whenM (eq lastIx <$> join (ST.read sharedBound.extent)) do\n            previousRegion <- runSTFn2 index (lastIx - 1) children\n            void $ ST.write previousRegion.ix sharedBound.extent\n\n        -- now safe to move, indices becoming invalid\n        do\n          removed <- STArray.splice lastIx 1 [] children\n          void $ STArray.splice pos 0 removed children\n\n          -- restoring indices\n          runSTFn3 fixManaged (min lastIx pos) updateIx children\n          newBegin <- runSTFn2 shareBound managed.ix children\n          void $ ST.write newBegin managed.end\n\n        -- if we had any elements we signal a bump, this requires the indices to be valid so we do it last\n        ST.read lastAnchor >>= traverse_ \\anchor -> runSTFn3 bumpBound anchor\n          managed\n          children\n\n        -- update parent when necessary\n        runSTFn3 updateParent wasLast managed span\n\n      remove :: ST.ST Global Unit\n      remove = do\n        runSTFn1 bump Nothing\n        finalIx <- ix\n        -- give ourselves an invalid index so later sendTo and removes have no effect\n        runSTFn1 managed.pushIx (-1)\n        void $ STArray.splice finalIx 1 [] children\n        runSTFn3 fixManaged finalIx updateIx children\n\n    pure $ Region { begin, end, position, sendTo, remove, bump }\n\nindex :: forall r a. STFn2 Int (STArray.STArray r a) r a\nindex = mkSTFn2 \\ix arr ->\n  unsafePartial (flip Array.unsafeIndex ix <$> STArray.unsafeFreeze arr)\n\nlastRegion :: STFn1 Children Global ManagedRegion\nlastRegion = mkSTFn1 \\children -> do\n  length <- STArray.length children\n  -- there is always atleast one element or the parent\n  runSTFn2 index (length - 1) children\n\n-- | Reads the end of the previous sibling which is defined as the beginning of the `ManagedRegion`.\nbeginBound :: STFn2 ManagedRegion Children Global Anchor\nbeginBound = mkSTFn2 \\region children -> do\n  ix <- region.ix\n  prev <- runSTFn2 index (ix - 1) children\n  sbound <- ST.read prev.end\n  sbound.bound\n\n-- | Determines the whether the final `Bound`, determines the final `Bound` and runs the `Bump` effect on it.\nupdateParent :: STFn3 Boolean ManagedRegion RegionSpan Global Unit\nupdateParent = mkSTFn3 \\wasLast managed (RegionSpan { bump, children }) -> do\n  nowLast <- runSTFn2 isLastBound managed children\n  when (wasLast /= nowLast) do\n    last <- runSTFn1 lastRegion children\n    end <- ST.read last.end\n    ownerIx <- join $ ST.read end.owner\n    if ownerIx == 0 then\n      runSTFn1 bump Nothing\n    else do\n      anchor <- end.bound\n      runSTFn1 bump $ Just anchor\n\nisEmpty :: STFn1 ManagedRegion Global Boolean\nisEmpty = mkSTFn1 \\{ ix, end } -> do\n  { owner } <- ST.read end\n  -- if the `ManagedRegion` does not own its end it's considered empty\n  notEq <$> (join $ ST.read owner) <*> ix\n\n-- | Returns whether the given `ManagedRegion` controls the ending bound of the whole span.\nisLastBound\n  :: STFn2 ManagedRegion Children Global Boolean\nisLastBound = mkSTFn2 \\region children -> do\n  length <- STArray.length children\n  end <- ST.read region.end\n  owner <- join $ ST.read end.owner\n  pos <- region.ix\n  extent <- join $ ST.read end.extent\n  pure $ owner == pos && extent == length - 1\n\n-- | Creates a new `ShareBound'` value for an empty `ManagedRegion`. It looks up the preceding `ManagedRegion` and uses\n-- | its end `SharedBound` possibly extending it.\nshareBound\n  :: STFn2 (ST.ST Global Int) Children Global\n       SharedBound'\nshareBound = mkSTFn2 \\posRef children -> do\n  pos <- posRef\n  -- prev should always be present, shareBound is called with an actual child element and the first element is the\n  -- always the parentRegion\n  prev <- runSTFn2 index (pos - 1) children\n  endFromPrev <- ST.read prev.end\n  currentExtent <- join $ ST.read endFromPrev.extent\n\n  -- If the currentExtent is equal or greater to our pos then the region will be inserted before the end of the\n  -- `SharedBound` and we dont have to anything.\n  -- otherwise we are getting inserted at the end of the `SharedBound` so we set it up to track our position \n  when (currentExtent < pos) do\n    void $ ST.write posRef endFromPrev.extent\n\n  pure endFromPrev\n\n-- | Lifts a `ManagedRegion` out of the `RegionSpan`, restoring the `SharedBound`s of its siblings.\nclearBound\n  :: STFn2 ManagedRegion Children Global Unit\nclearBound = mkSTFn2 \\cleared children -> do\n  nextBound <- ST.read cleared.end\n  selfIx <- cleared.ix\n  prevBound <- ST.read <<< _.end =<< runSTFn2 index (selfIx - 1) children\n\n  extentToEff <- ST.read nextBound.extent\n  extentToIx <- extentToEff\n  ownerEff <- ST.read prevBound.owner\n  ownerIx <- ownerEff\n\n  -- choose the smaller `SharedBound` to update, but never update the first element, the parent\n  if selfIx - ownerIx > extentToIx - selfIx || ownerIx == 0 then do\n    -- the following owned `SharedBound` was smaller, so we extend prevBound to cover nextBound and update the following \n    -- regions\n    void $ ST.write extentToEff prevBound.extent\n    runSTFn4 fixManagedTo selfIx (extentToIx + 1) (updateShared prevBound)\n      children\n\n  else do\n    -- the preceding not owned `SharedBound` was smaller, update the nextBound with the information of\n    -- prevBound and update the preceding `ManagedRegion`s\n    anchor <- prevBound.bound\n    runSTFn1 nextBound.pushAnchor anchor\n    void $ ST.write ownerEff nextBound.owner\n\n    runSTFn4 fixManagedTo ownerIx (selfIx + 1) (updateShared nextBound) children\n\n-- | Updates the end of a `ManagedRegion`. If it shares that bound with a preceding sibling it will set up a new\n-- | `SharedBound` that it owns and propagates it to all following members of the old `SharedBound`. \n-- | Or it hijacks the previous `SharedBound`. \nbumpBound\n  :: STFn3 Anchor ManagedRegion Children Global\n       Unit\nbumpBound = mkSTFn3 \\anchor bumped children -> do\n  empty <- runSTFn1 isEmpty bumped\n  -- update our owned `SharedBound`\n  if not empty then do\n    ownedBound <- ST.read bumped.end\n    runSTFn1 ownedBound.pushAnchor anchor\n\n  -- we need to split up the `SharedBound` \n  else do\n    prevExtent <- ST.read bumped.end\n    ownerEff <- ST.read prevExtent.owner\n    ownerIx <- ownerEff\n\n    extentToEff <- ST.read prevExtent.extent\n    extentToIx <- extentToEff\n    selfIx <- bumped.ix\n\n    previousRegion <- runSTFn2 index (selfIx - 1) children\n\n    -- find the smallest possible update, but never update the first element, the parent\n    if selfIx - ownerIx > extentToIx - selfIx || ownerIx == 0 then do\n      -- the following `SharedBound` will be smaller\n      newShared <- do\n        owner <- ST.new bumped.ix\n        extent <- ST.new extentToEff\n        ref <- ST.new anchor\n        let\n          pushAnchor = mkSTFn1 \\a -> void $ ST.write a ref\n          bound = ST.read ref\n        pure { owner, extent, bound, pushAnchor }\n\n      runSTFn4 fixManagedTo selfIx (extentToIx + 1) (updateShared newShared)\n        children\n\n      -- update the extent of the preceding `SharedBound` to the previous `ManagedRegion`\n      void $ ST.write previousRegion.ix prevExtent.extent\n\n    else do\n      -- preceding `SharedBound` will be smaller\n      newShared <- do\n        owner <- ST.new ownerEff\n        extent <- ST.new previousRegion.ix\n        ref <- ST.new =<< prevExtent.bound\n        let\n          pushAnchor = mkSTFn1 \\a -> void $ ST.write a ref\n          bound = ST.read ref\n        pure { owner, extent, bound, pushAnchor }\n\n      runSTFn4 fixManagedTo ownerIx selfIx (updateShared newShared)\n        children\n\n      -- hijack longer prevExtent `SharedBound` and update it with our own info, making bumped the new owner\n      void $ ST.write bumped.ix prevExtent.owner\n      runSTFn1 prevExtent.pushAnchor anchor\n\ninsertManaged\n  :: STFn2 (Maybe Int) Children Global\n       ManagedRegion\ninsertManaged = mkSTFn2 \\givenPos children -> do\n  length <- STArray.length children\n  let\n    -- clamp and correct the givenPos, because the parent `SharedBound` already occupies the first element and shifts\n    -- everything else by one\n    pos :: Int\n    pos =\n      clamp 1 length $ maybe length (add 1) givenPos\n\n  ixRef <- ST.new pos\n  posEvent <- createPure\n\n  let\n    pushIx :: STFn1 Int Global Unit\n    pushIx = mkSTFn1 \\i -> do\n      void $ ST.write i ixRef\n      posEvent.push $ i - 1 -- and restore position for the user\n\n    ix :: ST.ST Global Int\n    ix =\n      ST.read ixRef\n\n    position :: Poll Int\n    position = add (-1) <$> stRefToPoll ixRef <|> pollFromEvent posEvent.event\n\n  prevBegin <- runSTFn2 shareBound ix children\n  end <- ST.new prevBegin\n\n  let\n    managed :: ManagedRegion\n    managed =\n      { ix, pushIx, position, end }\n\n  void $ STArray.splice pos 0 [ managed ] children\n  runSTFn3 fixManaged (pos + 1) updateIx children\n  pure managed\n\nupdateShared :: SharedBound' -> STFn2 Int ManagedRegion Global Unit\nupdateShared shared = mkSTFn2 \\_ region -> do\n  void $ ST.write shared region.end\n\nupdateIx :: STFn2 Int ManagedRegion Global Unit\nupdateIx =\n  mkSTFn2 \\i { pushIx } -> runSTFn1 pushIx i\n\n-- TODO: expensive operation\nfixManaged\n  :: STFn3 Int (STFn2 Int ManagedRegion Global Unit)\n       Children\n       Global\n       Unit\nfixManaged = mkSTFn3 \\from fn children -> do\n  length <- STArray.length children\n  runSTFn4 fixManagedTo from length fn children\n\n-- TODO: expensive operation\nfixManagedTo\n  :: STFn4 Int Int (STFn2 Int ManagedRegion Global Unit)\n       Children\n       Global\n       Unit\nfixManagedTo = mkSTFn4 \\from to fn children -> do\n  elems <- STArray.unsafeFreeze children\n  ST.for from to \\ix -> do\n    runSTFn2 fn ix (unsafePartial (Array.unsafeIndex elems ix))\n\nnewStaticRegion :: STFn2 Bound Bump Global StaticRegion\nnewStaticRegion = mkSTFn2 \\parentBound parentBump -> do\n  spanCounter <- ST.new (-1) -- making the first span 0\n  spanState <- ST.new $ Nothing @RegionSpan\n  staticEnd <- ST.new $ Nothing @Anchor\n  spanEnd <- ST.new $ Nothing @Anchor\n\n  let\n    findOrCreateSpan :: ST.ST Global RegionSpan\n    findOrCreateSpan = ST.read spanState >>= case _ of\n      Nothing -> do\n        spanIx <- ST.modify (add 1) spanCounter\n        staticBegin <- ST.read staticEnd\n        let\n          begin :: Bound\n          begin = do\n            case staticBegin of\n              Just e -> pure e\n              Nothing -> parentBound\n\n          bump :: Bump\n          bump = mkSTFn1 \\update ->\n            -- only take control of parentBump when we are the last span\n            whenM (eq spanIx <$> ST.read spanCounter) do\n              void $ ST.write update spanEnd\n              case update of\n                Nothing ->\n                  runSTFn1 parentBump =<< ST.read staticEnd\n\n                b ->\n                  runSTFn1 parentBump b\n\n        span <- runSTFn2 newSpan begin bump\n        void $ ST.write (Just span) spanState\n        pure span\n\n      Just span ->\n        pure span\n\n  pure $ StaticRegion\n    { end: do\n        fromSpan <- ST.read spanEnd\n        case fromSpan of\n          Just e ->\n            pure e\n\n          Nothing -> do\n            fromStatic <- ST.read staticEnd\n            case fromStatic of\n              Just e ->\n                pure e\n\n              Nothing ->\n                parentBound\n\n    , region: do\n        span <- findOrCreateSpan\n        runSTFn2 allocateRegion Nothing span\n\n    , element: mkSTFn1 \\anchor -> do\n        whenM (isJust <$> ST.read spanState) do\n          -- clear span state\n          void $ ST.write Nothing spanState\n          void $ ST.write Nothing spanEnd\n          -- signal that any previous span is no longer allowed to use parentBump\n          void $ ST.modify (add 1) spanCounter\n\n        void $ ST.write (Just anchor) staticEnd\n        runSTFn1 parentBump $ Just anchor\n    }\n\nfromParent :: STFn1 DekuParent Global StaticRegion\nfromParent =\n  mkSTFn1 \\parent -> runSTFn2 newStaticRegion\n    (pure $ ParentStart parent)\n    (mkSTFn1 \\_ -> pure unit)\n", "-- | This module contains the low-level functionality of Deku, including\n-- | the primitive `Nut` type, which is the type of a Deku application.\n-- | In general, this module is not intended to be used directly, with the\n-- | exception of the `Nut` type signature and, when needed, the `Nut`\n-- | type signature (for which `Nut` is an alias).\nmodule Deku.Core\n  ( AttachElement\n  , AttachText\n  , AttrIndex(..)\n  , Attribute\n  , Attribute'\n  , BeamRegion\n  , BufferPortal\n  , Cb(..)\n  , ChildId(..)\n  , DOMInterpret(..)\n  , DynOptions\n  , Hook\n  , Hook'\n  , Key(..)\n  , MakeElement\n  , MakeText\n  , Namespace(..)\n  , Nut(..)\n  , PSR(..)\n  , ParentId(..)\n  , RemoveElement\n  , RemoveText\n  , SetCb\n  , SetInnerHtml\n  , SetProp\n  , SetText\n  , Tag(..)\n  , UnsetAttribute\n  , Value(..)\n  , attributeAtYourOwnRisk\n  , callbackWithCaution\n  , cb\n  , cb'\n  , defer\n  , deferO\n  , dynOptions\n  , elementify\n  , fixed\n  , handleScope\n  , newPSR\n  , portal\n  , prop'\n  , pump\n  , text\n  , text_\n  , unsafeAttribute\n  , unsafeUnAttribute\n  , unset'\n  , useDeflect\n  , useDyn\n  , useDynAtBeginning\n  , useDynAtBeginningWith\n  , useDynAtEnd\n  , useDynAtEndWith\n  , useDynWith\n  , useHot\n  , useHotRant\n  , useMailboxed\n  , useMailboxed'\n  , useMailboxedS\n  , useMailboxedS'\n  , useRant\n  , useRant'\n  , useRef\n  , useRefST\n  , useSkimmed\n  , useSplit\n  , useState\n  , useState'\n  , useStateTagged'\n  , xdata\n  ) where\n\nimport Prelude\n\nimport Control.Alt (alt, (<|>))\nimport Control.Monad.ST.Class (liftST)\nimport Control.Monad.ST.Global (Global)\nimport Control.Monad.ST.Internal as ST\nimport Control.Monad.ST.Internal as STRef\nimport Control.Monad.ST.Uncurried (STFn1, STFn2, STFn3, mkSTFn1, mkSTFn3, runSTFn1, runSTFn2, runSTFn3)\nimport Control.Plus (empty)\nimport Data.Array as Array\nimport Data.Array.ST as STArray\nimport Data.Compactable (compact)\nimport Data.Foldable (traverse_)\nimport Data.List ((:))\nimport Data.List as List\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Newtype (class Newtype, over, un)\nimport Data.Tuple (Tuple(..))\nimport Data.Tuple.Nested (type (/\\), (/\\))\nimport Deku.Do as Deku\nimport Deku.Internal.Ancestry (Ancestry, hasElementParent)\nimport Deku.Internal.Ancestry as Ancestry\nimport Deku.Internal.Entities (DekuChild(..), DekuElement, DekuParent(..), DekuText, fromDekuElement, toDekuElement)\nimport Deku.Internal.Region (Anchor(..), Bound, Region(..), StaticRegion(..), allocateRegion, fromParent, newSpan, newStaticRegion)\nimport Effect (Effect, forE)\nimport Effect.Uncurried (EffectFn1, EffectFn2, EffectFn3, mkEffectFn1, mkEffectFn2, mkEffectFn3, runEffectFn1, runEffectFn2, runEffectFn3)\nimport FRP.Event as Event\nimport FRP.Event.Class (once)\nimport FRP.Poll (Poll(..))\nimport FRP.Poll as Poll\nimport FRP.Poll.Unoptimized as UPoll\nimport Partial.Unsafe (unsafePartial)\nimport Safe.Coerce (coerce)\nimport Web.DOM (Element)\nimport Web.Event.Internal.Types (Event)\n\n-- | A callback function that can be used as a value for a listener.\nnewtype Key = Key String\nnewtype Value = Value String\nnewtype Cb = Cb (Event -> Effect Boolean)\n\n-- | Construct a `cb`. This is an alias for the newtype constructor.\ncb :: (Event -> Effect Unit) -> Cb\ncb = Cb <<< ((map <<< map) (const true))\n\nprop' :: String -> String -> Attribute'\nprop' k v = mkEffectFn3\n  \\_ e (DOMInterpret { setProp }) -> do\n    runEffectFn3 setProp (Key k) (Value v) (toDekuElement e)\n\ncb' :: String -> Cb -> Attribute'\ncb' k v = mkEffectFn3\n  \\id e (DOMInterpret { markElementAsImpure, setCb }) -> do\n    liftST $ runSTFn1 markElementAsImpure id\n    runEffectFn3 setCb (Key k) v (toDekuElement e)\n\nunset' :: String -> Attribute'\nunset' k = mkEffectFn3 \\_ e (DOMInterpret { unsetAttribute }) ->\n  runEffectFn2 unsetAttribute (Key k) (toDekuElement e)\n\n-- TODO: get rid of `Element` type\ntype Attribute' =\n  EffectFn3 Ancestry Element DOMInterpret Unit\n\n-- | Low level representation of key-value pairs for attributes and listeners.\n-- | In general, this type is for internal use only.\nnewtype Attribute :: Row Type -> Type\nnewtype Attribute i = Attribute Attribute'\n\n-- | For internal use only, exported to be used by other modules. Ignore this.\nunsafeUnAttribute :: forall e. Attribute e -> Attribute'\nunsafeUnAttribute = coerce\n\n-- | For internal use only, exported to be used by other modules. Ignore this.\nunsafeAttribute\n  :: forall e\n   . EffectFn3 Ancestry Element DOMInterpret Unit\n  -> Attribute e\nunsafeAttribute = Attribute\n\nattributeAtYourOwnRisk :: forall e. String -> String -> Attribute e\nattributeAtYourOwnRisk k v = unsafeAttribute $ mkEffectFn3\n  \\_ e (DOMInterpret { setProp }) -> do\n    runEffectFn3 setProp (Key k) (Value v) (toDekuElement e)\n\ncallbackWithCaution\n  :: forall e. String -> (Event -> Effect Boolean) -> Attribute e\ncallbackWithCaution k v = unsafeAttribute $ mkEffectFn3\n  \\id e (DOMInterpret { markElementAsImpure, setCb }) -> do\n    liftST $ runSTFn1 markElementAsImpure id\n    runEffectFn3 setCb (Key k) (Cb v) (toDekuElement e)\n\n-- | Construct a [data attribute](https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes).\nxdata :: forall e. String -> String -> Attribute e\nxdata k v =\n  attributeAtYourOwnRisk (\"data-\" <> k) v\n\nnewtype Tag = Tag String\nnewtype Namespace = Namespace String\n\n-- | Type used by Deku backends to create an element. For internal use only unless you're writing a custom backend.\ntype MakeElement =\n  EffectFn3 Ancestry (Maybe Namespace) Tag DekuElement\n\ntype RemoveElement = EffectFn1 DekuElement Unit\ntype RemoveText = EffectFn1 DekuText Unit\n\n-- | Type used by Deku backends to give a parent to an element. For internal use only unless you're writing a custom\n-- | backend.\ntype AttachElement =\n  EffectFn2 DekuChild Anchor Unit\n\n-- | An optimization to attach innerhtml\ntype SetInnerHtml =\n  EffectFn2 String Anchor Unit\n\ntype AttachText =\n  EffectFn2 DekuText Anchor Unit\n\n-- | Type used by Deku backends to construct a text element. For internal use only unless you're writing a custom\n-- | backend.\ntype MakeText = EffectFn2 Ancestry (Maybe String) DekuText\n\n-- | Type used by Deku backends to set the text of a text element. For internal use only unless you're writing a custom\n-- | backend.\ntype SetText = EffectFn2 String DekuText Unit\n\n-- | Type used by Deku backends to unset an attribute. For internal use only unless you're writing a custom backend.\ntype UnsetAttribute =\n  EffectFn2 Key DekuElement Unit\n\n-- | Type used by Deku backends to set an attribute. For internal use only unless you're writing a custom backend.\ntype SetProp = EffectFn3 Key Value DekuElement Unit\n\n-- | Type used by Deku backends to set a listener. For internal use only unless you're writing a custom backend.\ntype SetCb =\n  EffectFn3 Key Cb DekuElement Unit\n\n-- | This effect takes 3 `Anchor`s and moves the elements \"between\" the first and second `Anchor` \"after\" the last\n-- | `Anchor`. Because `Anchor` includes `Node`s and `ParentNode`s we'll have to define \"between\" and \"after\".\n-- | - between: A region is the collection of elements after the beginning up and including the end. The beginning is\n-- |   never included in the collection. This means that when begin and end point to the same `Node` the collection is\n-- |   empty. \n-- | - after: This is more straightforward: for `Node`s it's simply after the `Node` and for `ParentNode` its before the\n-- |   first child `Node`.\ntype BeamRegion =\n  EffectFn3 Anchor Anchor Anchor Unit\n\n-- | Generates a place for portals to render into that will not be displayed immediatly.\ntype BufferPortal = Effect (Tuple Int DekuParent)\n\nnewtype ParentId = ParentId Int\n\nderive instance Newtype ParentId _\nderive newtype instance Eq ParentId\nderive newtype instance Ord ParentId\nnewtype ChildId = ChildId Int\n\nderive instance Newtype ChildId _\nderive newtype instance Eq ChildId\nderive newtype instance Ord ChildId\n\nnewtype AttrIndex = AttrIndex Int\n\nderive instance Newtype AttrIndex _\nderive newtype instance Eq AttrIndex\nderive newtype instance Ord AttrIndex\n\n-- | This is the interpreter that any Deku backend creator needs to impelement.\n-- | Three interpreters are included with Deku: SPA.\n-- , SSR, and hydrated SSR.\nnewtype DOMInterpret = DOMInterpret\n  { -- ssr\n    dynamicDOMInterpret :: Unit -> DOMInterpret\n  , portalDOMInterpret :: Ancestry -> DOMInterpret\n  -- element\n  , makeElement :: MakeElement\n  , setProp :: SetProp\n  , setCb :: SetCb\n  , unsetAttribute :: UnsetAttribute\n  , attachElement :: AttachElement\n  , removeElement :: RemoveElement\n  -- element ssr\n  , initializeElementRendering ::\n      STFn2 Ancestry DekuElement Global Unit\n  , markElementAsImpure :: STFn1 Ancestry Global Unit\n  , isBoring :: Ancestry -> Boolean\n  -- text\n  , makeText :: MakeText\n  , setText :: SetText\n  , attachText :: AttachText\n  , removeText :: RemoveText\n  -- text ssr\n  , initializeTextRendering ::\n      STFn2 Ancestry DekuText Global Unit\n  , markTextAsImpure :: STFn1 Ancestry Global Unit\n  -- portal\n  , bufferPortal :: BufferPortal\n  , initializePortalRendering :: STFn1 Ancestry Global Unit\n  , markPortalAsRendered :: STFn1 Ancestry Global Unit\n  -- beam\n  , beamRegion :: BeamRegion\n  -- dyn\n  , initializeDynRendering :: STFn1 Ancestry Global Unit\n  -- fixed\n  , initializeFixedRendering :: STFn1 Ancestry Global Unit\n  -- pursx optimization\n  , setInnerHTML :: SetInnerHtml\n  }\n\nderive instance Newtype DOMInterpret _\n\n-- | Handles an optimized `Poll` by running the effect on each emitted value. Any resulting subscription gets written to \n-- | the given cleanup array.\npump'\n  :: forall a\n   . PSR\n  -> Poll a\n  -> (Boolean -> EffectFn1 a Unit)\n  -> Effect Unit\npump' (PSR { addEffectToDisposalQueue }) p effF =\n  go p\n  where\n  staticEff = effF true\n  dynamicEff = effF false\n\n  handleEvent :: Event.Event a -> Effect Unit\n  handleEvent y = do\n    uu <- runEffectFn2 Event.subscribeO y dynamicEff\n    void $ liftST $ runSTFn1 addEffectToDisposalQueue $ uu\n\n  handlePoll\n    :: ST.STRef Global (EffectFn1 a Unit) -> Event.Event a -> Effect Unit\n  handlePoll whichF y = do\n    uu <- runEffectFn2 Event.subscribeO y $ mkEffectFn1 \\i -> do\n      f <- liftST $ ST.read whichF\n      runEffectFn1 f i\n    void $ liftST $ runSTFn1 addEffectToDisposalQueue uu\n\n  go :: Poll a -> Effect Unit\n  go = case _ of\n    OnlyEvent x -> handleEvent x\n    OnlyPure x -> runEffectFn2 Event.fastForeachE x staticEff\n    OnlyPoll x -> do\n      bang <- liftST $ Event.create\n      -- start with the statif function\n      f <- liftST $ ST.new staticEff\n      handlePoll f (UPoll.sample x bang.event)\n      bang.push identity\n      -- after we peel off the \"pure\" values, switch to the dynamic function\n      liftST $ void $ ST.write dynamicEff f\n    PureAndEvent x y -> do\n      go (OnlyPure x)\n      go (OnlyEvent y)\n    PureAndPoll x y -> do\n      go (OnlyPure x)\n      go (OnlyPoll y)\n\npump\n  :: forall a\n   . PSR\n  -> Poll a\n  -> EffectFn1 a Unit\n  -> Effect Unit\npump psr poll fn = pump' psr poll (const fn)\n\nnewtype PSR = PSR\n  {\n    -- used by `Nut`s to register or clear the last element of their region.\n    region :: StaticRegion\n  -- scope\n  -- used by an element to signal it should be removed\n  , signalDisposalQueueShouldBeTriggered :: Poll.Poll Unit\n  , addEffectToDisposalQueue :: STFn1 (Effect Unit) Global Unit\n  , triggerDisposalQueueEffects :: Effect Unit\n  -- used to indicate when an element should never be statically rendered\n  -- it may be disqualified for other reasons, but this flag trumps them all\n  , ancestry :: Ancestry\n  }\n\nderive instance Newtype PSR _\n\nnewPSR :: STFn3 Ancestry (Poll.Poll Unit) StaticRegion Global PSR\nnewPSR = mkSTFn3 \\ancestry signalDisposalQueueShouldBeTriggered region -> do\n  unsubs <- STArray.new\n  let\n    addEffectToDisposalQueue :: STFn1 (Effect Unit) Global Unit\n    addEffectToDisposalQueue =\n      mkSTFn1 \\eff -> void (STArray.push eff unsubs)\n\n    -- to correctly dispose, effect should be run in the reverse order of insertion\n    triggerDisposalQueueEffects :: Effect Unit\n    triggerDisposalQueueEffects = do\n      stack <- liftST $ STArray.unsafeFreeze unsubs\n      let l = Array.length stack\n      forE 0 l \\i -> (unsafePartial $ Array.unsafeIndex stack (l - 1 - i))\n\n  pure\n    ( PSR\n        { signalDisposalQueueShouldBeTriggered: once\n            signalDisposalQueueShouldBeTriggered\n        , ancestry\n        , region\n        , addEffectToDisposalQueue\n        , triggerDisposalQueueEffects\n        }\n    )\n\nhandleScope :: EffectFn1 PSR Unit\nhandleScope = mkEffectFn1 \\psr -> do\n  pump psr (un PSR psr).signalDisposalQueueShouldBeTriggered\n    $ mkEffectFn1 \\_ -> (un PSR psr).triggerDisposalQueueEffects\n\nnewtype Nut =\n  Nut (EffectFn2 PSR DOMInterpret Unit)\n\ninstance Semigroup Nut where\n  append (Nut a) (Nut b) =\n    -- unrolled version of `fixed`\n    Nut $ mkEffectFn2 \\psr di -> do\n      liftST $ runSTFn1 (un DOMInterpret di).initializeFixedRendering\n        (un PSR psr).ancestry\n      -- first `Nut` should not handle any unsubs, they may still be needed for later elements\n      emptyScope <- liftST $ runSTFn3 newPSR\n        (Ancestry.fixed 0 (un PSR psr).ancestry)\n        (un PSR psr).signalDisposalQueueShouldBeTriggered\n        (un PSR psr).region\n\n      runEffectFn2 a emptyScope di\n      runEffectFn2 b\n        (over PSR (\\i -> i { ancestry = (Ancestry.fixed 1 i.ancestry) }) psr)\n        di\n\ninstance Monoid Nut where\n  mempty =\n    -- while we contribute no UI elements we still have to handle any deferred effects by our hooks\n    Nut $ mkEffectFn2 \\psr _ -> runEffectFn1 handleScope psr\n\n-- hooks\n\ntype Hook' a r = (a -> r) -> Nut\ntype Hook a = (a -> Nut) -> Nut\n\nuseDeflect :: forall a. Poll a -> Hook (Poll a)\nuseDeflect e f = Nut $ mkEffectFn2 \\psr di -> do\n  d <- liftST $ Poll.deflect e\n  runEffectFn2 (coerce $ f d) psr di\n\nuseHot\n  :: forall a\n   . a\n  -> Hook ((a -> Effect Unit) /\\ Poll a)\nuseHot a f = Deku.do\n  push /\\ poll <- useState'\n  r <- useRefST a poll\n  f (push /\\ (Poll.stToPoll r <|> poll))\n\nuseHotRant :: forall a. Poll a -> Hook (Poll a)\nuseHotRant e f = Deku.do\n  r <- useRefST Nothing (Just <$> e)\n  p <- useRant e\n  -- we `once e` in case it has an initial value\n  f $ compact (Poll.stToPoll r <|> (Just <$> p))\n\nuseMailboxed'\n  :: forall a b\n   . Ord a\n  => Hook (({ address :: a, payload :: b } -> Effect Unit) /\\ (a -> Poll b))\nuseMailboxed' f = Nut $ mkEffectFn2 \\psr di -> do\n  { poll, push } <- liftST $ Poll.mailbox\n  runEffectFn2 (coerce $ f (push /\\ poll)) psr di\n\nuseMailboxed\n  :: forall a b\n   . Ord a\n  => { address :: a, payload :: b }\n  -> Hook (({ address :: a, payload :: b } -> Effect Unit) /\\ (a -> Poll b))\nuseMailboxed i f = Nut $ mkEffectFn2 \\psr di -> do\n  { poll, push } <- liftST $ Poll.mailbox\n  runEffectFn2\n    ( coerce $ f\n        ( push /\\\n            ( alt <$> (eq i.address >>> if _ then pure i.payload else empty) <*>\n                poll\n            )\n        )\n    )\n    psr\n    di\n\nuseMailboxedS'\n  :: forall b\n   . Hook\n       ( ({ address :: String, payload :: b } -> Effect Unit) /\\\n           (String -> Poll b)\n       )\nuseMailboxedS' f = Nut $ mkEffectFn2 \\psr di -> do\n  { poll, push } <- liftST $ Poll.mailboxS\n  runEffectFn2 (coerce $ f (push /\\ poll)) psr di\n\nuseMailboxedS\n  :: forall b\n   . { address :: String, payload :: b }\n  -> Hook (({ address :: String, payload :: b } -> Effect Unit) /\\ (String -> Poll b))\nuseMailboxedS i f = Nut $ mkEffectFn2 \\psr di -> do\n  { poll, push } <- liftST $ Poll.mailbox\n  runEffectFn2\n    ( coerce $ f\n        ( push /\\\n            ( alt <$> (eq i.address >>> if _ then pure i.payload else empty) <*>\n                poll\n            )\n        )\n    )\n    psr\n    di\n\nuseRant :: forall a. Poll a -> Hook (Poll a)\nuseRant e f = Nut $ mkEffectFn2 \\psr di -> do\n  { poll, unsubscribe } <- liftST $ Poll.rant e\n  runEffectFn2 deferO psr (liftST unsubscribe)\n  runEffectFn2 (coerce $ f poll) psr di\n\nuseSkimmed :: forall a. Poll a -> Hook (Poll a)\nuseSkimmed x f = Nut $ mkEffectFn2 \\psr di -> do\n  diffusingRef <- liftST $ ST.new false\n  receptacleRef <- liftST $ ST.new List.Nil\n  bang <- liftST $ Event.create\n  hot <- liftST $ Event.create\n  uu <- Event.subscribe (Poll.sample x bang.event) \\i -> do\n    diffusing <- liftST $ ST.read diffusingRef\n    if diffusing then hot.push i\n    else liftST $ void $ ST.modify (i : _) receptacleRef\n  bang.push identity\n  receptacle <- liftST $ ST.read receptacleRef\n  liftST $ void $ ST.write true diffusingRef\n  let\n    oPoll = case receptacle of\n      List.Cons i _ -> PureAndEvent [ i ] hot.event\n      List.Nil -> OnlyEvent hot.event\n  runEffectFn2 deferO psr uu\n  runEffectFn2 (coerce $ f oPoll) psr di\n\nuseSplit :: forall a. Poll a -> Hook { first :: Poll a, second :: Poll a }\nuseSplit e f = Nut $ mkEffectFn2 \\psr di -> do\n  { poll, unsubscribe } <- liftST $ Poll.rant e\n  p0 <- liftST $ Poll.create\n  p1 <- liftST $ Poll.create\n  e0 <- liftST $ Event.create\n  o <- Event.subscribe (Poll.sample poll e0.event) \\i -> do\n    p0.push i\n    p1.push i\n  e0.push identity\n  runEffectFn2 deferO psr (o *> liftST unsubscribe)\n  runEffectFn2 (coerce $ f { first: p0.poll, second: p1.poll }) psr di\n\nuseRant'\n  :: forall t a\n   . (Poll t -> Poll a)\n  -> Hook ((t -> Effect Unit) /\\ Poll a)\nuseRant' f0 f1 = Deku.do\n  push /\\ e <- useState'\n  m <- useRant (f0 e)\n  f1 (push /\\ m)\n\nuseRef :: forall a. a -> Poll a -> Hook (Effect a)\nuseRef a b f = Deku.do\n  r <- useRefST a b\n  f (liftST r)\n\ndeferO :: EffectFn2 PSR (Effect Unit) Unit\ndeferO = mkEffectFn2 \\psr eff -> liftST\n  (runSTFn1 (un PSR psr).addEffectToDisposalQueue eff)\n\ndefer :: PSR -> Effect Unit -> Effect Unit\ndefer =\n  runEffectFn2 deferO\n\nuseRefST :: forall a. a -> Poll a -> Hook (ST.ST Global a)\nuseRefST a e f = Nut $ mkEffectFn2 \\psr di -> do\n  r <- liftST $ ST.new a\n  { event, push } <- liftST $ Event.create\n  u <- Event.subscribe (Poll.sample e event) \\i -> void $ liftST $ ST.write i r\n  push identity\n  let Nut nut = f (ST.read r)\n  runEffectFn2 deferO psr u\n  runEffectFn2 nut psr di\n\nuseState' :: forall a. Hook ((a -> Effect Unit) /\\ Poll a)\nuseState' f = Nut $ mkEffectFn2 \\psr di -> do\n  { poll, push } <- liftST $ Poll.create\n  let Nut nut = f (push /\\ poll)\n  runEffectFn2 nut psr di\n\nuseStateTagged' :: forall a. String -> Hook ((a -> Effect Unit) /\\ Poll a)\nuseStateTagged' tag f = Nut $ mkEffectFn2 \\psr di -> do\n  { poll, push } <- liftST $ Poll.createTagged tag\n  let Nut nut = f (push /\\ poll)\n  runEffectFn2 nut psr di\n\nuseState :: forall a. a -> Hook ((a -> Effect Unit) /\\ Poll a)\nuseState a f = Nut $ mkEffectFn2 \\psr di -> do\n  { poll, push } <- liftST $ Poll.create\n  let Nut nut = f (push /\\ (pure a <|> poll))\n  runEffectFn2 nut psr di\n\n-- dyn\ntype DynOptions value =\n  { sendTo :: value -> Poll Int\n  , remove :: value -> Poll Unit\n  }\n\ntype DynControl value =\n  { value :: value\n  , position :: Poll Int\n  , remove :: Effect Unit\n  , sendTo :: Int -> Effect Unit\n  }\n\ndynOptions :: forall v. DynOptions v\ndynOptions = { sendTo: \\_ -> empty, remove: \\_ -> empty }\n\nuseDyn\n  :: forall value\n   . Poll (Tuple (Maybe Int) value)\n  -> Hook (DynControl value)\nuseDyn p = useDynWith p dynOptions\n\nuseDynAtBeginning\n  :: forall value\n   . Poll value\n  -> Hook (DynControl value)\nuseDynAtBeginning b = useDynAtBeginningWith b dynOptions\n\nuseDynAtBeginningWith\n  :: forall value\n   . Poll value\n  -> DynOptions value\n  -> Hook (DynControl value)\nuseDynAtBeginningWith e = useDynWith (map (Just 0 /\\ _) e)\n\nuseDynAtEnd\n  :: forall value\n   . Poll value\n  -> Hook (DynControl value)\nuseDynAtEnd b = useDynAtEndWith b dynOptions\n\nuseDynAtEndWith\n  :: forall value\n   . Poll value\n  -> DynOptions value\n  -> Hook (DynControl value)\nuseDynAtEndWith e = useDynWith (map (Nothing /\\ _) e)\n\nuseDynWith\n  :: forall value\n   . Poll (Tuple (Maybe Int) value)\n  -> DynOptions value\n  -> Hook (DynControl value)\nuseDynWith elements options cont = Nut $ mkEffectFn2 \\psr di' -> do\n\n  liftST $ runSTFn1 (un DOMInterpret di').initializeDynRendering\n    (un PSR psr).ancestry\n\n  Region region <- liftST $ (un StaticRegion (un PSR psr).region).region\n  span <- liftST $ runSTFn2 newSpan region.begin region.bump\n  let ancestry = (un PSR psr).ancestry\n  aref <- liftST $ STRef.new (-1)\n\n  let\n    handleElements :: Boolean -> EffectFn1 (Tuple (Maybe Int) value) Unit\n    handleElements isStatic = mkEffectFn1 \\(Tuple initialPos value) -> do\n      let\n        di =\n          if isStatic then di'\n          else (un DOMInterpret di').dynamicDOMInterpret unit\n      Region eltRegion <- liftST $ runSTFn2 allocateRegion initialPos span\n      staticRegion <- liftST $ runSTFn2 newStaticRegion\n        eltRegion.begin\n        eltRegion.bump\n\n      -- this controls whether the user can influence the element via `remove` or `sentTo`, it will change to `false`\n      -- after initialization and back to `true` before removal. This means that the user is only in control the element\n      -- between initialization and removal.\n      eltDisposed <- liftST $ ST.new true\n\n      eltSendTo <- liftST Poll.create\n      let\n        sendTo :: Poll Int\n        sendTo =\n          Poll.merge [ options.sendTo value, eltSendTo.poll ]\n\n      eltRemove <- liftST Poll.create\n      let\n        remove :: Poll Unit\n        remove =\n          Poll.merge\n            [ options.remove value $> unit\n            , eltRemove.poll $> unit\n            , (un PSR psr).signalDisposalQueueShouldBeTriggered\n            ]\n\n      eltLifecycle <- liftST Poll.create\n      a <- liftST $ STRef.modify (add 1) aref\n      eltPSR <- liftST $ runSTFn3 newPSR (Ancestry.dyn a ancestry)\n        eltLifecycle.poll\n        staticRegion\n      let\n        Nut nut = cont\n          { value\n          , position: eltRegion.position\n          , remove: eltRemove.push unit\n          , sendTo: eltSendTo.push\n          }\n\n        handleSendTo :: EffectFn1 Int Unit\n        handleSendTo = mkEffectFn1 \\newPos -> do\n          whenM (not <$> liftST (ST.read eltDisposed)) do\n            fromBegin <- liftST eltRegion.begin\n            fromEnd <- liftST eltRegion.end\n            liftST $ runSTFn1 eltRegion.sendTo newPos\n\n            target <- liftST eltRegion.begin\n            runEffectFn3 (un DOMInterpret di).beamRegion fromBegin fromEnd\n              target\n\n        -- | We need explicit ordering here, if just pass the lifecycle of the parent to the child element it is not \n        -- | guarantueed that the child will dispose itself before the parent.\n        handleRemove :: Effect Unit\n        handleRemove = whenM (not <$> liftST (ST.read eltDisposed)) do\n          -- disable user control\n          void $ liftST $ ST.write true eltDisposed\n          eltLifecycle.push unit\n          liftST eltRegion.remove\n\n      pump eltPSR sendTo handleSendTo\n      pump eltPSR (once remove) $ mkEffectFn1 \\_ -> handleRemove\n      runEffectFn2 nut eltPSR di\n      -- enable user control\n      void $ liftST $ ST.write false eltDisposed\n\n  pump' psr elements handleElements\n\n  runEffectFn1 handleScope psr\n\nfixed :: Array Nut -> Nut\nfixed nuts = Nut $ mkEffectFn2 \\psr di -> do\n  emptyScope <- liftST $ runSTFn3 newPSR\n    (un PSR psr).ancestry\n    (un PSR psr).signalDisposalQueueShouldBeTriggered\n    (un PSR psr).region\n  aref <- liftST $ STRef.new (-1)\n  liftST $ runSTFn1 (un DOMInterpret di).initializeFixedRendering\n    (un PSR psr).ancestry\n\n  let\n    handleNuts :: EffectFn1 Nut Unit\n    handleNuts = mkEffectFn1 \\(Nut nut) -> do\n      a <- liftST $ STRef.modify (add 1) aref\n      runEffectFn2 nut\n        ( over PSR (\\i -> i { ancestry = Ancestry.fixed a i.ancestry })\n            emptyScope\n        )\n        di\n\n  -- run `nuts` with separate scope\n  runEffectFn2 Event.fastForeachE nuts handleNuts\n  -- actually handle the scope\n  runEffectFn1 handleScope psr\n\nelementify\n  :: forall element\n   . Maybe String\n  -> String\n  -> Array (Poll (Attribute element))\n  -> Array Nut\n  -> Nut\nelementify ns tag arrAtts nuts = Nut $ mkEffectFn2 \\psr di -> do\n  let isBoring = (un DOMInterpret di).isBoring (un PSR psr).ancestry\n  when (not isBoring) do\n    elt <- runEffectFn3 (un DOMInterpret di).makeElement (un PSR psr).ancestry\n      (Namespace <$> ns)\n      (Tag tag)\n    regionEnd <- liftST (un StaticRegion (un PSR psr).region).end\n    liftST $ runSTFn1 (un StaticRegion (un PSR psr).region).element\n      (Element (elt))\n\n    -- runEffectFn2 deferO psr do\n    --   runEffectFn1 (un DOMInterpret di).removeElement elt\n\n    ---\n    --- ssr management\n\n    liftST $ runSTFn2 (un DOMInterpret di).initializeElementRendering\n      (un PSR psr).ancestry\n      elt\n\n    --- end ssr management\n    ---\n\n    let\n      handleAtts :: EffectFn1 (Poll (Attribute element)) Unit\n      handleAtts = mkEffectFn1 \\atts -> do\n        case atts of\n          OnlyPure _ -> pure unit\n          _ -> liftST $ runSTFn1\n            (un DOMInterpret di).markElementAsImpure\n            (un PSR psr).ancestry\n        pump' psr atts $ \\useOriginalDi -> do\n          let\n            newDi =\n              if useOriginalDi then di\n              else (un DOMInterpret di).dynamicDOMInterpret unit\n          mkEffectFn1 \\(Attribute x) ->\n            runEffectFn3 x (un PSR psr).ancestry (fromDekuElement elt) newDi\n\n    runEffectFn2 Event.fastForeachE arrAtts handleAtts\n\n    eltRegion <- liftST $ runSTFn1 fromParent $ DekuParent elt\n    aref <- liftST $ STRef.new (-1)\n\n    let\n      handleNuts :: EffectFn1 Nut Unit\n      handleNuts = mkEffectFn1 \\(Nut nut) -> do\n        a <- liftST $ STRef.modify (add 1) aref\n        scope <- liftST $ runSTFn3 newPSR\n          (Ancestry.element a (un PSR psr).ancestry)\n          (un PSR psr).signalDisposalQueueShouldBeTriggered\n          eltRegion\n        runEffectFn2 nut scope di\n\n    runEffectFn2 Event.fastForeachE nuts handleNuts\n\n    let\n      handleRemove :: Effect Unit\n      handleRemove = when\n        (not (hasElementParent (un PSR psr).ancestry))\n        do\n          runEffectFn1 (un DOMInterpret di).removeElement elt\n\n    runEffectFn2 (un DOMInterpret di).attachElement (DekuChild elt) regionEnd\n\n    liftST $ runSTFn1 (un PSR psr).addEffectToDisposalQueue handleRemove\n\n    runEffectFn1 handleScope psr\n\ntext_ :: String -> Nut\ntext_ txt =\n  text (pure @Poll txt)\n\ntext :: Poll String -> Nut\ntext texts = Nut $ mkEffectFn2 \\psr di -> do\n  let ancestry = (un PSR psr).ancestry\n  txt <- case texts of\n    OnlyPure xs -> do\n      runEffectFn2 (un DOMInterpret di).makeText\n        ancestry\n        (Array.last xs)\n\n    OnlyEvent _ -> do\n      runEffectFn2 (un DOMInterpret di).makeText\n        ancestry\n        Nothing\n\n    OnlyPoll _ -> do\n      runEffectFn2 (un DOMInterpret di).makeText\n        ancestry\n        Nothing\n\n    PureAndEvent xs _ -> do\n      runEffectFn2 (un DOMInterpret di).makeText\n        ancestry\n        (Array.last xs)\n\n    PureAndPoll xs _ -> do\n      runEffectFn2 (un DOMInterpret di).makeText\n        ancestry\n        (Array.last xs)\n\n  liftST $ runSTFn2 (un DOMInterpret di).initializeTextRendering\n    (un PSR psr).ancestry\n    txt\n\n  let\n    modifiedPoll = case texts of\n      OnlyPure _ -> OnlyPure []\n\n      OnlyEvent e -> OnlyEvent e\n\n      OnlyPoll p -> OnlyPoll p\n\n      PureAndEvent _ e -> OnlyEvent e\n\n      PureAndPoll _ p -> OnlyPoll p\n\n  case texts of\n    OnlyPure _ -> pure unit\n    _ -> liftST $ runSTFn1 (un DOMInterpret di).markTextAsImpure ancestry\n\n  let\n    handleTextUpdate :: Boolean -> EffectFn1 String Unit\n    handleTextUpdate useOriginalDi = mkEffectFn1 \\x -> do\n      let\n        di2 =\n          if useOriginalDi then di\n          else (un DOMInterpret di).dynamicDOMInterpret unit\n      runEffectFn2 (un DOMInterpret di2).setText x txt\n\n  pump' psr modifiedPoll handleTextUpdate\n  regionEnd <- liftST (un StaticRegion (un PSR psr).region).end\n  runEffectFn2 (un DOMInterpret di).attachText txt regionEnd\n  liftST $ runSTFn1 (un StaticRegion (un PSR psr).region).element (Text txt)\n\n  let\n    handleRemove :: Effect Unit\n    handleRemove = when\n      (not (hasElementParent (un PSR psr).ancestry))\n      do\n        runEffectFn1 (un DOMInterpret di).removeText txt\n\n  liftST $ runSTFn1 (un PSR psr).addEffectToDisposalQueue handleRemove\n  runEffectFn1 handleScope psr\n\n-- | Creates a `Nut` that can be attached to another part of the application. The lifetime of the `Nut` is no longer\n-- | than that of `Nut` that created it.\n-- maybe also attach the lifetime to its mountpoints and/or do reference counting\nportal :: Nut -> Hook Nut\nportal (Nut toBeam) cont = Nut $ mkEffectFn2 \\psr di -> do\n\n  liftST $ runSTFn1 (un DOMInterpret di).initializePortalRendering\n    (un PSR psr).ancestry\n  -- set up a StaticRegion for the portal contents and track its begin and end\n  Tuple portalIx buffer' <- (un DOMInterpret di).bufferPortal\n  let buffer = pure $ ParentStart buffer'\n\n  trackBegin <- liftST $ ST.new buffer\n  trackEnd <- liftST $ ST.new $ Nothing @Anchor\n\n  -- signal for other locations of the portal that its contents have moved\n  beamed <- liftST Event.create\n  bumped <- liftST Event.createPure\n\n  staticBuffer <- liftST $ runSTFn2 newStaticRegion\n    (join $ ST.read trackBegin)\n    ( mkSTFn1 \\bound -> do\n        void $ ST.write bound trackEnd\n        bumped.push bound\n    )\n  let myAncestry = Ancestry.portal portalIx (un PSR psr).ancestry\n  runEffectFn2 toBeam\n    (over PSR (_ { ancestry = myAncestry, region = staticBuffer }) psr)\n    $ (un DOMInterpret di).portalDOMInterpret myAncestry\n\n  let\n    Nut hooked = cont $ portaled myAncestry buffer (beamed.push unit)\n      beamed.event\n      bumped.event\n      trackBegin\n      trackEnd\n\n    -- | We can't rely on our ancestor to move our nodes of the screen so we move portaled content of the screen back\n    -- | into the buffer. Afterwards we mark the buffer as empty so all references get lost.\n    dispose :: Effect Unit\n    dispose = do\n      beamed.push unit\n      begin <- liftST $ join $ ST.read trackBegin\n      end <- liftST $ ST.read trackEnd\n      target <- liftST buffer\n      runEffectFn3 (un DOMInterpret di).beamRegion begin (fromMaybe begin end)\n        target\n      void $ liftST $ ST.write Nothing trackEnd\n\n  runEffectFn2 deferO psr dispose\n  runEffectFn2 hooked psr di\n\nportaled\n  :: Ancestry\n  -> Bound\n  -> Effect Unit\n  -> Event.Event Unit\n  -> Event.Event (Maybe Anchor)\n  -> ST.STRef Global Bound\n  -> ST.STRef Global (Maybe Anchor)\n  -> Nut\nportaled myAncestry buffer beam beamed bumped trackBegin trackEnd =\n  Nut $ mkEffectFn2 \\psr di -> do\n\n    liftST $ runSTFn1 (un DOMInterpret di).markPortalAsRendered myAncestry\n    -- signal to other portaled `Nut`s that we are about to steal their content\n    beam\n\n    -- set up region and its eventual cleanup\n    Region region <- liftST (un StaticRegion (un PSR psr).region).region\n    stolen <- liftST $ ST.new false\n\n    unsubBeamed <- runEffectFn2 Event.subscribeO beamed $ mkEffectFn1 \\_ -> do\n      whenM (not <$> liftST (ST.read stolen)) do\n        void $ liftST $ ST.write true stolen\n\n    unsubBumped <- runEffectFn2 Event.subscribeO bumped $ mkEffectFn1 $ liftST\n      <<< runSTFn1 region.bump\n\n    -- region starts empty, only bump when we actually have an end\n    liftST $ ST.read trackEnd >>= traverse_ (runSTFn1 region.bump <<< Just)\n\n    -- actuall insert portal contents\n    do\n      begin <- liftST $ join $ ST.read trackBegin\n      end <- liftST $ ST.read trackEnd\n      target <- liftST region.begin\n      runEffectFn3 (un DOMInterpret di).beamRegion begin (fromMaybe begin end)\n        target\n\n    -- update the tracked begin so other portaled `Nut`s can steal the contents correctly\n    void $ liftST $ ST.write region.begin trackBegin\n\n    -- lifecycle handling\n    liftST $ runSTFn1 (un PSR psr).addEffectToDisposalQueue\n      (unsubBeamed *> unsubBumped)\n\n    let\n      restoreBuffer :: Effect Unit\n      restoreBuffer = do\n        whenM (not <$> liftST (ST.read stolen)) do\n          -- send portaled content back to buffer\n          begin <- liftST region.begin\n          end <- liftST $ ST.read trackEnd\n          target <- liftST buffer\n          runEffectFn3 (un DOMInterpret di).beamRegion begin\n            (fromMaybe begin end)\n            target\n          void $ liftST $ ST.write buffer trackBegin\n          void $ liftST $ ST.write true stolen\n\n    runEffectFn2 deferO psr restoreBuffer\n    runEffectFn1 handleScope psr", "-- | This module contains reexports of all the DOM elements.\n-- This module has been automatically generated by running `spago run -p codegen`.\n-- Any changes may be overwritten.\nmodule Deku.DOM\n  ( module Deku.Control\n  , module Deku.Attribute\n  , class TagToDeku\n  , html\n  , html_\n  , html__\n  , head\n  , head_\n  , head__\n  , title\n  , title_\n  , title__\n  , base\n  , base_\n  , base__\n  , link\n  , link_\n  , link__\n  , meta\n  , meta_\n  , meta__\n  , style\n  , style_\n  , style__\n  , body\n  , body_\n  , body__\n  , article\n  , article_\n  , article__\n  , section\n  , section_\n  , section__\n  , nav\n  , nav_\n  , nav__\n  , aside\n  , aside_\n  , aside__\n  , h1\n  , h1_\n  , h1__\n  , h2\n  , h2_\n  , h2__\n  , h3\n  , h3_\n  , h3__\n  , h4\n  , h4_\n  , h4__\n  , h5\n  , h5_\n  , h5__\n  , h6\n  , h6_\n  , h6__\n  , hgroup\n  , hgroup_\n  , hgroup__\n  , header\n  , header_\n  , header__\n  , footer\n  , footer_\n  , footer__\n  , address\n  , address_\n  , address__\n  , p\n  , p_\n  , p__\n  , hr\n  , hr_\n  , hr__\n  , pre\n  , pre_\n  , pre__\n  , blockquote\n  , blockquote_\n  , blockquote__\n  , ol\n  , ol_\n  , ol__\n  , ul\n  , ul_\n  , ul__\n  , menu\n  , menu_\n  , menu__\n  , li\n  , li_\n  , li__\n  , dl\n  , dl_\n  , dl__\n  , dt\n  , dt_\n  , dt__\n  , dd\n  , dd_\n  , dd__\n  , figure\n  , figure_\n  , figure__\n  , figcaption\n  , figcaption_\n  , figcaption__\n  , main\n  , main_\n  , main__\n  , search\n  , search_\n  , search__\n  , div\n  , div_\n  , div__\n  , a\n  , a_\n  , a__\n  , em\n  , em_\n  , em__\n  , strong\n  , strong_\n  , strong__\n  , small\n  , small_\n  , small__\n  , s\n  , s_\n  , s__\n  , cite\n  , cite_\n  , cite__\n  , q\n  , q_\n  , q__\n  , dfn\n  , dfn_\n  , dfn__\n  , abbr\n  , abbr_\n  , abbr__\n  , ruby\n  , ruby_\n  , ruby__\n  , rt\n  , rt_\n  , rt__\n  , rp\n  , rp_\n  , rp__\n  , xdata\n  , xdata_\n  , xdata__\n  , time\n  , time_\n  , time__\n  , code\n  , code_\n  , code__\n  , var\n  , var_\n  , var__\n  , samp\n  , samp_\n  , samp__\n  , kbd\n  , kbd_\n  , kbd__\n  , sub\n  , sub_\n  , sub__\n  , sup\n  , sup_\n  , sup__\n  , i\n  , i_\n  , i__\n  , b\n  , b_\n  , b__\n  , u\n  , u_\n  , u__\n  , mark\n  , mark_\n  , mark__\n  , bdi\n  , bdi_\n  , bdi__\n  , bdo\n  , bdo_\n  , bdo__\n  , span\n  , span_\n  , span__\n  , br\n  , br_\n  , br__\n  , wbr\n  , wbr_\n  , wbr__\n  , ins\n  , ins_\n  , ins__\n  , del\n  , del_\n  , del__\n  , picture\n  , picture_\n  , picture__\n  , source\n  , source_\n  , source__\n  , img\n  , img_\n  , img__\n  , iframe\n  , iframe_\n  , iframe__\n  , embed\n  , embed_\n  , embed__\n  , object\n  , object_\n  , object__\n  , video\n  , video_\n  , video__\n  , audio\n  , audio_\n  , audio__\n  , track\n  , track_\n  , track__\n  , map\n  , map_\n  , map__\n  , area\n  , area_\n  , area__\n  , table\n  , table_\n  , table__\n  , caption\n  , caption_\n  , caption__\n  , colgroup\n  , colgroup_\n  , colgroup__\n  , col\n  , col_\n  , col__\n  , tbody\n  , tbody_\n  , tbody__\n  , thead\n  , thead_\n  , thead__\n  , tfoot\n  , tfoot_\n  , tfoot__\n  , tr\n  , tr_\n  , tr__\n  , td\n  , td_\n  , td__\n  , th\n  , th_\n  , th__\n  , form\n  , form_\n  , form__\n  , label\n  , label_\n  , label__\n  , input\n  , input_\n  , input__\n  , button\n  , button_\n  , button__\n  , select\n  , select_\n  , select__\n  , datalist\n  , datalist_\n  , datalist__\n  , optgroup\n  , optgroup_\n  , optgroup__\n  , option\n  , option_\n  , option__\n  , textarea\n  , textarea_\n  , textarea__\n  , output\n  , output_\n  , output__\n  , progress\n  , progress_\n  , progress__\n  , meter\n  , meter_\n  , meter__\n  , fieldset\n  , fieldset_\n  , fieldset__\n  , legend\n  , legend_\n  , legend__\n  , details\n  , details_\n  , details__\n  , summary\n  , summary_\n  , summary__\n  , dialog\n  , dialog_\n  , dialog__\n  , script\n  , script_\n  , script__\n  , noscript\n  , noscript_\n  , noscript__\n  , template\n  , template_\n  , template__\n  , slot\n  , slot_\n  , slot__\n  , canvas\n  , canvas_\n  , canvas__\n  , applet\n  , applet_\n  , applet__\n  , acronym\n  , acronym_\n  , acronym__\n  , bgsound\n  , bgsound_\n  , bgsound__\n  , dir\n  , dir_\n  , dir__\n  , frame\n  , frame_\n  , frame__\n  , frameset\n  , frameset_\n  , frameset__\n  , noframes\n  , noframes_\n  , noframes__\n  , isindex\n  , isindex_\n  , isindex__\n  , keygen\n  , keygen_\n  , keygen__\n  , listing\n  , listing_\n  , listing__\n  , menuitem\n  , menuitem_\n  , menuitem__\n  , nextid\n  , nextid_\n  , nextid__\n  , noembed\n  , noembed_\n  , noembed__\n  , param\n  , param_\n  , param__\n  , plaintext\n  , plaintext_\n  , plaintext__\n  , rb\n  , rb_\n  , rb__\n  , rtc\n  , rtc_\n  , rtc__\n  , strike\n  , strike_\n  , strike__\n  , xmp\n  , xmp_\n  , xmp__\n  , basefont\n  , basefont_\n  , basefont__\n  , big\n  , big_\n  , big__\n  , blink\n  , blink_\n  , blink__\n  , center\n  , center_\n  , center__\n  , font\n  , font_\n  , font__\n  , marquee\n  , marquee_\n  , marquee__\n  , multicol\n  , multicol_\n  , multicol__\n  , nobr\n  , nobr_\n  , nobr__\n  , spacer\n  , spacer_\n  , spacer__\n  , tt\n  , tt_\n  , tt__\n  , ARIAMixin\n  , HTMLElement\n  , HTMLUnknownElement\n  , HTMLOrSVGElement\n  , HTMLHtmlElement\n  , HTMLHeadElement\n  , HTMLTitleElement\n  , HTMLBaseElement\n  , HTMLLinkElement\n  , HTMLMetaElement\n  , HTMLStyleElement\n  , HTMLBodyElement\n  , HTMLHeadingElement\n  , HTMLParagraphElement\n  , HTMLHRElement\n  , HTMLPreElement\n  , HTMLQuoteElement\n  , HTMLOListElement\n  , HTMLUListElement\n  , HTMLMenuElement\n  , HTMLLIElement\n  , HTMLDListElement\n  , HTMLDivElement\n  , HTMLAnchorElement\n  , HTMLDataElement\n  , HTMLTimeElement\n  , HTMLSpanElement\n  , HTMLBRElement\n  , HTMLHyperlinkElementUtils\n  , HTMLModElement\n  , HTMLPictureElement\n  , HTMLSourceElement\n  , HTMLImageElement\n  , HTMLIFrameElement\n  , HTMLEmbedElement\n  , HTMLObjectElement\n  , HTMLVideoElement\n  , HTMLAudioElement\n  , HTMLTrackElement\n  , HTMLMediaElement\n  , HTMLMapElement\n  , HTMLAreaElement\n  , HTMLTableElement\n  , HTMLTableCaptionElement\n  , HTMLTableColElement\n  , HTMLTableSectionElement\n  , HTMLTableRowElement\n  , HTMLTableCellElement\n  , HTMLFormElement\n  , HTMLLabelElement\n  , HTMLInputElement\n  , HTMLButtonElement\n  , HTMLSelectElement\n  , HTMLDataListElement\n  , HTMLOptGroupElement\n  , HTMLOptionElement\n  , HTMLTextAreaElement\n  , HTMLOutputElement\n  , HTMLProgressElement\n  , HTMLMeterElement\n  , HTMLFieldSetElement\n  , HTMLLegendElement\n  , HTMLDetailsElement\n  , HTMLDialogElement\n  , HTMLScriptElement\n  , HTMLTemplateElement\n  , HTMLSlotElement\n  , HTMLCanvasElement\n  , ElementContentEditable\n  , PopoverInvokerElement\n  , GlobalEventHandlers\n  , WindowEventHandlers\n  , HTMLMarqueeElement\n  , HTMLFrameSetElement\n  , HTMLFrameElement\n  , HTMLDirectoryElement\n  , HTMLFontElement\n  , HTMLParamElement\n  , EventTarget\n  , ParentNode\n  , NonDocumentTypeChildNode\n  , ChildNode\n  , Slottable\n  , Node\n  , Element\n  ) where\n\nimport Deku.Control (text, text_) as Deku.Control\nimport FRP.Poll as FRP.Poll\nimport Data.Maybe (Maybe(..))\nimport Deku.Attribute (Attribute) as Deku.Attribute\nimport Deku.Control (elementify)\nimport Deku.Control as DC\nimport Deku.Core (Nut)\nimport Type.Proxy (Proxy)\nimport Web.Event.Internal.Types as Web.Event.Internal.Types\nimport Web.PointerEvent.PointerEvent as Web.PointerEvent.PointerEvent\nimport Web.HTML.Event.DragEvent as Web.HTML.Event.DragEvent\nimport Web.UIEvent.KeyboardEvent as Web.UIEvent.KeyboardEvent\nimport Web.UIEvent.FocusEvent as Web.UIEvent.FocusEvent\nimport Web.UIEvent.UIEvent as Web.UIEvent.UIEvent\nimport Web.UIEvent.MouseEvent as Web.UIEvent.MouseEvent\nimport Web.UIEvent.CompositionEvent as Web.UIEvent.CompositionEvent\nimport Web.TouchEvent.TouchEvent as Web.TouchEvent.TouchEvent\n\nclass TagToDeku (tag :: Symbol) (interface :: Row Type) | tag -> interface\ntype ARIAMixin (r :: Row Type) =\n  ( __tag :: Proxy \"ARIAMixin\"\n  , ariaValuetext :: String\n  , ariaValuenow :: String\n  , ariaValuemin :: String\n  , ariaValuemax :: String\n  , ariaSort :: String\n  , ariaSetsize :: String\n  , ariaSelected :: String\n  , ariaRowspan :: String\n  , ariaRowindextext :: String\n  , ariaRowindex :: String\n  , ariaRowcount :: String\n  , ariaRoledescription :: String\n  , ariaRequired :: String\n  , ariaReadonly :: String\n  , ariaPressed :: String\n  , ariaPosinset :: String\n  , ariaPlaceholder :: String\n  , ariaOwns :: String\n  , ariaOrientation :: String\n  , ariaMultiselectable :: String\n  , ariaMultiline :: String\n  , ariaModal :: String\n  , ariaLive :: String\n  , ariaLevel :: String\n  , ariaLabelledby :: String\n  , ariaLabel :: String\n  , ariaKeyshortcuts :: String\n  , ariaInvalid :: String\n  , ariaHidden :: String\n  , ariaHaspopup :: String\n  , ariaFlowto :: String\n  , ariaExpanded :: String\n  , ariaErrormessage :: String\n  , ariaDisabled :: String\n  , ariaDetails :: String\n  , ariaDescription :: String\n  , ariaDescribedby :: String\n  , ariaCurrent :: String\n  , ariaControls :: String\n  , ariaColspan :: String\n  , ariaColindextext :: String\n  , ariaColindex :: String\n  , ariaColcount :: String\n  , ariaChecked :: String\n  , ariaBusy :: String\n  , ariaBrailleroledescription :: String\n  , ariaBraillelabel :: String\n  , ariaAutocomplete :: String\n  , ariaAtomic :: String\n  , ariaActivedescendant :: String\n  , role :: String\n  | r\n  )\n\ntype HTMLElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLElement\"\n  , popovertargetaction :: String\n  , popovertarget :: String\n  , popover :: String\n  , draggable :: String\n  , enterkeyhint :: String\n  , inputmode :: String\n  , autocapitalize :: String\n  , writingsuggestions :: String\n  , spellcheck :: String\n  , contenteditable :: String\n  , accesskey :: String\n  , autofocus :: String\n  , hidden :: String\n  , itemprop :: String\n  , itemref :: String\n  , itemid :: String\n  , itemtype :: String\n  , itemscope :: String\n  , is :: String\n  , title :: String\n  , style :: String\n  , dir :: String\n  , translate :: String\n  , lang :: String\n  , load :: Web.Event.Internal.Types.Event\n  , error :: Web.Event.Internal.Types.Event\n  , beforetoggle :: Web.Event.Internal.Types.Event\n  , beforematch :: Web.Event.Internal.Types.Event\n  | HTMLOrSVGElement (ElementContentEditable (GlobalEventHandlers (Element r)))\n  )\n\ntype HTMLUnknownElement (r :: Row Type) = (__tag :: Proxy \"HTMLUnknownElement\" | HTMLElement r)\ntype HTMLOrSVGElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLOrSVGElement\", tabindex :: String, nonce :: String | r)\n\ntype HTMLHtmlElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLHtmlElement\", version :: String, manifest :: String | HTMLElement r)\n\ntype HTMLHeadElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLHeadElement\", profile :: String | HTMLElement r)\n\ntype HTMLTitleElement (r :: Row Type) = (__tag :: Proxy \"HTMLTitleElement\" | HTMLElement r)\ntype HTMLBaseElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLBaseElement\", target :: String, href :: String | HTMLElement r)\n\ntype HTMLLinkElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLLinkElement\"\n  , target :: String\n  , urn :: String\n  , rev :: String\n  , methods :: String\n  , charset :: String\n  , fetchpriority :: String\n  , disabled :: String\n  , color :: String\n  , blocking :: String\n  , as :: String\n  , sizes :: String\n  , imagesizes :: String\n  , imagesrcset :: String\n  , title :: String\n  , referrerpolicy :: String\n  , xtype :: String\n  , hreflang :: String\n  , integrity :: String\n  , media :: String\n  , crossorigin :: String\n  , rel :: String\n  , href :: String\n  | HTMLElement r\n  )\n\ntype HTMLMetaElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLMetaElement\"\n  , scheme :: String\n  , httpEquiv :: String\n  , media :: String\n  , name :: String\n  , content :: String\n  , charset :: String\n  | HTMLElement r\n  )\n\ntype HTMLStyleElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLStyleElement\"\n  , xtype :: String\n  , title :: String\n  , blocking :: String\n  , media :: String\n  | HTMLElement r\n  )\n\ntype HTMLBodyElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLBodyElement\"\n  , vlink :: String\n  , topmargin :: String\n  , text :: String\n  , rightmargin :: String\n  , marginwidth :: String\n  , marginheight :: String\n  , link :: String\n  , leftmargin :: String\n  , bottommargin :: String\n  , bgcolor :: String\n  , alink :: String\n  | WindowEventHandlers (HTMLElement r)\n  )\n\ntype HTMLHeadingElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLHeadingElement\", align :: String | HTMLElement r)\n\ntype HTMLParagraphElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLParagraphElement\", align :: String | HTMLElement r)\n\ntype HTMLHRElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLHRElement\"\n  , width :: String\n  , size :: String\n  , noshade :: String\n  , color :: String\n  , align :: String\n  | HTMLElement r\n  )\n\ntype HTMLPreElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLPreElement\", width :: String | HTMLElement r)\n\ntype HTMLQuoteElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLQuoteElement\", cite :: String | HTMLElement r)\n\ntype HTMLOListElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLOListElement\"\n  , compact :: String\n  , xtype :: String\n  , start :: String\n  , reversed :: String\n  | HTMLElement r\n  )\n\ntype HTMLUListElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLUListElement\", xtype :: String, compact :: String | HTMLElement r)\n\ntype HTMLMenuElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLMenuElement\"\n  , compact :: String\n  , label :: String\n  , xtype :: String\n  | HTMLElement r\n  )\n\ntype HTMLLIElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLLIElement\", xtype :: String, value :: String | HTMLElement r)\n\ntype HTMLDListElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLDListElement\", compact :: String | HTMLElement r)\n\ntype HTMLDivElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLDivElement\", align :: String | HTMLElement r)\n\ntype HTMLAnchorElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLAnchorElement\"\n  , urn :: String\n  , rev :: String\n  , name :: String\n  , methods :: String\n  , shape :: String\n  , coords :: String\n  , charset :: String\n  , referrerpolicy :: String\n  , xtype :: String\n  , hreflang :: String\n  , rel :: String\n  , ping :: String\n  , download :: String\n  , target :: String\n  , href :: String\n  | HTMLHyperlinkElementUtils (HTMLElement r)\n  )\n\ntype HTMLDataElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLDataElement\", value :: String | HTMLElement r)\n\ntype HTMLTimeElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLTimeElement\", datetime :: String | HTMLElement r)\n\ntype HTMLSpanElement (r :: Row Type) = (__tag :: Proxy \"HTMLSpanElement\" | HTMLElement r)\ntype HTMLBRElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLBRElement\", clear :: String | HTMLElement r)\n\ntype HTMLHyperlinkElementUtils (r :: Row Type) = (__tag :: Proxy \"HTMLHyperlinkElementUtils\" | r)\ntype HTMLModElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLModElement\", datetime :: String, cite :: String | HTMLElement r)\n\ntype HTMLPictureElement (r :: Row Type) = (__tag :: Proxy \"HTMLPictureElement\" | HTMLElement r)\ntype HTMLSourceElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLSourceElement\"\n  , height :: String\n  , width :: String\n  , src :: String\n  , sizes :: String\n  , srcset :: String\n  , media :: String\n  , xtype :: String\n  , error :: Web.Event.Internal.Types.Event\n  | HTMLElement r\n  )\n\ntype HTMLImageElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLImageElement\"\n  , vspace :: String\n  , hspace :: String\n  , border :: String\n  , align :: String\n  , lowsrc :: String\n  , longdesc :: String\n  , name :: String\n  , height :: String\n  , width :: String\n  , usemap :: String\n  , ismap :: String\n  , loading :: String\n  , fetchpriority :: String\n  , decoding :: String\n  , referrerpolicy :: String\n  , crossorigin :: String\n  , sizes :: String\n  , alt :: String\n  , srcset :: String\n  , src :: String\n  | HTMLElement r\n  )\n\ntype HTMLIFrameElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLIFrameElement\"\n  , vspace :: String\n  , scrolling :: String\n  , marginwidth :: String\n  , marginheight :: String\n  , hspace :: String\n  , framespacing :: String\n  , frameborder :: String\n  , allowtransparency :: String\n  , align :: String\n  , longdesc :: String\n  , height :: String\n  , width :: String\n  , loading :: String\n  , referrerpolicy :: String\n  , allowfullscreen :: String\n  , allow :: String\n  , sandbox :: String\n  , name :: String\n  , srcdoc :: String\n  , src :: String\n  | HTMLElement r\n  )\n\ntype HTMLEmbedElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLEmbedElement\"\n  , vspace :: String\n  , hspace :: String\n  , align :: String\n  , name :: String\n  , height :: String\n  , width :: String\n  , xtype :: String\n  , src :: String\n  | HTMLElement r\n  )\n\ntype HTMLObjectElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLObjectElement\"\n  , vspace :: String\n  , hspace :: String\n  , border :: String\n  , align :: String\n  , typemustmatch :: String\n  , standby :: String\n  , declare :: String\n  , codetype :: String\n  , codebase :: String\n  , code :: String\n  , classid :: String\n  , archive :: String\n  , usemap :: String\n  , autocomplete :: String\n  , disabled :: String\n  , form :: String\n  , height :: String\n  , width :: String\n  , name :: String\n  , xtype :: String\n  , xdata :: String\n  | HTMLElement r\n  )\n\ntype HTMLVideoElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLVideoElement\"\n  , height :: String\n  , width :: String\n  , muted :: String\n  , controls :: String\n  , autoplay :: String\n  , loop :: String\n  , preload :: String\n  , crossorigin :: String\n  , src :: String\n  , playsinline :: String\n  , poster :: String\n  | HTMLMediaElement r\n  )\n\ntype HTMLAudioElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLAudioElement\"\n  , muted :: String\n  , controls :: String\n  , autoplay :: String\n  , loop :: String\n  , preload :: String\n  , crossorigin :: String\n  , src :: String\n  | HTMLMediaElement r\n  )\n\ntype HTMLTrackElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLTrackElement\"\n  , default :: String\n  , label :: String\n  , srclang :: String\n  , src :: String\n  , kind :: String\n  , load :: Web.Event.Internal.Types.Event\n  , error :: Web.Event.Internal.Types.Event\n  , cuechange :: Web.Event.Internal.Types.Event\n  | HTMLElement r\n  )\n\ntype HTMLMediaElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLMediaElement\"\n  , volumechange :: Web.Event.Internal.Types.Event\n  , resize :: Web.Event.Internal.Types.Event\n  , ratechange :: Web.Event.Internal.Types.Event\n  , pause :: Web.Event.Internal.Types.Event\n  , play :: Web.Event.Internal.Types.Event\n  , timeupdate :: Web.Event.Internal.Types.Event\n  , durationchange :: Web.Event.Internal.Types.Event\n  , ended :: Web.Event.Internal.Types.Event\n  , seeked :: Web.Event.Internal.Types.Event\n  , seeking :: Web.Event.Internal.Types.Event\n  , waiting :: Web.Event.Internal.Types.Event\n  , playing :: Web.Event.Internal.Types.Event\n  , canplaythrough :: Web.Event.Internal.Types.Event\n  , canplay :: Web.Event.Internal.Types.Event\n  , loadeddata :: Web.Event.Internal.Types.Event\n  , loadedmetadata :: Web.Event.Internal.Types.Event\n  , stalled :: Web.Event.Internal.Types.Event\n  , emptied :: Web.Event.Internal.Types.Event\n  , error :: Web.Event.Internal.Types.Event\n  , abort :: Web.Event.Internal.Types.Event\n  , suspend :: Web.Event.Internal.Types.Event\n  , progress :: Web.Event.Internal.Types.Event\n  , loadstart :: Web.Event.Internal.Types.Event\n  | HTMLElement r\n  )\n\ntype HTMLMapElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLMapElement\", name :: String | HTMLElement r)\n\ntype HTMLAreaElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLAreaElement\"\n  , nohref :: String\n  , xtype :: String\n  , hreflang :: String\n  , coords :: String\n  , shape :: String\n  , alt :: String\n  , referrerpolicy :: String\n  , rel :: String\n  , ping :: String\n  , download :: String\n  , target :: String\n  , href :: String\n  | HTMLHyperlinkElementUtils (HTMLElement r)\n  )\n\ntype HTMLTableElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLTableElement\"\n  , width :: String\n  , rules :: String\n  , height :: String\n  , frame :: String\n  , cellspacing :: String\n  , cellpadding :: String\n  , bordercolor :: String\n  , border :: String\n  , bgcolor :: String\n  , align :: String\n  , summary :: String\n  , datapagesize :: String\n  | HTMLElement r\n  )\n\ntype HTMLTableCaptionElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLTableCaptionElement\", align :: String | HTMLElement r)\n\ntype HTMLTableColElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLTableColElement\"\n  , width :: String\n  , valign :: String\n  , charoff :: String\n  , char :: String\n  , align :: String\n  , span :: String\n  | HTMLElement r\n  )\n\ntype HTMLTableSectionElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLTableSectionElement\"\n  , valign :: String\n  , height :: String\n  , charoff :: String\n  , char :: String\n  , align :: String\n  | HTMLElement r\n  )\n\ntype HTMLTableRowElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLTableRowElement\"\n  , valign :: String\n  , height :: String\n  , charoff :: String\n  , char :: String\n  , bgcolor :: String\n  , align :: String\n  | HTMLElement r\n  )\n\ntype HTMLTableCellElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLTableCellElement\"\n  , width :: String\n  , valign :: String\n  , nowrap :: String\n  , height :: String\n  , charoff :: String\n  , char :: String\n  , bgcolor :: String\n  , align :: String\n  , scope :: String\n  , axis :: String\n  , abbr :: String\n  , headers :: String\n  , rowspan :: String\n  , colspan :: String\n  | HTMLElement r\n  )\n\ntype HTMLFormElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLFormElement\"\n  , accept :: String\n  , formnovalidate :: String\n  , novalidate :: String\n  , formtarget :: String\n  , target :: String\n  , formenctype :: String\n  , enctype :: String\n  , formmethod :: String\n  , method :: String\n  , formaction :: String\n  , action :: String\n  , rel :: String\n  , autocomplete :: String\n  , name :: String\n  , acceptCharset :: String\n  , submit :: Web.Event.Internal.Types.Event\n  , reset :: Web.Event.Internal.Types.Event\n  , formdata :: Web.Event.Internal.Types.Event\n  | HTMLElement r\n  )\n\ntype HTMLLabelElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLLabelElement\", for :: String | HTMLElement r)\n\ntype HTMLInputElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLInputElement\"\n  , capture :: String\n  , vspace :: String\n  , hspace :: String\n  , border :: String\n  , align :: String\n  , usemap :: String\n  , ismap :: String\n  , autocomplete :: String\n  , disabled :: String\n  , minlength :: String\n  , maxlength :: String\n  , dirname :: String\n  , name :: String\n  , form :: String\n  , placeholder :: String\n  , list :: String\n  , step :: String\n  , max :: String\n  , min :: String\n  , title :: String\n  , pattern :: String\n  , multiple :: String\n  , required :: String\n  , readonly :: String\n  , size :: String\n  , alt :: String\n  , src :: String\n  , accept :: String\n  , checked :: String\n  , value :: String\n  , xtype :: String\n  , select :: Web.Event.Internal.Types.Event\n  , invalid :: Web.Event.Internal.Types.Event\n  , change :: Web.Event.Internal.Types.Event\n  , cancel :: Web.Event.Internal.Types.Event\n  | PopoverInvokerElement (HTMLElement r)\n  )\n\ntype HTMLButtonElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLButtonElement\"\n  , autocomplete :: String\n  , formnovalidate :: String\n  , novalidate :: String\n  , formtarget :: String\n  , target :: String\n  , formenctype :: String\n  , enctype :: String\n  , formmethod :: String\n  , method :: String\n  , formaction :: String\n  , action :: String\n  , disabled :: String\n  , name :: String\n  , form :: String\n  , value :: String\n  , xtype :: String\n  , invalid :: Web.Event.Internal.Types.Event\n  | PopoverInvokerElement (HTMLElement r)\n  )\n\ntype HTMLSelectElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLSelectElement\"\n  , autocomplete :: String\n  , disabled :: String\n  , name :: String\n  , form :: String\n  , required :: String\n  , size :: String\n  , multiple :: String\n  , invalid :: Web.Event.Internal.Types.Event\n  , change :: Web.Event.Internal.Types.Event\n  | HTMLElement r\n  )\n\ntype HTMLDataListElement (r :: Row Type) = (__tag :: Proxy \"HTMLDataListElement\" | HTMLElement r)\ntype HTMLOptGroupElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLOptGroupElement\", label :: String, disabled :: String | HTMLElement r)\n\ntype HTMLOptionElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLOptionElement\"\n  , name :: String\n  , selected :: String\n  , value :: String\n  , label :: String\n  , disabled :: String\n  | HTMLElement r\n  )\n\ntype HTMLTextAreaElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLTextAreaElement\"\n  , autocomplete :: String\n  , disabled :: String\n  , minlength :: String\n  , maxlength :: String\n  , dirname :: String\n  , name :: String\n  , form :: String\n  , placeholder :: String\n  , required :: String\n  , wrap :: String\n  , rows :: String\n  , cols :: String\n  , readonly :: String\n  , select :: Web.Event.Internal.Types.Event\n  , invalid :: Web.Event.Internal.Types.Event\n  | HTMLElement r\n  )\n\ntype HTMLOutputElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLOutputElement\"\n  , autocomplete :: String\n  , disabled :: String\n  , name :: String\n  , form :: String\n  , for :: String\n  | HTMLElement r\n  )\n\ntype HTMLProgressElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLProgressElement\", max :: String, value :: String | HTMLElement r)\n\ntype HTMLMeterElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLMeterElement\"\n  , optimum :: String\n  , high :: String\n  , low :: String\n  , value :: String\n  , max :: String\n  , min :: String\n  | HTMLElement r\n  )\n\ntype HTMLFieldSetElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLFieldSetElement\"\n  , autocomplete :: String\n  , disabled :: String\n  , name :: String\n  , form :: String\n  | HTMLElement r\n  )\n\ntype HTMLLegendElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLLegendElement\", align :: String | HTMLElement r)\n\ntype HTMLDetailsElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLDetailsElement\"\n  , open :: String\n  , name :: String\n  , toggle :: Web.Event.Internal.Types.Event\n  | HTMLElement r\n  )\n\ntype HTMLDialogElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLDialogElement\"\n  , open :: String\n  , cancel :: Web.Event.Internal.Types.Event\n  , close :: Web.Event.Internal.Types.Event\n  | HTMLElement r\n  )\n\ntype HTMLScriptElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLScriptElement\"\n  , for :: String\n  , event :: String\n  , language :: String\n  , charset :: String\n  , fetchpriority :: String\n  , blocking :: String\n  , referrerpolicy :: String\n  , integrity :: String\n  , crossorigin :: String\n  , defer :: String\n  , async :: String\n  , nomodule :: String\n  , src :: String\n  , xtype :: String\n  | HTMLElement r\n  )\n\ntype HTMLTemplateElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLTemplateElement\"\n  , shadowrootserializable :: String\n  , shadowrootclonable :: String\n  , shadowrootdelegatesfocus :: String\n  , shadowrootmode :: String\n  | HTMLElement r\n  )\n\ntype HTMLSlotElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLSlotElement\", name :: String | HTMLElement r)\n\ntype HTMLCanvasElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLCanvasElement\"\n  , height :: String\n  , width :: String\n  , contextrestored :: Web.Event.Internal.Types.Event\n  , contextlost :: Web.Event.Internal.Types.Event\n  | HTMLElement r\n  )\n\ntype ElementContentEditable (r :: Row Type) = (__tag :: Proxy \"ElementContentEditable\" | r)\ntype PopoverInvokerElement (r :: Row Type) = (__tag :: Proxy \"PopoverInvokerElement\" | r)\ntype GlobalEventHandlers (r :: Row Type) =\n  ( __tag :: Proxy \"GlobalEventHandlers\"\n  , transitioncancel :: Web.Event.Internal.Types.Event\n  , transitionend :: Web.Event.Internal.Types.Event\n  , transitionstart :: Web.Event.Internal.Types.Event\n  , transitionrun :: Web.Event.Internal.Types.Event\n  , animationcancel :: Web.Event.Internal.Types.Event\n  , animationend :: Web.Event.Internal.Types.Event\n  , animationiteration :: Web.Event.Internal.Types.Event\n  , animationstart :: Web.Event.Internal.Types.Event\n  , lostpointercapture :: Web.PointerEvent.PointerEvent.PointerEvent\n  , gotpointercapture :: Web.PointerEvent.PointerEvent.PointerEvent\n  , pointerleave :: Web.PointerEvent.PointerEvent.PointerEvent\n  , pointerout :: Web.PointerEvent.PointerEvent.PointerEvent\n  , pointercancel :: Web.PointerEvent.PointerEvent.PointerEvent\n  , pointerup :: Web.PointerEvent.PointerEvent.PointerEvent\n  , pointerrawupdate :: Web.PointerEvent.PointerEvent.PointerEvent\n  , pointermove :: Web.PointerEvent.PointerEvent.PointerEvent\n  , pointerdown :: Web.PointerEvent.PointerEvent.PointerEvent\n  , pointerenter :: Web.PointerEvent.PointerEvent.PointerEvent\n  , pointerover :: Web.PointerEvent.PointerEvent.PointerEvent\n  , dragend :: Web.HTML.Event.DragEvent.DragEvent\n  , drop :: Web.HTML.Event.DragEvent.DragEvent\n  , dragover :: Web.HTML.Event.DragEvent.DragEvent\n  , dragleave :: Web.HTML.Event.DragEvent.DragEvent\n  , dragenter :: Web.HTML.Event.DragEvent.DragEvent\n  , drag :: Web.HTML.Event.DragEvent.DragEvent\n  , dragstart :: Web.HTML.Event.DragEvent.DragEvent\n  | r\n  )\n\ntype WindowEventHandlers (r :: Row Type) = (__tag :: Proxy \"WindowEventHandlers\" | r)\ntype HTMLMarqueeElement (r :: Row Type) =\n  ( __tag :: Proxy \"HTMLMarqueeElement\"\n  , loop :: String\n  , truespeed :: String\n  , direction :: String\n  , behavior :: String\n  | HTMLElement r\n  )\n\ntype HTMLFrameSetElement (r :: Row Type) =\n  (__tag :: Proxy \"HTMLFrameSetElement\" | WindowEventHandlers (HTMLElement r))\n\ntype HTMLFrameElement (r :: Row Type) = (__tag :: Proxy \"HTMLFrameElement\" | HTMLElement r)\ntype HTMLDirectoryElement (r :: Row Type) = (__tag :: Proxy \"HTMLDirectoryElement\" | HTMLElement r)\ntype HTMLFontElement (r :: Row Type) = (__tag :: Proxy \"HTMLFontElement\" | HTMLElement r)\ntype HTMLParamElement (r :: Row Type) = (__tag :: Proxy \"HTMLParamElement\" | HTMLElement r)\ntype EventTarget (r :: Row Type) = (__tag :: Proxy \"EventTarget\" | r)\ntype ParentNode (r :: Row Type) = (__tag :: Proxy \"ParentNode\" | r)\ntype NonDocumentTypeChildNode (r :: Row Type) = (__tag :: Proxy \"NonDocumentTypeChildNode\" | r)\ntype ChildNode (r :: Row Type) = (__tag :: Proxy \"ChildNode\" | r)\ntype Slottable (r :: Row Type) = (__tag :: Proxy \"Slottable\" | r)\ntype Node (r :: Row Type) = (__tag :: Proxy \"Node\" | EventTarget r)\ntype Element (r :: Row Type) =\n  ( __tag :: Proxy \"Element\"\n  , slot :: String\n  , id :: String\n  , klass :: String\n  , textInput :: Web.Event.Internal.Types.Event\n  , keypress :: Web.UIEvent.KeyboardEvent.KeyboardEvent\n  , domSubtreeModified :: Web.Event.Internal.Types.Event\n  , domNodeRemovedFromDocument :: Web.Event.Internal.Types.Event\n  , domNodeRemoved :: Web.Event.Internal.Types.Event\n  , domNodeInsertedIntoDocument :: Web.Event.Internal.Types.Event\n  , domNodeInserted :: Web.Event.Internal.Types.Event\n  , domFocusOut :: Web.UIEvent.FocusEvent.FocusEvent\n  , domFocusIn :: Web.UIEvent.FocusEvent.FocusEvent\n  , domAttrModified :: Web.Event.Internal.Types.Event\n  , domActivate :: Web.UIEvent.UIEvent.UIEvent\n  , wheel :: Web.Event.Internal.Types.Event\n  , unload :: Web.Event.Internal.Types.Event\n  , select :: Web.Event.Internal.Types.Event\n  , mouseup :: Web.UIEvent.MouseEvent.MouseEvent\n  , mouseover :: Web.UIEvent.MouseEvent.MouseEvent\n  , mouseout :: Web.UIEvent.MouseEvent.MouseEvent\n  , mousemove :: Web.UIEvent.MouseEvent.MouseEvent\n  , mouseleave :: Web.UIEvent.MouseEvent.MouseEvent\n  , mouseenter :: Web.UIEvent.MouseEvent.MouseEvent\n  , mousedown :: Web.UIEvent.MouseEvent.MouseEvent\n  , load :: Web.Event.Internal.Types.Event\n  , keyup :: Web.UIEvent.KeyboardEvent.KeyboardEvent\n  , keydown :: Web.UIEvent.KeyboardEvent.KeyboardEvent\n  , input :: Web.Event.Internal.Types.Event\n  , focusout :: Web.UIEvent.FocusEvent.FocusEvent\n  , focusin :: Web.UIEvent.FocusEvent.FocusEvent\n  , focus :: Web.UIEvent.FocusEvent.FocusEvent\n  , error :: Web.Event.Internal.Types.Event\n  , dblclick :: Web.UIEvent.MouseEvent.MouseEvent\n  , contextmenu :: Web.PointerEvent.PointerEvent.PointerEvent\n  , compositionend :: Web.UIEvent.CompositionEvent.CompositionEvent\n  , compositionupdate :: Web.UIEvent.CompositionEvent.CompositionEvent\n  , compositionstart :: Web.UIEvent.CompositionEvent.CompositionEvent\n  , click :: Web.PointerEvent.PointerEvent.PointerEvent\n  , blur :: Web.UIEvent.FocusEvent.FocusEvent\n  , beforeinput :: Web.Event.Internal.Types.Event\n  , auxclick :: Web.PointerEvent.PointerEvent.PointerEvent\n  , abort :: Web.Event.Internal.Types.Event\n  , touchcancel :: Web.TouchEvent.TouchEvent.TouchEvent\n  , touchmove :: Web.TouchEvent.TouchEvent.TouchEvent\n  , touchend :: Web.TouchEvent.TouchEvent.TouchEvent\n  , touchstart :: Web.TouchEvent.TouchEvent.TouchEvent\n  | ARIAMixin (Slottable (ChildNode (NonDocumentTypeChildNode (ParentNode (Node r)))))\n  )\n\ninstance TagToDeku \"html\" (HTMLHtmlElement ())\n\nhtml :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLHtmlElement ()))) -> Array Nut -> Nut\nhtml = elementify Nothing \"html\"\n\nhtml_ :: Array Nut -> Nut\nhtml_ = html []\n\nhtml__ :: String -> Nut\nhtml__ t = html [] [ DC.text_ t ]\n\ninstance TagToDeku \"head\" (HTMLHeadElement ())\n\nhead :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLHeadElement ()))) -> Array Nut -> Nut\nhead = elementify Nothing \"head\"\n\nhead_ :: Array Nut -> Nut\nhead_ = head []\n\nhead__ :: String -> Nut\nhead__ t = head [] [ DC.text_ t ]\n\ninstance TagToDeku \"title\" (HTMLTitleElement ())\n\ntitle :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLTitleElement ()))) -> Array Nut -> Nut\ntitle = elementify Nothing \"title\"\n\ntitle_ :: Array Nut -> Nut\ntitle_ = title []\n\ntitle__ :: String -> Nut\ntitle__ t = title [] [ DC.text_ t ]\n\ninstance TagToDeku \"base\" (HTMLBaseElement ())\n\nbase :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLBaseElement ()))) -> Array Nut -> Nut\nbase = elementify Nothing \"base\"\n\nbase_ :: Array Nut -> Nut\nbase_ = base []\n\nbase__ :: String -> Nut\nbase__ t = base [] [ DC.text_ t ]\n\ninstance TagToDeku \"link\" (HTMLLinkElement ())\n\nlink :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLLinkElement ()))) -> Array Nut -> Nut\nlink = elementify Nothing \"link\"\n\nlink_ :: Array Nut -> Nut\nlink_ = link []\n\nlink__ :: String -> Nut\nlink__ t = link [] [ DC.text_ t ]\n\ninstance TagToDeku \"meta\" (HTMLMetaElement ())\n\nmeta :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLMetaElement ()))) -> Array Nut -> Nut\nmeta = elementify Nothing \"meta\"\n\nmeta_ :: Array Nut -> Nut\nmeta_ = meta []\n\nmeta__ :: String -> Nut\nmeta__ t = meta [] [ DC.text_ t ]\n\ninstance TagToDeku \"style\" (HTMLStyleElement ())\n\nstyle :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLStyleElement ()))) -> Array Nut -> Nut\nstyle = elementify Nothing \"style\"\n\nstyle_ :: Array Nut -> Nut\nstyle_ = style []\n\nstyle__ :: String -> Nut\nstyle__ t = style [] [ DC.text_ t ]\n\ninstance TagToDeku \"body\" (HTMLBodyElement ())\n\nbody :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLBodyElement ()))) -> Array Nut -> Nut\nbody = elementify Nothing \"body\"\n\nbody_ :: Array Nut -> Nut\nbody_ = body []\n\nbody__ :: String -> Nut\nbody__ t = body [] [ DC.text_ t ]\n\ninstance TagToDeku \"article\" (HTMLElement ())\n\narticle :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\narticle = elementify Nothing \"article\"\n\narticle_ :: Array Nut -> Nut\narticle_ = article []\n\narticle__ :: String -> Nut\narticle__ t = article [] [ DC.text_ t ]\n\ninstance TagToDeku \"section\" (HTMLElement ())\n\nsection :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nsection = elementify Nothing \"section\"\n\nsection_ :: Array Nut -> Nut\nsection_ = section []\n\nsection__ :: String -> Nut\nsection__ t = section [] [ DC.text_ t ]\n\ninstance TagToDeku \"nav\" (HTMLElement ())\n\nnav :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nnav = elementify Nothing \"nav\"\n\nnav_ :: Array Nut -> Nut\nnav_ = nav []\n\nnav__ :: String -> Nut\nnav__ t = nav [] [ DC.text_ t ]\n\ninstance TagToDeku \"aside\" (HTMLElement ())\n\naside :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\naside = elementify Nothing \"aside\"\n\naside_ :: Array Nut -> Nut\naside_ = aside []\n\naside__ :: String -> Nut\naside__ t = aside [] [ DC.text_ t ]\n\ninstance TagToDeku \"h1\" (HTMLHeadingElement ())\n\nh1 :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLHeadingElement ()))) -> Array Nut -> Nut\nh1 = elementify Nothing \"h1\"\n\nh1_ :: Array Nut -> Nut\nh1_ = h1 []\n\nh1__ :: String -> Nut\nh1__ t = h1 [] [ DC.text_ t ]\n\ninstance TagToDeku \"h2\" (HTMLHeadingElement ())\n\nh2 :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLHeadingElement ()))) -> Array Nut -> Nut\nh2 = elementify Nothing \"h2\"\n\nh2_ :: Array Nut -> Nut\nh2_ = h2 []\n\nh2__ :: String -> Nut\nh2__ t = h2 [] [ DC.text_ t ]\n\ninstance TagToDeku \"h3\" (HTMLHeadingElement ())\n\nh3 :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLHeadingElement ()))) -> Array Nut -> Nut\nh3 = elementify Nothing \"h3\"\n\nh3_ :: Array Nut -> Nut\nh3_ = h3 []\n\nh3__ :: String -> Nut\nh3__ t = h3 [] [ DC.text_ t ]\n\ninstance TagToDeku \"h4\" (HTMLHeadingElement ())\n\nh4 :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLHeadingElement ()))) -> Array Nut -> Nut\nh4 = elementify Nothing \"h4\"\n\nh4_ :: Array Nut -> Nut\nh4_ = h4 []\n\nh4__ :: String -> Nut\nh4__ t = h4 [] [ DC.text_ t ]\n\ninstance TagToDeku \"h5\" (HTMLHeadingElement ())\n\nh5 :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLHeadingElement ()))) -> Array Nut -> Nut\nh5 = elementify Nothing \"h5\"\n\nh5_ :: Array Nut -> Nut\nh5_ = h5 []\n\nh5__ :: String -> Nut\nh5__ t = h5 [] [ DC.text_ t ]\n\ninstance TagToDeku \"h6\" (HTMLHeadingElement ())\n\nh6 :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLHeadingElement ()))) -> Array Nut -> Nut\nh6 = elementify Nothing \"h6\"\n\nh6_ :: Array Nut -> Nut\nh6_ = h6 []\n\nh6__ :: String -> Nut\nh6__ t = h6 [] [ DC.text_ t ]\n\ninstance TagToDeku \"hgroup\" (HTMLElement ())\n\nhgroup :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nhgroup = elementify Nothing \"hgroup\"\n\nhgroup_ :: Array Nut -> Nut\nhgroup_ = hgroup []\n\nhgroup__ :: String -> Nut\nhgroup__ t = hgroup [] [ DC.text_ t ]\n\ninstance TagToDeku \"header\" (HTMLElement ())\n\nheader :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nheader = elementify Nothing \"header\"\n\nheader_ :: Array Nut -> Nut\nheader_ = header []\n\nheader__ :: String -> Nut\nheader__ t = header [] [ DC.text_ t ]\n\ninstance TagToDeku \"footer\" (HTMLElement ())\n\nfooter :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nfooter = elementify Nothing \"footer\"\n\nfooter_ :: Array Nut -> Nut\nfooter_ = footer []\n\nfooter__ :: String -> Nut\nfooter__ t = footer [] [ DC.text_ t ]\n\ninstance TagToDeku \"address\" (HTMLElement ())\n\naddress :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\naddress = elementify Nothing \"address\"\n\naddress_ :: Array Nut -> Nut\naddress_ = address []\n\naddress__ :: String -> Nut\naddress__ t = address [] [ DC.text_ t ]\n\ninstance TagToDeku \"p\" (HTMLParagraphElement ())\n\np :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLParagraphElement ()))) -> Array Nut -> Nut\np = elementify Nothing \"p\"\n\np_ :: Array Nut -> Nut\np_ = p []\n\np__ :: String -> Nut\np__ t = p [] [ DC.text_ t ]\n\ninstance TagToDeku \"hr\" (HTMLHRElement ())\n\nhr :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLHRElement ()))) -> Array Nut -> Nut\nhr = elementify Nothing \"hr\"\n\nhr_ :: Array Nut -> Nut\nhr_ = hr []\n\nhr__ :: String -> Nut\nhr__ t = hr [] [ DC.text_ t ]\n\ninstance TagToDeku \"pre\" (HTMLPreElement ())\n\npre :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLPreElement ()))) -> Array Nut -> Nut\npre = elementify Nothing \"pre\"\n\npre_ :: Array Nut -> Nut\npre_ = pre []\n\npre__ :: String -> Nut\npre__ t = pre [] [ DC.text_ t ]\n\ninstance TagToDeku \"blockquote\" (HTMLQuoteElement ())\n\nblockquote\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLQuoteElement ()))) -> Array Nut -> Nut\nblockquote = elementify Nothing \"blockquote\"\n\nblockquote_ :: Array Nut -> Nut\nblockquote_ = blockquote []\n\nblockquote__ :: String -> Nut\nblockquote__ t = blockquote [] [ DC.text_ t ]\n\ninstance TagToDeku \"ol\" (HTMLOListElement ())\n\nol :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLOListElement ()))) -> Array Nut -> Nut\nol = elementify Nothing \"ol\"\n\nol_ :: Array Nut -> Nut\nol_ = ol []\n\nol__ :: String -> Nut\nol__ t = ol [] [ DC.text_ t ]\n\ninstance TagToDeku \"ul\" (HTMLUListElement ())\n\nul :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLUListElement ()))) -> Array Nut -> Nut\nul = elementify Nothing \"ul\"\n\nul_ :: Array Nut -> Nut\nul_ = ul []\n\nul__ :: String -> Nut\nul__ t = ul [] [ DC.text_ t ]\n\ninstance TagToDeku \"menu\" (HTMLMenuElement ())\n\nmenu :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLMenuElement ()))) -> Array Nut -> Nut\nmenu = elementify Nothing \"menu\"\n\nmenu_ :: Array Nut -> Nut\nmenu_ = menu []\n\nmenu__ :: String -> Nut\nmenu__ t = menu [] [ DC.text_ t ]\n\ninstance TagToDeku \"li\" (HTMLLIElement ())\n\nli :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLLIElement ()))) -> Array Nut -> Nut\nli = elementify Nothing \"li\"\n\nli_ :: Array Nut -> Nut\nli_ = li []\n\nli__ :: String -> Nut\nli__ t = li [] [ DC.text_ t ]\n\ninstance TagToDeku \"dl\" (HTMLDListElement ())\n\ndl :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLDListElement ()))) -> Array Nut -> Nut\ndl = elementify Nothing \"dl\"\n\ndl_ :: Array Nut -> Nut\ndl_ = dl []\n\ndl__ :: String -> Nut\ndl__ t = dl [] [ DC.text_ t ]\n\ninstance TagToDeku \"dt\" (HTMLElement ())\n\ndt :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\ndt = elementify Nothing \"dt\"\n\ndt_ :: Array Nut -> Nut\ndt_ = dt []\n\ndt__ :: String -> Nut\ndt__ t = dt [] [ DC.text_ t ]\n\ninstance TagToDeku \"dd\" (HTMLElement ())\n\ndd :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\ndd = elementify Nothing \"dd\"\n\ndd_ :: Array Nut -> Nut\ndd_ = dd []\n\ndd__ :: String -> Nut\ndd__ t = dd [] [ DC.text_ t ]\n\ninstance TagToDeku \"figure\" (HTMLElement ())\n\nfigure :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nfigure = elementify Nothing \"figure\"\n\nfigure_ :: Array Nut -> Nut\nfigure_ = figure []\n\nfigure__ :: String -> Nut\nfigure__ t = figure [] [ DC.text_ t ]\n\ninstance TagToDeku \"figcaption\" (HTMLElement ())\n\nfigcaption :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nfigcaption = elementify Nothing \"figcaption\"\n\nfigcaption_ :: Array Nut -> Nut\nfigcaption_ = figcaption []\n\nfigcaption__ :: String -> Nut\nfigcaption__ t = figcaption [] [ DC.text_ t ]\n\ninstance TagToDeku \"main\" (HTMLElement ())\n\nmain :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nmain = elementify Nothing \"main\"\n\nmain_ :: Array Nut -> Nut\nmain_ = main []\n\nmain__ :: String -> Nut\nmain__ t = main [] [ DC.text_ t ]\n\ninstance TagToDeku \"search\" (HTMLElement ())\n\nsearch :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nsearch = elementify Nothing \"search\"\n\nsearch_ :: Array Nut -> Nut\nsearch_ = search []\n\nsearch__ :: String -> Nut\nsearch__ t = search [] [ DC.text_ t ]\n\ninstance TagToDeku \"div\" (HTMLDivElement ())\n\ndiv :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLDivElement ()))) -> Array Nut -> Nut\ndiv = elementify Nothing \"div\"\n\ndiv_ :: Array Nut -> Nut\ndiv_ = div []\n\ndiv__ :: String -> Nut\ndiv__ t = div [] [ DC.text_ t ]\n\ninstance TagToDeku \"a\" (HTMLAnchorElement ())\n\na :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLAnchorElement ()))) -> Array Nut -> Nut\na = elementify Nothing \"a\"\n\na_ :: Array Nut -> Nut\na_ = a []\n\na__ :: String -> Nut\na__ t = a [] [ DC.text_ t ]\n\ninstance TagToDeku \"em\" (HTMLElement ())\n\nem :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nem = elementify Nothing \"em\"\n\nem_ :: Array Nut -> Nut\nem_ = em []\n\nem__ :: String -> Nut\nem__ t = em [] [ DC.text_ t ]\n\ninstance TagToDeku \"strong\" (HTMLElement ())\n\nstrong :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nstrong = elementify Nothing \"strong\"\n\nstrong_ :: Array Nut -> Nut\nstrong_ = strong []\n\nstrong__ :: String -> Nut\nstrong__ t = strong [] [ DC.text_ t ]\n\ninstance TagToDeku \"small\" (HTMLElement ())\n\nsmall :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nsmall = elementify Nothing \"small\"\n\nsmall_ :: Array Nut -> Nut\nsmall_ = small []\n\nsmall__ :: String -> Nut\nsmall__ t = small [] [ DC.text_ t ]\n\ninstance TagToDeku \"s\" (HTMLElement ())\n\ns :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\ns = elementify Nothing \"s\"\n\ns_ :: Array Nut -> Nut\ns_ = s []\n\ns__ :: String -> Nut\ns__ t = s [] [ DC.text_ t ]\n\ninstance TagToDeku \"cite\" (HTMLElement ())\n\ncite :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\ncite = elementify Nothing \"cite\"\n\ncite_ :: Array Nut -> Nut\ncite_ = cite []\n\ncite__ :: String -> Nut\ncite__ t = cite [] [ DC.text_ t ]\n\ninstance TagToDeku \"q\" (HTMLQuoteElement ())\n\nq :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLQuoteElement ()))) -> Array Nut -> Nut\nq = elementify Nothing \"q\"\n\nq_ :: Array Nut -> Nut\nq_ = q []\n\nq__ :: String -> Nut\nq__ t = q [] [ DC.text_ t ]\n\ninstance TagToDeku \"dfn\" (HTMLElement ())\n\ndfn :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\ndfn = elementify Nothing \"dfn\"\n\ndfn_ :: Array Nut -> Nut\ndfn_ = dfn []\n\ndfn__ :: String -> Nut\ndfn__ t = dfn [] [ DC.text_ t ]\n\ninstance TagToDeku \"abbr\" (HTMLElement ())\n\nabbr :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nabbr = elementify Nothing \"abbr\"\n\nabbr_ :: Array Nut -> Nut\nabbr_ = abbr []\n\nabbr__ :: String -> Nut\nabbr__ t = abbr [] [ DC.text_ t ]\n\ninstance TagToDeku \"ruby\" (HTMLElement ())\n\nruby :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nruby = elementify Nothing \"ruby\"\n\nruby_ :: Array Nut -> Nut\nruby_ = ruby []\n\nruby__ :: String -> Nut\nruby__ t = ruby [] [ DC.text_ t ]\n\ninstance TagToDeku \"rt\" (HTMLElement ())\n\nrt :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nrt = elementify Nothing \"rt\"\n\nrt_ :: Array Nut -> Nut\nrt_ = rt []\n\nrt__ :: String -> Nut\nrt__ t = rt [] [ DC.text_ t ]\n\ninstance TagToDeku \"rp\" (HTMLElement ())\n\nrp :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nrp = elementify Nothing \"rp\"\n\nrp_ :: Array Nut -> Nut\nrp_ = rp []\n\nrp__ :: String -> Nut\nrp__ t = rp [] [ DC.text_ t ]\n\ninstance TagToDeku \"data\" (HTMLDataElement ())\n\nxdata :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLDataElement ()))) -> Array Nut -> Nut\nxdata = elementify Nothing \"data\"\n\nxdata_ :: Array Nut -> Nut\nxdata_ = xdata []\n\nxdata__ :: String -> Nut\nxdata__ t = xdata [] [ DC.text_ t ]\n\ninstance TagToDeku \"time\" (HTMLTimeElement ())\n\ntime :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLTimeElement ()))) -> Array Nut -> Nut\ntime = elementify Nothing \"time\"\n\ntime_ :: Array Nut -> Nut\ntime_ = time []\n\ntime__ :: String -> Nut\ntime__ t = time [] [ DC.text_ t ]\n\ninstance TagToDeku \"code\" (HTMLElement ())\n\ncode :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\ncode = elementify Nothing \"code\"\n\ncode_ :: Array Nut -> Nut\ncode_ = code []\n\ncode__ :: String -> Nut\ncode__ t = code [] [ DC.text_ t ]\n\ninstance TagToDeku \"var\" (HTMLElement ())\n\nvar :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nvar = elementify Nothing \"var\"\n\nvar_ :: Array Nut -> Nut\nvar_ = var []\n\nvar__ :: String -> Nut\nvar__ t = var [] [ DC.text_ t ]\n\ninstance TagToDeku \"samp\" (HTMLElement ())\n\nsamp :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nsamp = elementify Nothing \"samp\"\n\nsamp_ :: Array Nut -> Nut\nsamp_ = samp []\n\nsamp__ :: String -> Nut\nsamp__ t = samp [] [ DC.text_ t ]\n\ninstance TagToDeku \"kbd\" (HTMLElement ())\n\nkbd :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nkbd = elementify Nothing \"kbd\"\n\nkbd_ :: Array Nut -> Nut\nkbd_ = kbd []\n\nkbd__ :: String -> Nut\nkbd__ t = kbd [] [ DC.text_ t ]\n\ninstance TagToDeku \"sub\" (HTMLElement ())\n\nsub :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nsub = elementify Nothing \"sub\"\n\nsub_ :: Array Nut -> Nut\nsub_ = sub []\n\nsub__ :: String -> Nut\nsub__ t = sub [] [ DC.text_ t ]\n\ninstance TagToDeku \"sup\" (HTMLElement ())\n\nsup :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nsup = elementify Nothing \"sup\"\n\nsup_ :: Array Nut -> Nut\nsup_ = sup []\n\nsup__ :: String -> Nut\nsup__ t = sup [] [ DC.text_ t ]\n\ninstance TagToDeku \"i\" (HTMLElement ())\n\ni :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\ni = elementify Nothing \"i\"\n\ni_ :: Array Nut -> Nut\ni_ = i []\n\ni__ :: String -> Nut\ni__ t = i [] [ DC.text_ t ]\n\ninstance TagToDeku \"b\" (HTMLElement ())\n\nb :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nb = elementify Nothing \"b\"\n\nb_ :: Array Nut -> Nut\nb_ = b []\n\nb__ :: String -> Nut\nb__ t = b [] [ DC.text_ t ]\n\ninstance TagToDeku \"u\" (HTMLElement ())\n\nu :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nu = elementify Nothing \"u\"\n\nu_ :: Array Nut -> Nut\nu_ = u []\n\nu__ :: String -> Nut\nu__ t = u [] [ DC.text_ t ]\n\ninstance TagToDeku \"mark\" (HTMLElement ())\n\nmark :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nmark = elementify Nothing \"mark\"\n\nmark_ :: Array Nut -> Nut\nmark_ = mark []\n\nmark__ :: String -> Nut\nmark__ t = mark [] [ DC.text_ t ]\n\ninstance TagToDeku \"bdi\" (HTMLElement ())\n\nbdi :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nbdi = elementify Nothing \"bdi\"\n\nbdi_ :: Array Nut -> Nut\nbdi_ = bdi []\n\nbdi__ :: String -> Nut\nbdi__ t = bdi [] [ DC.text_ t ]\n\ninstance TagToDeku \"bdo\" (HTMLElement ())\n\nbdo :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nbdo = elementify Nothing \"bdo\"\n\nbdo_ :: Array Nut -> Nut\nbdo_ = bdo []\n\nbdo__ :: String -> Nut\nbdo__ t = bdo [] [ DC.text_ t ]\n\ninstance TagToDeku \"span\" (HTMLSpanElement ())\n\nspan :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLSpanElement ()))) -> Array Nut -> Nut\nspan = elementify Nothing \"span\"\n\nspan_ :: Array Nut -> Nut\nspan_ = span []\n\nspan__ :: String -> Nut\nspan__ t = span [] [ DC.text_ t ]\n\ninstance TagToDeku \"br\" (HTMLBRElement ())\n\nbr :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLBRElement ()))) -> Array Nut -> Nut\nbr = elementify Nothing \"br\"\n\nbr_ :: Array Nut -> Nut\nbr_ = br []\n\nbr__ :: String -> Nut\nbr__ t = br [] [ DC.text_ t ]\n\ninstance TagToDeku \"wbr\" (HTMLElement ())\n\nwbr :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nwbr = elementify Nothing \"wbr\"\n\nwbr_ :: Array Nut -> Nut\nwbr_ = wbr []\n\nwbr__ :: String -> Nut\nwbr__ t = wbr [] [ DC.text_ t ]\n\ninstance TagToDeku \"ins\" (HTMLModElement ())\n\nins :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLModElement ()))) -> Array Nut -> Nut\nins = elementify Nothing \"ins\"\n\nins_ :: Array Nut -> Nut\nins_ = ins []\n\nins__ :: String -> Nut\nins__ t = ins [] [ DC.text_ t ]\n\ninstance TagToDeku \"del\" (HTMLModElement ())\n\ndel :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLModElement ()))) -> Array Nut -> Nut\ndel = elementify Nothing \"del\"\n\ndel_ :: Array Nut -> Nut\ndel_ = del []\n\ndel__ :: String -> Nut\ndel__ t = del [] [ DC.text_ t ]\n\ninstance TagToDeku \"picture\" (HTMLPictureElement ())\n\npicture\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLPictureElement ()))) -> Array Nut -> Nut\npicture = elementify Nothing \"picture\"\n\npicture_ :: Array Nut -> Nut\npicture_ = picture []\n\npicture__ :: String -> Nut\npicture__ t = picture [] [ DC.text_ t ]\n\ninstance TagToDeku \"source\" (HTMLSourceElement ())\n\nsource\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLSourceElement ()))) -> Array Nut -> Nut\nsource = elementify Nothing \"source\"\n\nsource_ :: Array Nut -> Nut\nsource_ = source []\n\nsource__ :: String -> Nut\nsource__ t = source [] [ DC.text_ t ]\n\ninstance TagToDeku \"img\" (HTMLImageElement ())\n\nimg :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLImageElement ()))) -> Array Nut -> Nut\nimg = elementify Nothing \"img\"\n\nimg_ :: Array Nut -> Nut\nimg_ = img []\n\nimg__ :: String -> Nut\nimg__ t = img [] [ DC.text_ t ]\n\ninstance TagToDeku \"iframe\" (HTMLIFrameElement ())\n\niframe\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLIFrameElement ()))) -> Array Nut -> Nut\niframe = elementify Nothing \"iframe\"\n\niframe_ :: Array Nut -> Nut\niframe_ = iframe []\n\niframe__ :: String -> Nut\niframe__ t = iframe [] [ DC.text_ t ]\n\ninstance TagToDeku \"embed\" (HTMLEmbedElement ())\n\nembed :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLEmbedElement ()))) -> Array Nut -> Nut\nembed = elementify Nothing \"embed\"\n\nembed_ :: Array Nut -> Nut\nembed_ = embed []\n\nembed__ :: String -> Nut\nembed__ t = embed [] [ DC.text_ t ]\n\ninstance TagToDeku \"object\" (HTMLObjectElement ())\n\nobject\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLObjectElement ()))) -> Array Nut -> Nut\nobject = elementify Nothing \"object\"\n\nobject_ :: Array Nut -> Nut\nobject_ = object []\n\nobject__ :: String -> Nut\nobject__ t = object [] [ DC.text_ t ]\n\ninstance TagToDeku \"video\" (HTMLVideoElement ())\n\nvideo :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLVideoElement ()))) -> Array Nut -> Nut\nvideo = elementify Nothing \"video\"\n\nvideo_ :: Array Nut -> Nut\nvideo_ = video []\n\nvideo__ :: String -> Nut\nvideo__ t = video [] [ DC.text_ t ]\n\ninstance TagToDeku \"audio\" (HTMLAudioElement ())\n\naudio :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLAudioElement ()))) -> Array Nut -> Nut\naudio = elementify Nothing \"audio\"\n\naudio_ :: Array Nut -> Nut\naudio_ = audio []\n\naudio__ :: String -> Nut\naudio__ t = audio [] [ DC.text_ t ]\n\ninstance TagToDeku \"track\" (HTMLTrackElement ())\n\ntrack :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLTrackElement ()))) -> Array Nut -> Nut\ntrack = elementify Nothing \"track\"\n\ntrack_ :: Array Nut -> Nut\ntrack_ = track []\n\ntrack__ :: String -> Nut\ntrack__ t = track [] [ DC.text_ t ]\n\ninstance TagToDeku \"map\" (HTMLMapElement ())\n\nmap :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLMapElement ()))) -> Array Nut -> Nut\nmap = elementify Nothing \"map\"\n\nmap_ :: Array Nut -> Nut\nmap_ = map []\n\nmap__ :: String -> Nut\nmap__ t = map [] [ DC.text_ t ]\n\ninstance TagToDeku \"area\" (HTMLAreaElement ())\n\narea :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLAreaElement ()))) -> Array Nut -> Nut\narea = elementify Nothing \"area\"\n\narea_ :: Array Nut -> Nut\narea_ = area []\n\narea__ :: String -> Nut\narea__ t = area [] [ DC.text_ t ]\n\ninstance TagToDeku \"table\" (HTMLTableElement ())\n\ntable :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLTableElement ()))) -> Array Nut -> Nut\ntable = elementify Nothing \"table\"\n\ntable_ :: Array Nut -> Nut\ntable_ = table []\n\ntable__ :: String -> Nut\ntable__ t = table [] [ DC.text_ t ]\n\ninstance TagToDeku \"caption\" (HTMLTableCaptionElement ())\n\ncaption\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLTableCaptionElement ())))\n  -> Array Nut\n  -> Nut\ncaption = elementify Nothing \"caption\"\n\ncaption_ :: Array Nut -> Nut\ncaption_ = caption []\n\ncaption__ :: String -> Nut\ncaption__ t = caption [] [ DC.text_ t ]\n\ninstance TagToDeku \"colgroup\" (HTMLTableColElement ())\n\ncolgroup\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLTableColElement ()))) -> Array Nut -> Nut\ncolgroup = elementify Nothing \"colgroup\"\n\ncolgroup_ :: Array Nut -> Nut\ncolgroup_ = colgroup []\n\ncolgroup__ :: String -> Nut\ncolgroup__ t = colgroup [] [ DC.text_ t ]\n\ninstance TagToDeku \"col\" (HTMLTableColElement ())\n\ncol\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLTableColElement ()))) -> Array Nut -> Nut\ncol = elementify Nothing \"col\"\n\ncol_ :: Array Nut -> Nut\ncol_ = col []\n\ncol__ :: String -> Nut\ncol__ t = col [] [ DC.text_ t ]\n\ninstance TagToDeku \"tbody\" (HTMLTableSectionElement ())\n\ntbody\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLTableSectionElement ())))\n  -> Array Nut\n  -> Nut\ntbody = elementify Nothing \"tbody\"\n\ntbody_ :: Array Nut -> Nut\ntbody_ = tbody []\n\ntbody__ :: String -> Nut\ntbody__ t = tbody [] [ DC.text_ t ]\n\ninstance TagToDeku \"thead\" (HTMLTableSectionElement ())\n\nthead\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLTableSectionElement ())))\n  -> Array Nut\n  -> Nut\nthead = elementify Nothing \"thead\"\n\nthead_ :: Array Nut -> Nut\nthead_ = thead []\n\nthead__ :: String -> Nut\nthead__ t = thead [] [ DC.text_ t ]\n\ninstance TagToDeku \"tfoot\" (HTMLTableSectionElement ())\n\ntfoot\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLTableSectionElement ())))\n  -> Array Nut\n  -> Nut\ntfoot = elementify Nothing \"tfoot\"\n\ntfoot_ :: Array Nut -> Nut\ntfoot_ = tfoot []\n\ntfoot__ :: String -> Nut\ntfoot__ t = tfoot [] [ DC.text_ t ]\n\ninstance TagToDeku \"tr\" (HTMLTableRowElement ())\n\ntr :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLTableRowElement ()))) -> Array Nut -> Nut\ntr = elementify Nothing \"tr\"\n\ntr_ :: Array Nut -> Nut\ntr_ = tr []\n\ntr__ :: String -> Nut\ntr__ t = tr [] [ DC.text_ t ]\n\ninstance TagToDeku \"td\" (HTMLTableCellElement ())\n\ntd\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLTableCellElement ()))) -> Array Nut -> Nut\ntd = elementify Nothing \"td\"\n\ntd_ :: Array Nut -> Nut\ntd_ = td []\n\ntd__ :: String -> Nut\ntd__ t = td [] [ DC.text_ t ]\n\ninstance TagToDeku \"th\" (HTMLTableCellElement ())\n\nth\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLTableCellElement ()))) -> Array Nut -> Nut\nth = elementify Nothing \"th\"\n\nth_ :: Array Nut -> Nut\nth_ = th []\n\nth__ :: String -> Nut\nth__ t = th [] [ DC.text_ t ]\n\ninstance TagToDeku \"form\" (HTMLFormElement ())\n\nform :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLFormElement ()))) -> Array Nut -> Nut\nform = elementify Nothing \"form\"\n\nform_ :: Array Nut -> Nut\nform_ = form []\n\nform__ :: String -> Nut\nform__ t = form [] [ DC.text_ t ]\n\ninstance TagToDeku \"label\" (HTMLLabelElement ())\n\nlabel :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLLabelElement ()))) -> Array Nut -> Nut\nlabel = elementify Nothing \"label\"\n\nlabel_ :: Array Nut -> Nut\nlabel_ = label []\n\nlabel__ :: String -> Nut\nlabel__ t = label [] [ DC.text_ t ]\n\ninstance TagToDeku \"input\" (HTMLInputElement ())\n\ninput :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLInputElement ()))) -> Array Nut -> Nut\ninput = elementify Nothing \"input\"\n\ninput_ :: Array Nut -> Nut\ninput_ = input []\n\ninput__ :: String -> Nut\ninput__ t = input [] [ DC.text_ t ]\n\ninstance TagToDeku \"button\" (HTMLButtonElement ())\n\nbutton\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLButtonElement ()))) -> Array Nut -> Nut\nbutton = elementify Nothing \"button\"\n\nbutton_ :: Array Nut -> Nut\nbutton_ = button []\n\nbutton__ :: String -> Nut\nbutton__ t = button [] [ DC.text_ t ]\n\ninstance TagToDeku \"select\" (HTMLSelectElement ())\n\nselect\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLSelectElement ()))) -> Array Nut -> Nut\nselect = elementify Nothing \"select\"\n\nselect_ :: Array Nut -> Nut\nselect_ = select []\n\nselect__ :: String -> Nut\nselect__ t = select [] [ DC.text_ t ]\n\ninstance TagToDeku \"datalist\" (HTMLDataListElement ())\n\ndatalist\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLDataListElement ()))) -> Array Nut -> Nut\ndatalist = elementify Nothing \"datalist\"\n\ndatalist_ :: Array Nut -> Nut\ndatalist_ = datalist []\n\ndatalist__ :: String -> Nut\ndatalist__ t = datalist [] [ DC.text_ t ]\n\ninstance TagToDeku \"optgroup\" (HTMLOptGroupElement ())\n\noptgroup\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLOptGroupElement ()))) -> Array Nut -> Nut\noptgroup = elementify Nothing \"optgroup\"\n\noptgroup_ :: Array Nut -> Nut\noptgroup_ = optgroup []\n\noptgroup__ :: String -> Nut\noptgroup__ t = optgroup [] [ DC.text_ t ]\n\ninstance TagToDeku \"option\" (HTMLOptionElement ())\n\noption\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLOptionElement ()))) -> Array Nut -> Nut\noption = elementify Nothing \"option\"\n\noption_ :: Array Nut -> Nut\noption_ = option []\n\noption__ :: String -> Nut\noption__ t = option [] [ DC.text_ t ]\n\ninstance TagToDeku \"textarea\" (HTMLTextAreaElement ())\n\ntextarea\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLTextAreaElement ()))) -> Array Nut -> Nut\ntextarea = elementify Nothing \"textarea\"\n\ntextarea_ :: Array Nut -> Nut\ntextarea_ = textarea []\n\ntextarea__ :: String -> Nut\ntextarea__ t = textarea [] [ DC.text_ t ]\n\ninstance TagToDeku \"output\" (HTMLOutputElement ())\n\noutput\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLOutputElement ()))) -> Array Nut -> Nut\noutput = elementify Nothing \"output\"\n\noutput_ :: Array Nut -> Nut\noutput_ = output []\n\noutput__ :: String -> Nut\noutput__ t = output [] [ DC.text_ t ]\n\ninstance TagToDeku \"progress\" (HTMLProgressElement ())\n\nprogress\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLProgressElement ()))) -> Array Nut -> Nut\nprogress = elementify Nothing \"progress\"\n\nprogress_ :: Array Nut -> Nut\nprogress_ = progress []\n\nprogress__ :: String -> Nut\nprogress__ t = progress [] [ DC.text_ t ]\n\ninstance TagToDeku \"meter\" (HTMLMeterElement ())\n\nmeter :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLMeterElement ()))) -> Array Nut -> Nut\nmeter = elementify Nothing \"meter\"\n\nmeter_ :: Array Nut -> Nut\nmeter_ = meter []\n\nmeter__ :: String -> Nut\nmeter__ t = meter [] [ DC.text_ t ]\n\ninstance TagToDeku \"fieldset\" (HTMLFieldSetElement ())\n\nfieldset\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLFieldSetElement ()))) -> Array Nut -> Nut\nfieldset = elementify Nothing \"fieldset\"\n\nfieldset_ :: Array Nut -> Nut\nfieldset_ = fieldset []\n\nfieldset__ :: String -> Nut\nfieldset__ t = fieldset [] [ DC.text_ t ]\n\ninstance TagToDeku \"legend\" (HTMLLegendElement ())\n\nlegend\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLLegendElement ()))) -> Array Nut -> Nut\nlegend = elementify Nothing \"legend\"\n\nlegend_ :: Array Nut -> Nut\nlegend_ = legend []\n\nlegend__ :: String -> Nut\nlegend__ t = legend [] [ DC.text_ t ]\n\ninstance TagToDeku \"details\" (HTMLDetailsElement ())\n\ndetails\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLDetailsElement ()))) -> Array Nut -> Nut\ndetails = elementify Nothing \"details\"\n\ndetails_ :: Array Nut -> Nut\ndetails_ = details []\n\ndetails__ :: String -> Nut\ndetails__ t = details [] [ DC.text_ t ]\n\ninstance TagToDeku \"summary\" (HTMLElement ())\n\nsummary :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nsummary = elementify Nothing \"summary\"\n\nsummary_ :: Array Nut -> Nut\nsummary_ = summary []\n\nsummary__ :: String -> Nut\nsummary__ t = summary [] [ DC.text_ t ]\n\ninstance TagToDeku \"dialog\" (HTMLDialogElement ())\n\ndialog\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLDialogElement ()))) -> Array Nut -> Nut\ndialog = elementify Nothing \"dialog\"\n\ndialog_ :: Array Nut -> Nut\ndialog_ = dialog []\n\ndialog__ :: String -> Nut\ndialog__ t = dialog [] [ DC.text_ t ]\n\ninstance TagToDeku \"script\" (HTMLScriptElement ())\n\nscript\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLScriptElement ()))) -> Array Nut -> Nut\nscript = elementify Nothing \"script\"\n\nscript_ :: Array Nut -> Nut\nscript_ = script []\n\nscript__ :: String -> Nut\nscript__ t = script [] [ DC.text_ t ]\n\ninstance TagToDeku \"noscript\" (HTMLElement ())\n\nnoscript :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nnoscript = elementify Nothing \"noscript\"\n\nnoscript_ :: Array Nut -> Nut\nnoscript_ = noscript []\n\nnoscript__ :: String -> Nut\nnoscript__ t = noscript [] [ DC.text_ t ]\n\ninstance TagToDeku \"template\" (HTMLTemplateElement ())\n\ntemplate\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLTemplateElement ()))) -> Array Nut -> Nut\ntemplate = elementify Nothing \"template\"\n\ntemplate_ :: Array Nut -> Nut\ntemplate_ = template []\n\ntemplate__ :: String -> Nut\ntemplate__ t = template [] [ DC.text_ t ]\n\ninstance TagToDeku \"slot\" (HTMLSlotElement ())\n\nslot :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLSlotElement ()))) -> Array Nut -> Nut\nslot = elementify Nothing \"slot\"\n\nslot_ :: Array Nut -> Nut\nslot_ = slot []\n\nslot__ :: String -> Nut\nslot__ t = slot [] [ DC.text_ t ]\n\ninstance TagToDeku \"canvas\" (HTMLCanvasElement ())\n\ncanvas\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLCanvasElement ()))) -> Array Nut -> Nut\ncanvas = elementify Nothing \"canvas\"\n\ncanvas_ :: Array Nut -> Nut\ncanvas_ = canvas []\n\ncanvas__ :: String -> Nut\ncanvas__ t = canvas [] [ DC.text_ t ]\n\ninstance TagToDeku \"applet\" (HTMLUnknownElement ())\n\napplet\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLUnknownElement ()))) -> Array Nut -> Nut\napplet = elementify Nothing \"applet\"\n\napplet_ :: Array Nut -> Nut\napplet_ = applet []\n\napplet__ :: String -> Nut\napplet__ t = applet [] [ DC.text_ t ]\n\ninstance TagToDeku \"acronym\" (HTMLElement ())\n\nacronym :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nacronym = elementify Nothing \"acronym\"\n\nacronym_ :: Array Nut -> Nut\nacronym_ = acronym []\n\nacronym__ :: String -> Nut\nacronym__ t = acronym [] [ DC.text_ t ]\n\ninstance TagToDeku \"bgsound\" (HTMLUnknownElement ())\n\nbgsound\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLUnknownElement ()))) -> Array Nut -> Nut\nbgsound = elementify Nothing \"bgsound\"\n\nbgsound_ :: Array Nut -> Nut\nbgsound_ = bgsound []\n\nbgsound__ :: String -> Nut\nbgsound__ t = bgsound [] [ DC.text_ t ]\n\ninstance TagToDeku \"dir\" (HTMLDirectoryElement ())\n\ndir\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLDirectoryElement ()))) -> Array Nut -> Nut\ndir = elementify Nothing \"dir\"\n\ndir_ :: Array Nut -> Nut\ndir_ = dir []\n\ndir__ :: String -> Nut\ndir__ t = dir [] [ DC.text_ t ]\n\ninstance TagToDeku \"frame\" (HTMLFrameElement ())\n\nframe :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLFrameElement ()))) -> Array Nut -> Nut\nframe = elementify Nothing \"frame\"\n\nframe_ :: Array Nut -> Nut\nframe_ = frame []\n\nframe__ :: String -> Nut\nframe__ t = frame [] [ DC.text_ t ]\n\ninstance TagToDeku \"frameset\" (HTMLFrameSetElement ())\n\nframeset\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLFrameSetElement ()))) -> Array Nut -> Nut\nframeset = elementify Nothing \"frameset\"\n\nframeset_ :: Array Nut -> Nut\nframeset_ = frameset []\n\nframeset__ :: String -> Nut\nframeset__ t = frameset [] [ DC.text_ t ]\n\ninstance TagToDeku \"noframes\" (HTMLElement ())\n\nnoframes :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nnoframes = elementify Nothing \"noframes\"\n\nnoframes_ :: Array Nut -> Nut\nnoframes_ = noframes []\n\nnoframes__ :: String -> Nut\nnoframes__ t = noframes [] [ DC.text_ t ]\n\ninstance TagToDeku \"isindex\" (HTMLUnknownElement ())\n\nisindex\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLUnknownElement ()))) -> Array Nut -> Nut\nisindex = elementify Nothing \"isindex\"\n\nisindex_ :: Array Nut -> Nut\nisindex_ = isindex []\n\nisindex__ :: String -> Nut\nisindex__ t = isindex [] [ DC.text_ t ]\n\ninstance TagToDeku \"keygen\" (HTMLUnknownElement ())\n\nkeygen\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLUnknownElement ()))) -> Array Nut -> Nut\nkeygen = elementify Nothing \"keygen\"\n\nkeygen_ :: Array Nut -> Nut\nkeygen_ = keygen []\n\nkeygen__ :: String -> Nut\nkeygen__ t = keygen [] [ DC.text_ t ]\n\ninstance TagToDeku \"listing\" (HTMLPreElement ())\n\nlisting :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLPreElement ()))) -> Array Nut -> Nut\nlisting = elementify Nothing \"listing\"\n\nlisting_ :: Array Nut -> Nut\nlisting_ = listing []\n\nlisting__ :: String -> Nut\nlisting__ t = listing [] [ DC.text_ t ]\n\ninstance TagToDeku \"menuitem\" (HTMLElement ())\n\nmenuitem :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nmenuitem = elementify Nothing \"menuitem\"\n\nmenuitem_ :: Array Nut -> Nut\nmenuitem_ = menuitem []\n\nmenuitem__ :: String -> Nut\nmenuitem__ t = menuitem [] [ DC.text_ t ]\n\ninstance TagToDeku \"nextid\" (HTMLUnknownElement ())\n\nnextid\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLUnknownElement ()))) -> Array Nut -> Nut\nnextid = elementify Nothing \"nextid\"\n\nnextid_ :: Array Nut -> Nut\nnextid_ = nextid []\n\nnextid__ :: String -> Nut\nnextid__ t = nextid [] [ DC.text_ t ]\n\ninstance TagToDeku \"noembed\" (HTMLElement ())\n\nnoembed :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nnoembed = elementify Nothing \"noembed\"\n\nnoembed_ :: Array Nut -> Nut\nnoembed_ = noembed []\n\nnoembed__ :: String -> Nut\nnoembed__ t = noembed [] [ DC.text_ t ]\n\ninstance TagToDeku \"param\" (HTMLParamElement ())\n\nparam :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLParamElement ()))) -> Array Nut -> Nut\nparam = elementify Nothing \"param\"\n\nparam_ :: Array Nut -> Nut\nparam_ = param []\n\nparam__ :: String -> Nut\nparam__ t = param [] [ DC.text_ t ]\n\ninstance TagToDeku \"plaintext\" (HTMLElement ())\n\nplaintext :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nplaintext = elementify Nothing \"plaintext\"\n\nplaintext_ :: Array Nut -> Nut\nplaintext_ = plaintext []\n\nplaintext__ :: String -> Nut\nplaintext__ t = plaintext [] [ DC.text_ t ]\n\ninstance TagToDeku \"rb\" (HTMLElement ())\n\nrb :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nrb = elementify Nothing \"rb\"\n\nrb_ :: Array Nut -> Nut\nrb_ = rb []\n\nrb__ :: String -> Nut\nrb__ t = rb [] [ DC.text_ t ]\n\ninstance TagToDeku \"rtc\" (HTMLElement ())\n\nrtc :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nrtc = elementify Nothing \"rtc\"\n\nrtc_ :: Array Nut -> Nut\nrtc_ = rtc []\n\nrtc__ :: String -> Nut\nrtc__ t = rtc [] [ DC.text_ t ]\n\ninstance TagToDeku \"strike\" (HTMLElement ())\n\nstrike :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nstrike = elementify Nothing \"strike\"\n\nstrike_ :: Array Nut -> Nut\nstrike_ = strike []\n\nstrike__ :: String -> Nut\nstrike__ t = strike [] [ DC.text_ t ]\n\ninstance TagToDeku \"xmp\" (HTMLPreElement ())\n\nxmp :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLPreElement ()))) -> Array Nut -> Nut\nxmp = elementify Nothing \"xmp\"\n\nxmp_ :: Array Nut -> Nut\nxmp_ = xmp []\n\nxmp__ :: String -> Nut\nxmp__ t = xmp [] [ DC.text_ t ]\n\ninstance TagToDeku \"basefont\" (HTMLElement ())\n\nbasefont :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nbasefont = elementify Nothing \"basefont\"\n\nbasefont_ :: Array Nut -> Nut\nbasefont_ = basefont []\n\nbasefont__ :: String -> Nut\nbasefont__ t = basefont [] [ DC.text_ t ]\n\ninstance TagToDeku \"big\" (HTMLElement ())\n\nbig :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nbig = elementify Nothing \"big\"\n\nbig_ :: Array Nut -> Nut\nbig_ = big []\n\nbig__ :: String -> Nut\nbig__ t = big [] [ DC.text_ t ]\n\ninstance TagToDeku \"blink\" (HTMLUnknownElement ())\n\nblink\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLUnknownElement ()))) -> Array Nut -> Nut\nblink = elementify Nothing \"blink\"\n\nblink_ :: Array Nut -> Nut\nblink_ = blink []\n\nblink__ :: String -> Nut\nblink__ t = blink [] [ DC.text_ t ]\n\ninstance TagToDeku \"center\" (HTMLElement ())\n\ncenter :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\ncenter = elementify Nothing \"center\"\n\ncenter_ :: Array Nut -> Nut\ncenter_ = center []\n\ncenter__ :: String -> Nut\ncenter__ t = center [] [ DC.text_ t ]\n\ninstance TagToDeku \"font\" (HTMLFontElement ())\n\nfont :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLFontElement ()))) -> Array Nut -> Nut\nfont = elementify Nothing \"font\"\n\nfont_ :: Array Nut -> Nut\nfont_ = font []\n\nfont__ :: String -> Nut\nfont__ t = font [] [ DC.text_ t ]\n\ninstance TagToDeku \"marquee\" (HTMLMarqueeElement ())\n\nmarquee\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLMarqueeElement ()))) -> Array Nut -> Nut\nmarquee = elementify Nothing \"marquee\"\n\nmarquee_ :: Array Nut -> Nut\nmarquee_ = marquee []\n\nmarquee__ :: String -> Nut\nmarquee__ t = marquee [] [ DC.text_ t ]\n\ninstance TagToDeku \"multicol\" (HTMLUnknownElement ())\n\nmulticol\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLUnknownElement ()))) -> Array Nut -> Nut\nmulticol = elementify Nothing \"multicol\"\n\nmulticol_ :: Array Nut -> Nut\nmulticol_ = multicol []\n\nmulticol__ :: String -> Nut\nmulticol__ t = multicol [] [ DC.text_ t ]\n\ninstance TagToDeku \"nobr\" (HTMLElement ())\n\nnobr :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\nnobr = elementify Nothing \"nobr\"\n\nnobr_ :: Array Nut -> Nut\nnobr_ = nobr []\n\nnobr__ :: String -> Nut\nnobr__ t = nobr [] [ DC.text_ t ]\n\ninstance TagToDeku \"spacer\" (HTMLUnknownElement ())\n\nspacer\n  :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLUnknownElement ()))) -> Array Nut -> Nut\nspacer = elementify Nothing \"spacer\"\n\nspacer_ :: Array Nut -> Nut\nspacer_ = spacer []\n\nspacer__ :: String -> Nut\nspacer__ t = spacer [] [ DC.text_ t ]\n\ninstance TagToDeku \"tt\" (HTMLElement ())\n\ntt :: Array (FRP.Poll.Poll (Deku.Attribute.Attribute (HTMLElement ()))) -> Array Nut -> Nut\ntt = elementify Nothing \"tt\"\n\ntt_ :: Array Nut -> Nut\ntt_ = tt []\n\ntt__ :: String -> Nut\ntt__ t = tt [] [ DC.text_ t ]\n", "/* globals setImmediate, clearImmediate, setTimeout, clearTimeout */\n/* eslint-disable no-unused-vars, no-prototype-builtins, no-use-before-define, no-unused-labels, no-param-reassign */\nvar Aff = function () {\n  // A unique value for empty.\n  var EMPTY = {};\n\n  /*\n\n  An awkward approximation. We elide evidence we would otherwise need in PS for\n  efficiency sake.\n\n  data Aff eff a\n    = Pure a\n    | Throw Error\n    | Catch (Aff eff a) (Error -> Aff eff a)\n    | Sync (Eff eff a)\n    | Async ((Either Error a -> Eff eff Unit) -> Eff eff (Canceler eff))\n    | forall b. Bind (Aff eff b) (b -> Aff eff a)\n    | forall b. Bracket (Aff eff b) (BracketConditions eff b) (b -> Aff eff a)\n    | forall b. Fork Boolean (Aff eff b) ?(Fiber eff b -> a)\n    | Sequential (ParAff aff a)\n\n  */\n  var PURE    = \"Pure\";\n  var THROW   = \"Throw\";\n  var CATCH   = \"Catch\";\n  var SYNC    = \"Sync\";\n  var ASYNC   = \"Async\";\n  var BIND    = \"Bind\";\n  var BRACKET = \"Bracket\";\n  var FORK    = \"Fork\";\n  var SEQ     = \"Sequential\";\n\n  /*\n\n  data ParAff eff a\n    = forall b. Map (b -> a) (ParAff eff b)\n    | forall b. Apply (ParAff eff (b -> a)) (ParAff eff b)\n    | Alt (ParAff eff a) (ParAff eff a)\n    | ?Par (Aff eff a)\n\n  */\n  var MAP   = \"Map\";\n  var APPLY = \"Apply\";\n  var ALT   = \"Alt\";\n\n  // Various constructors used in interpretation\n  var CONS      = \"Cons\";      // Cons-list, for stacks\n  var RESUME    = \"Resume\";    // Continue indiscriminately\n  var RELEASE   = \"Release\";   // Continue with bracket finalizers\n  var FINALIZER = \"Finalizer\"; // A non-interruptible effect\n  var FINALIZED = \"Finalized\"; // Marker for finalization\n  var FORKED    = \"Forked\";    // Reference to a forked fiber, with resumption stack\n  var FIBER     = \"Fiber\";     // Actual fiber reference\n  var THUNK     = \"Thunk\";     // Primed effect, ready to invoke\n\n  function Aff(tag, _1, _2, _3) {\n    this.tag = tag;\n    this._1  = _1;\n    this._2  = _2;\n    this._3  = _3;\n  }\n\n  function AffCtr(tag) {\n    var fn = function (_1, _2, _3) {\n      return new Aff(tag, _1, _2, _3);\n    };\n    fn.tag = tag;\n    return fn;\n  }\n\n  function nonCanceler(error) {\n    return new Aff(PURE, void 0);\n  }\n\n  function runEff(eff) {\n    try {\n      eff();\n    } catch (error) {\n      setTimeout(function () {\n        throw error;\n      }, 0);\n    }\n  }\n\n  function runSync(left, right, eff) {\n    try {\n      return right(eff());\n    } catch (error) {\n      return left(error);\n    }\n  }\n\n  function runAsync(left, eff, k) {\n    try {\n      return eff(k)();\n    } catch (error) {\n      k(left(error))();\n      return nonCanceler;\n    }\n  }\n\n  var Scheduler = function () {\n    var limit    = 1024;\n    var size     = 0;\n    var ix       = 0;\n    var queue    = new Array(limit);\n    var draining = false;\n\n    function drain() {\n      var thunk;\n      draining = true;\n      while (size !== 0) {\n        size--;\n        thunk     = queue[ix];\n        queue[ix] = void 0;\n        ix        = (ix + 1) % limit;\n        thunk();\n      }\n      draining = false;\n    }\n\n    return {\n      isDraining: function () {\n        return draining;\n      },\n      enqueue: function (cb) {\n        var i, tmp;\n        if (size === limit) {\n          tmp = draining;\n          drain();\n          draining = tmp;\n        }\n\n        queue[(ix + size) % limit] = cb;\n        size++;\n\n        if (!draining) {\n          drain();\n        }\n      }\n    };\n  }();\n\n  function Supervisor(util) {\n    var fibers  = {};\n    var fiberId = 0;\n    var count   = 0;\n\n    return {\n      register: function (fiber) {\n        var fid = fiberId++;\n        fiber.onComplete({\n          rethrow: true,\n          handler: function (result) {\n            return function () {\n              count--;\n              delete fibers[fid];\n            };\n          }\n        })();\n        fibers[fid] = fiber;\n        count++;\n      },\n      isEmpty: function () {\n        return count === 0;\n      },\n      killAll: function (killError, cb) {\n        return function () {\n          if (count === 0) {\n            return cb();\n          }\n\n          var killCount = 0;\n          var kills     = {};\n\n          function kill(fid) {\n            kills[fid] = fibers[fid].kill(killError, function (result) {\n              return function () {\n                delete kills[fid];\n                killCount--;\n                if (util.isLeft(result) && util.fromLeft(result)) {\n                  setTimeout(function () {\n                    throw util.fromLeft(result);\n                  }, 0);\n                }\n                if (killCount === 0) {\n                  cb();\n                }\n              };\n            })();\n          }\n\n          for (var k in fibers) {\n            if (fibers.hasOwnProperty(k)) {\n              killCount++;\n              kill(k);\n            }\n          }\n\n          fibers  = {};\n          fiberId = 0;\n          count   = 0;\n\n          return function (error) {\n            return new Aff(SYNC, function () {\n              for (var k in kills) {\n                if (kills.hasOwnProperty(k)) {\n                  kills[k]();\n                }\n              }\n            });\n          };\n        };\n      }\n    };\n  }\n\n  // Fiber state machine\n  var SUSPENDED   = 0; // Suspended, pending a join.\n  var CONTINUE    = 1; // Interpret the next instruction.\n  var STEP_BIND   = 2; // Apply the next bind.\n  var STEP_RESULT = 3; // Handle potential failure from a result.\n  var PENDING     = 4; // An async effect is running.\n  var RETURN      = 5; // The current stack has returned.\n  var COMPLETED   = 6; // The entire fiber has completed.\n\n  function Fiber(util, supervisor, aff) {\n    // Monotonically increasing tick, increased on each asynchronous turn.\n    var runTick = 0;\n\n    // The current branch of the state machine.\n    var status = SUSPENDED;\n\n    // The current point of interest for the state machine branch.\n    var step      = aff;  // Successful step\n    var fail      = null; // Failure step\n    var interrupt = null; // Asynchronous interrupt\n\n    // Stack of continuations for the current fiber.\n    var bhead = null;\n    var btail = null;\n\n    // Stack of attempts and finalizers for error recovery. Every `Cons` is also\n    // tagged with current `interrupt` state. We use this to track which items\n    // should be ignored or evaluated as a result of a kill.\n    var attempts = null;\n\n    // A special state is needed for Bracket, because it cannot be killed. When\n    // we enter a bracket acquisition or finalizer, we increment the counter,\n    // and then decrement once complete.\n    var bracketCount = 0;\n\n    // Each join gets a new id so they can be revoked.\n    var joinId  = 0;\n    var joins   = null;\n    var rethrow = true;\n\n    // Each invocation of `run` requires a tick. When an asynchronous effect is\n    // resolved, we must check that the local tick coincides with the fiber\n    // tick before resuming. This prevents multiple async continuations from\n    // accidentally resuming the same fiber. A common example may be invoking\n    // the provided callback in `makeAff` more than once, but it may also be an\n    // async effect resuming after the fiber was already cancelled.\n    function run(localRunTick) {\n      var tmp, result, attempt;\n      while (true) {\n        tmp       = null;\n        result    = null;\n        attempt   = null;\n\n        switch (status) {\n        case STEP_BIND:\n          status = CONTINUE;\n          try {\n            step   = bhead(step);\n            if (btail === null) {\n              bhead = null;\n            } else {\n              bhead = btail._1;\n              btail = btail._2;\n            }\n          } catch (e) {\n            status = RETURN;\n            fail   = util.left(e);\n            step   = null;\n          }\n          break;\n\n        case STEP_RESULT:\n          if (util.isLeft(step)) {\n            status = RETURN;\n            fail   = step;\n            step   = null;\n          } else if (bhead === null) {\n            status = RETURN;\n          } else {\n            status = STEP_BIND;\n            step   = util.fromRight(step);\n          }\n          break;\n\n        case CONTINUE:\n          switch (step.tag) {\n          case BIND:\n            if (bhead) {\n              btail = new Aff(CONS, bhead, btail);\n            }\n            bhead  = step._2;\n            status = CONTINUE;\n            step   = step._1;\n            break;\n\n          case PURE:\n            if (bhead === null) {\n              status = RETURN;\n              step   = util.right(step._1);\n            } else {\n              status = STEP_BIND;\n              step   = step._1;\n            }\n            break;\n\n          case SYNC:\n            status = STEP_RESULT;\n            step   = runSync(util.left, util.right, step._1);\n            break;\n\n          case ASYNC:\n            status = PENDING;\n            step   = runAsync(util.left, step._1, function (result) {\n              return function () {\n                if (runTick !== localRunTick) {\n                  return;\n                }\n                runTick++;\n                Scheduler.enqueue(function () {\n                  // It's possible to interrupt the fiber between enqueuing and\n                  // resuming, so we need to check that the runTick is still\n                  // valid.\n                  if (runTick !== localRunTick + 1) {\n                    return;\n                  }\n                  status = STEP_RESULT;\n                  step   = result;\n                  run(runTick);\n                });\n              };\n            });\n            return;\n\n          case THROW:\n            status = RETURN;\n            fail   = util.left(step._1);\n            step   = null;\n            break;\n\n          // Enqueue the Catch so that we can call the error handler later on\n          // in case of an exception.\n          case CATCH:\n            if (bhead === null) {\n              attempts = new Aff(CONS, step, attempts, interrupt);\n            } else {\n              attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);\n            }\n            bhead    = null;\n            btail    = null;\n            status   = CONTINUE;\n            step     = step._1;\n            break;\n\n          // Enqueue the Bracket so that we can call the appropriate handlers\n          // after resource acquisition.\n          case BRACKET:\n            bracketCount++;\n            if (bhead === null) {\n              attempts = new Aff(CONS, step, attempts, interrupt);\n            } else {\n              attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);\n            }\n            bhead  = null;\n            btail  = null;\n            status = CONTINUE;\n            step   = step._1;\n            break;\n\n          case FORK:\n            status = STEP_RESULT;\n            tmp    = Fiber(util, supervisor, step._2);\n            if (supervisor) {\n              supervisor.register(tmp);\n            }\n            if (step._1) {\n              tmp.run();\n            }\n            step = util.right(tmp);\n            break;\n\n          case SEQ:\n            status = CONTINUE;\n            step   = sequential(util, supervisor, step._1);\n            break;\n          }\n          break;\n\n        case RETURN:\n          bhead = null;\n          btail = null;\n          // If the current stack has returned, and we have no other stacks to\n          // resume or finalizers to run, the fiber has halted and we can\n          // invoke all join callbacks. Otherwise we need to resume.\n          if (attempts === null) {\n            status = COMPLETED;\n            step   = interrupt || fail || step;\n          } else {\n            // The interrupt status for the enqueued item.\n            tmp      = attempts._3;\n            attempt  = attempts._1;\n            attempts = attempts._2;\n\n            switch (attempt.tag) {\n            // We cannot recover from an unmasked interrupt. Otherwise we should\n            // continue stepping, or run the exception handler if an exception\n            // was raised.\n            case CATCH:\n              // We should compare the interrupt status as well because we\n              // only want it to apply if there has been an interrupt since\n              // enqueuing the catch.\n              if (interrupt && interrupt !== tmp && bracketCount === 0) {\n                status = RETURN;\n              } else if (fail) {\n                status = CONTINUE;\n                step   = attempt._2(util.fromLeft(fail));\n                fail   = null;\n              }\n              break;\n\n            // We cannot resume from an unmasked interrupt or exception.\n            case RESUME:\n              // As with Catch, we only want to ignore in the case of an\n              // interrupt since enqueing the item.\n              if (interrupt && interrupt !== tmp && bracketCount === 0 || fail) {\n                status = RETURN;\n              } else {\n                bhead  = attempt._1;\n                btail  = attempt._2;\n                status = STEP_BIND;\n                step   = util.fromRight(step);\n              }\n              break;\n\n            // If we have a bracket, we should enqueue the handlers,\n            // and continue with the success branch only if the fiber has\n            // not been interrupted. If the bracket acquisition failed, we\n            // should not run either.\n            case BRACKET:\n              bracketCount--;\n              if (fail === null) {\n                result   = util.fromRight(step);\n                // We need to enqueue the Release with the same interrupt\n                // status as the Bracket that is initiating it.\n                attempts = new Aff(CONS, new Aff(RELEASE, attempt._2, result), attempts, tmp);\n                // We should only coninue as long as the interrupt status has not changed or\n                // we are currently within a non-interruptable finalizer.\n                if (interrupt === tmp || bracketCount > 0) {\n                  status = CONTINUE;\n                  step   = attempt._3(result);\n                }\n              }\n              break;\n\n            // Enqueue the appropriate handler. We increase the bracket count\n            // because it should not be cancelled.\n            case RELEASE:\n              attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);\n              status   = CONTINUE;\n              // It has only been killed if the interrupt status has changed\n              // since we enqueued the item, and the bracket count is 0. If the\n              // bracket count is non-zero then we are in a masked state so it's\n              // impossible to be killed.\n              if (interrupt && interrupt !== tmp && bracketCount === 0) {\n                step = attempt._1.killed(util.fromLeft(interrupt))(attempt._2);\n              } else if (fail) {\n                step = attempt._1.failed(util.fromLeft(fail))(attempt._2);\n              } else {\n                step = attempt._1.completed(util.fromRight(step))(attempt._2);\n              }\n              fail = null;\n              bracketCount++;\n              break;\n\n            case FINALIZER:\n              bracketCount++;\n              attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);\n              status   = CONTINUE;\n              step     = attempt._1;\n              break;\n\n            case FINALIZED:\n              bracketCount--;\n              status = RETURN;\n              step   = attempt._1;\n              fail   = attempt._2;\n              break;\n            }\n          }\n          break;\n\n        case COMPLETED:\n          for (var k in joins) {\n            if (joins.hasOwnProperty(k)) {\n              rethrow = rethrow && joins[k].rethrow;\n              runEff(joins[k].handler(step));\n            }\n          }\n          joins = null;\n          // If we have an interrupt and a fail, then the thread threw while\n          // running finalizers. This should always rethrow in a fresh stack.\n          if (interrupt && fail) {\n            setTimeout(function () {\n              throw util.fromLeft(fail);\n            }, 0);\n          // If we have an unhandled exception, and no other fiber has joined\n          // then we need to throw the exception in a fresh stack.\n          } else if (util.isLeft(step) && rethrow) {\n            setTimeout(function () {\n              // Guard on reathrow because a completely synchronous fiber can\n              // still have an observer which was added after-the-fact.\n              if (rethrow) {\n                throw util.fromLeft(step);\n              }\n            }, 0);\n          }\n          return;\n        case SUSPENDED:\n          status = CONTINUE;\n          break;\n        case PENDING: return;\n        }\n      }\n    }\n\n    function onComplete(join) {\n      return function () {\n        if (status === COMPLETED) {\n          rethrow = rethrow && join.rethrow;\n          join.handler(step)();\n          return function () {};\n        }\n\n        var jid    = joinId++;\n        joins      = joins || {};\n        joins[jid] = join;\n\n        return function() {\n          if (joins !== null) {\n            delete joins[jid];\n          }\n        };\n      };\n    }\n\n    function kill(error, cb) {\n      return function () {\n        if (status === COMPLETED) {\n          cb(util.right(void 0))();\n          return function () {};\n        }\n\n        var canceler = onComplete({\n          rethrow: false,\n          handler: function (/* unused */) {\n            return cb(util.right(void 0));\n          }\n        })();\n\n        switch (status) {\n        case SUSPENDED:\n          interrupt = util.left(error);\n          status    = COMPLETED;\n          step      = interrupt;\n          run(runTick);\n          break;\n        case PENDING:\n          if (interrupt === null) {\n            interrupt = util.left(error);\n          }\n          if (bracketCount === 0) {\n            if (status === PENDING) {\n              attempts = new Aff(CONS, new Aff(FINALIZER, step(error)), attempts, interrupt);\n            }\n            status   = RETURN;\n            step     = null;\n            fail     = null;\n            run(++runTick);\n          }\n          break;\n        default:\n          if (interrupt === null) {\n            interrupt = util.left(error);\n          }\n          if (bracketCount === 0) {\n            status = RETURN;\n            step   = null;\n            fail   = null;\n          }\n        }\n\n        return canceler;\n      };\n    }\n\n    function join(cb) {\n      return function () {\n        var canceler = onComplete({\n          rethrow: false,\n          handler: cb\n        })();\n        if (status === SUSPENDED) {\n          run(runTick);\n        }\n        return canceler;\n      };\n    }\n\n    return {\n      kill: kill,\n      join: join,\n      onComplete: onComplete,\n      isSuspended: function () {\n        return status === SUSPENDED;\n      },\n      run: function () {\n        if (status === SUSPENDED) {\n          if (!Scheduler.isDraining()) {\n            Scheduler.enqueue(function () {\n              run(runTick);\n            });\n          } else {\n            run(runTick);\n          }\n        }\n      }\n    };\n  }\n\n  function runPar(util, supervisor, par, cb) {\n    // Table of all forked fibers.\n    var fiberId   = 0;\n    var fibers    = {};\n\n    // Table of currently running cancelers, as a product of `Alt` behavior.\n    var killId    = 0;\n    var kills     = {};\n\n    // Error used for early cancelation on Alt branches.\n    var early     = new Error(\"[ParAff] Early exit\");\n\n    // Error used to kill the entire tree.\n    var interrupt = null;\n\n    // The root pointer of the tree.\n    var root      = EMPTY;\n\n    // Walks a tree, invoking all the cancelers. Returns the table of pending\n    // cancellation fibers.\n    function kill(error, par, cb) {\n      var step  = par;\n      var head  = null;\n      var tail  = null;\n      var count = 0;\n      var kills = {};\n      var tmp, kid;\n\n      loop: while (true) {\n        tmp = null;\n\n        switch (step.tag) {\n        case FORKED:\n          if (step._3 === EMPTY) {\n            tmp = fibers[step._1];\n            kills[count++] = tmp.kill(error, function (result) {\n              return function () {\n                count--;\n                if (count === 0) {\n                  cb(result)();\n                }\n              };\n            });\n          }\n          // Terminal case.\n          if (head === null) {\n            break loop;\n          }\n          // Go down the right side of the tree.\n          step = head._2;\n          if (tail === null) {\n            head = null;\n          } else {\n            head = tail._1;\n            tail = tail._2;\n          }\n          break;\n        case MAP:\n          step = step._2;\n          break;\n        case APPLY:\n        case ALT:\n          if (head) {\n            tail = new Aff(CONS, head, tail);\n          }\n          head = step;\n          step = step._1;\n          break;\n        }\n      }\n\n      if (count === 0) {\n        cb(util.right(void 0))();\n      } else {\n        // Run the cancelation effects. We alias `count` because it's mutable.\n        kid = 0;\n        tmp = count;\n        for (; kid < tmp; kid++) {\n          kills[kid] = kills[kid]();\n        }\n      }\n\n      return kills;\n    }\n\n    // When a fiber resolves, we need to bubble back up the tree with the\n    // result, computing the applicative nodes.\n    function join(result, head, tail) {\n      var fail, step, lhs, rhs, tmp, kid;\n\n      if (util.isLeft(result)) {\n        fail = result;\n        step = null;\n      } else {\n        step = result;\n        fail = null;\n      }\n\n      loop: while (true) {\n        lhs = null;\n        rhs = null;\n        tmp = null;\n        kid = null;\n\n        // We should never continue if the entire tree has been interrupted.\n        if (interrupt !== null) {\n          return;\n        }\n\n        // We've made it all the way to the root of the tree, which means\n        // the tree has fully evaluated.\n        if (head === null) {\n          cb(fail || step)();\n          return;\n        }\n\n        // The tree has already been computed, so we shouldn't try to do it\n        // again. This should never happen.\n        // TODO: Remove this?\n        if (head._3 !== EMPTY) {\n          return;\n        }\n\n        switch (head.tag) {\n        case MAP:\n          if (fail === null) {\n            head._3 = util.right(head._1(util.fromRight(step)));\n            step    = head._3;\n          } else {\n            head._3 = fail;\n          }\n          break;\n        case APPLY:\n          lhs = head._1._3;\n          rhs = head._2._3;\n          // If we have a failure we should kill the other side because we\n          // can't possible yield a result anymore.\n          if (fail) {\n            head._3 = fail;\n            tmp     = true;\n            kid     = killId++;\n\n            kills[kid] = kill(early, fail === lhs ? head._2 : head._1, function (/* unused */) {\n              return function () {\n                delete kills[kid];\n                if (tmp) {\n                  tmp = false;\n                } else if (tail === null) {\n                  join(fail, null, null);\n                } else {\n                  join(fail, tail._1, tail._2);\n                }\n              };\n            });\n\n            if (tmp) {\n              tmp = false;\n              return;\n            }\n          } else if (lhs === EMPTY || rhs === EMPTY) {\n            // We can only proceed if both sides have resolved.\n            return;\n          } else {\n            step    = util.right(util.fromRight(lhs)(util.fromRight(rhs)));\n            head._3 = step;\n          }\n          break;\n        case ALT:\n          lhs = head._1._3;\n          rhs = head._2._3;\n          // We can only proceed if both have resolved or we have a success\n          if (lhs === EMPTY && util.isLeft(rhs) || rhs === EMPTY && util.isLeft(lhs)) {\n            return;\n          }\n          // If both sides resolve with an error, we should continue with the\n          // first error\n          if (lhs !== EMPTY && util.isLeft(lhs) && rhs !== EMPTY && util.isLeft(rhs)) {\n            fail    = step === lhs ? rhs : lhs;\n            step    = null;\n            head._3 = fail;\n          } else {\n            head._3 = step;\n            tmp     = true;\n            kid     = killId++;\n            // Once a side has resolved, we need to cancel the side that is still\n            // pending before we can continue.\n            kills[kid] = kill(early, step === lhs ? head._2 : head._1, function (/* unused */) {\n              return function () {\n                delete kills[kid];\n                if (tmp) {\n                  tmp = false;\n                } else if (tail === null) {\n                  join(step, null, null);\n                } else {\n                  join(step, tail._1, tail._2);\n                }\n              };\n            });\n\n            if (tmp) {\n              tmp = false;\n              return;\n            }\n          }\n          break;\n        }\n\n        if (tail === null) {\n          head = null;\n        } else {\n          head = tail._1;\n          tail = tail._2;\n        }\n      }\n    }\n\n    function resolve(fiber) {\n      return function (result) {\n        return function () {\n          delete fibers[fiber._1];\n          fiber._3 = result;\n          join(result, fiber._2._1, fiber._2._2);\n        };\n      };\n    }\n\n    // Walks the applicative tree, substituting non-applicative nodes with\n    // `FORKED` nodes. In this tree, all applicative nodes use the `_3` slot\n    // as a mutable slot for memoization. In an unresolved state, the `_3`\n    // slot is `EMPTY`. In the cases of `ALT` and `APPLY`, we always walk\n    // the left side first, because both operations are left-associative. As\n    // we `RETURN` from those branches, we then walk the right side.\n    function run() {\n      var status = CONTINUE;\n      var step   = par;\n      var head   = null;\n      var tail   = null;\n      var tmp, fid;\n\n      loop: while (true) {\n        tmp = null;\n        fid = null;\n\n        switch (status) {\n        case CONTINUE:\n          switch (step.tag) {\n          case MAP:\n            if (head) {\n              tail = new Aff(CONS, head, tail);\n            }\n            head = new Aff(MAP, step._1, EMPTY, EMPTY);\n            step = step._2;\n            break;\n          case APPLY:\n            if (head) {\n              tail = new Aff(CONS, head, tail);\n            }\n            head = new Aff(APPLY, EMPTY, step._2, EMPTY);\n            step = step._1;\n            break;\n          case ALT:\n            if (head) {\n              tail = new Aff(CONS, head, tail);\n            }\n            head = new Aff(ALT, EMPTY, step._2, EMPTY);\n            step = step._1;\n            break;\n          default:\n            // When we hit a leaf value, we suspend the stack in the `FORKED`.\n            // When the fiber resolves, it can bubble back up the tree.\n            fid    = fiberId++;\n            status = RETURN;\n            tmp    = step;\n            step   = new Aff(FORKED, fid, new Aff(CONS, head, tail), EMPTY);\n            tmp    = Fiber(util, supervisor, tmp);\n            tmp.onComplete({\n              rethrow: false,\n              handler: resolve(step)\n            })();\n            fibers[fid] = tmp;\n            if (supervisor) {\n              supervisor.register(tmp);\n            }\n          }\n          break;\n        case RETURN:\n          // Terminal case, we are back at the root.\n          if (head === null) {\n            break loop;\n          }\n          // If we are done with the right side, we need to continue down the\n          // left. Otherwise we should continue up the stack.\n          if (head._1 === EMPTY) {\n            head._1 = step;\n            status  = CONTINUE;\n            step    = head._2;\n            head._2 = EMPTY;\n          } else {\n            head._2 = step;\n            step    = head;\n            if (tail === null) {\n              head  = null;\n            } else {\n              head  = tail._1;\n              tail  = tail._2;\n            }\n          }\n        }\n      }\n\n      // Keep a reference to the tree root so it can be cancelled.\n      root = step;\n\n      for (fid = 0; fid < fiberId; fid++) {\n        fibers[fid].run();\n      }\n    }\n\n    // Cancels the entire tree. If there are already subtrees being canceled,\n    // we need to first cancel those joins. We will then add fresh joins for\n    // all pending branches including those that were in the process of being\n    // canceled.\n    function cancel(error, cb) {\n      interrupt = util.left(error);\n      var innerKills;\n      for (var kid in kills) {\n        if (kills.hasOwnProperty(kid)) {\n          innerKills = kills[kid];\n          for (kid in innerKills) {\n            if (innerKills.hasOwnProperty(kid)) {\n              innerKills[kid]();\n            }\n          }\n        }\n      }\n\n      kills = null;\n      var newKills = kill(error, root, cb);\n\n      return function (killError) {\n        return new Aff(ASYNC, function (killCb) {\n          return function () {\n            for (var kid in newKills) {\n              if (newKills.hasOwnProperty(kid)) {\n                newKills[kid]();\n              }\n            }\n            return nonCanceler;\n          };\n        });\n      };\n    }\n\n    run();\n\n    return function (killError) {\n      return new Aff(ASYNC, function (killCb) {\n        return function () {\n          return cancel(killError, killCb);\n        };\n      });\n    };\n  }\n\n  function sequential(util, supervisor, par) {\n    return new Aff(ASYNC, function (cb) {\n      return function () {\n        return runPar(util, supervisor, par, cb);\n      };\n    });\n  }\n\n  Aff.EMPTY       = EMPTY;\n  Aff.Pure        = AffCtr(PURE);\n  Aff.Throw       = AffCtr(THROW);\n  Aff.Catch       = AffCtr(CATCH);\n  Aff.Sync        = AffCtr(SYNC);\n  Aff.Async       = AffCtr(ASYNC);\n  Aff.Bind        = AffCtr(BIND);\n  Aff.Bracket     = AffCtr(BRACKET);\n  Aff.Fork        = AffCtr(FORK);\n  Aff.Seq         = AffCtr(SEQ);\n  Aff.ParMap      = AffCtr(MAP);\n  Aff.ParApply    = AffCtr(APPLY);\n  Aff.ParAlt      = AffCtr(ALT);\n  Aff.Fiber       = Fiber;\n  Aff.Supervisor  = Supervisor;\n  Aff.Scheduler   = Scheduler;\n  Aff.nonCanceler = nonCanceler;\n\n  return Aff;\n}();\n\nexport const _pure = Aff.Pure;\nexport const _throwError = Aff.Throw;\n\nexport function _catchError(aff) {\n  return function (k) {\n    return Aff.Catch(aff, k);\n  };\n}\n\nexport function _map(f) {\n  return function (aff) {\n    if (aff.tag === Aff.Pure.tag) {\n      return Aff.Pure(f(aff._1));\n    } else {\n      return Aff.Bind(aff, function (value) {\n        return Aff.Pure(f(value));\n      });\n    }\n  };\n}\n\nexport function _bind(aff) {\n  return function (k) {\n    return Aff.Bind(aff, k);\n  };\n}\n\nexport function _fork(immediate) {\n  return function (aff) {\n    return Aff.Fork(immediate, aff);\n  };\n}\n\nexport const _liftEffect = Aff.Sync;\n\nexport function _parAffMap(f) {\n  return function (aff) {\n    return Aff.ParMap(f, aff);\n  };\n}\n\nexport function _parAffApply(aff1) {\n  return function (aff2) {\n    return Aff.ParApply(aff1, aff2);\n  };\n}\n\nexport function _parAffAlt(aff1) {\n  return function (aff2) {\n    return Aff.ParAlt(aff1, aff2);\n  };\n}\n\nexport const makeAff = Aff.Async;\n\nexport function generalBracket(acquire) {\n  return function (options) {\n    return function (k) {\n      return Aff.Bracket(acquire, options, k);\n    };\n  };\n}\n\nexport function _makeFiber(util, aff) {\n  return function () {\n    return Aff.Fiber(util, null, aff);\n  };\n}\n\nexport function _makeSupervisedFiber(util, aff) {\n  return function () {\n    var supervisor = Aff.Supervisor(util);\n    return {\n      fiber: Aff.Fiber(util, supervisor, aff),\n      supervisor: supervisor\n    };\n  };\n}\n\nexport function _killAll(error, supervisor, cb) {\n  return supervisor.killAll(error, cb);\n}\n\nexport const _delay = function () {\n  function setDelay(n, k) {\n    if (n === 0 && typeof setImmediate !== \"undefined\") {\n      return setImmediate(k);\n    } else {\n      return setTimeout(k, n);\n    }\n  }\n\n  function clearDelay(n, t) {\n    if (n === 0 && typeof clearImmediate !== \"undefined\") {\n      return clearImmediate(t);\n    } else {\n      return clearTimeout(t);\n    }\n  }\n\n  return function (right, ms) {\n    return Aff.Async(function (cb) {\n      return function () {\n        var timer = setDelay(ms, cb(right()));\n        return function () {\n          return Aff.Sync(function () {\n            return right(clearDelay(ms, timer));\n          });\n        };\n      };\n    });\n  };\n}();\n\nexport const _sequential = Aff.Seq;\n", "-- | This module contains reexports of all the attributes.\n-- This module has been automatically generated by running `spago run -p codegen`.\n-- Any changes may be overwritten.\nmodule Deku.DOM.Attributes\n  ( module Combinators\n  , tabindex\n  , tabindex_\n  , nonce\n  , nonce_\n  , slot\n  , slot_\n  , id\n  , id_\n  , klass\n  , klass_\n  , popovertargetaction\n  , popovertargetaction_\n  , popovertargetactionHide\n  , popovertargetactionShow\n  , popovertargetactionToggle\n  , popovertarget\n  , popovertarget_\n  , popover\n  , popover_\n  , popoverManual\n  , popoverAuto\n  , draggable\n  , draggable_\n  , draggableFalse\n  , draggableTrue\n  , enterkeyhint\n  , enterkeyhint_\n  , enterkeyhintSend\n  , enterkeyhintSearch\n  , enterkeyhintPrevious\n  , enterkeyhintNext\n  , enterkeyhintGo\n  , enterkeyhintDone\n  , enterkeyhintEnter\n  , inputmode\n  , inputmode_\n  , inputmodeSearch\n  , inputmodeDecimal\n  , inputmodeNumeric\n  , inputmodeEmail\n  , inputmodeUrl\n  , inputmodeTel\n  , inputmodeText\n  , inputmodeNone\n  , autocapitalize\n  , autocapitalize_\n  , autocapitalizeCharacters\n  , autocapitalizeWords\n  , autocapitalizeSentences\n  , autocapitalizeOn\n  , autocapitalizeNone\n  , autocapitalizeOff\n  , writingsuggestions\n  , writingsuggestions_\n  , writingsuggestionsFalse\n  , writingsuggestionsTrue\n  , spellcheck\n  , spellcheck_\n  , spellcheckFalse\n  , spellcheckTrue\n  , contenteditable\n  , contenteditable_\n  , contenteditablePlaintextOnly\n  , contenteditableFalse\n  , contenteditableTrue\n  , accesskey\n  , accesskey_\n  , autofocus\n  , autofocus_\n  , hidden\n  , hidden_\n  , hiddenUntilFound\n  , hiddenHidden\n  , itemprop\n  , itemprop_\n  , itemref\n  , itemref_\n  , itemid\n  , itemid_\n  , itemtype\n  , itemtype_\n  , itemscope\n  , itemscope_\n  , is\n  , is_\n  , title\n  , title_\n  , style\n  , style_\n  , dir\n  , dir_\n  , dirAuto\n  , dirRtl\n  , dirLtr\n  , translate\n  , translate_\n  , translateNo\n  , translateYes\n  , lang\n  , lang_\n  , target\n  , target_\n  , href\n  , href_\n  , urn\n  , urn_\n  , rev\n  , rev_\n  , methods\n  , methods_\n  , charset\n  , charset_\n  , fetchpriority\n  , fetchpriority_\n  , fetchpriorityAuto\n  , fetchpriorityLow\n  , fetchpriorityHigh\n  , disabled\n  , disabled_\n  , color\n  , color_\n  , blocking\n  , blocking_\n  , as\n  , as_\n  , sizes\n  , sizes_\n  , imagesizes\n  , imagesizes_\n  , imagesrcset\n  , imagesrcset_\n  , referrerpolicy\n  , referrerpolicy_\n  , xtype\n  , xtype_\n  , xtypeButton\n  , xtypeReset\n  , xtypeSubmit\n  , xtypeImage\n  , xtypeFile\n  , xtypeRadio\n  , xtypeCheckbox\n  , xtypeColor\n  , xtypeRange\n  , xtypeNumber\n  , xtypeDatetimeLocal\n  , xtypeTime\n  , xtypeWeek\n  , xtypeMonth\n  , xtypeDate\n  , xtypePassword\n  , xtypeEmail\n  , xtypeUrl\n  , xtypeTel\n  , xtypeSearch\n  , xtypeText\n  , xtypeHidden\n  , xtypeUpperI\n  , xtypeLowerI\n  , xtypeUpperA\n  , xtypeLowerA\n  , xtype1\n  , hreflang\n  , hreflang_\n  , integrity\n  , integrity_\n  , media\n  , media_\n  , crossorigin\n  , crossorigin_\n  , crossoriginUseCredentials\n  , crossoriginAnonymous\n  , rel\n  , rel_\n  , relPrev\n  , relNext\n  , relTermsOfService\n  , relTag\n  , relStylesheet\n  , relSearch\n  , relPrivacyPolicy\n  , relPreload\n  , relPrefetch\n  , relPreconnect\n  , relPingback\n  , relOpener\n  , relNoreferrer\n  , relNoopener\n  , relNofollow\n  , relModulepreload\n  , relManifest\n  , relLicense\n  , relIcon\n  , relHelp\n  , relExternal\n  , relExpect\n  , relDnsPrefetch\n  , relCanonical\n  , relBookmark\n  , relAuthor\n  , relAlternate\n  , scheme\n  , scheme_\n  , httpEquiv\n  , httpEquiv_\n  , httpEquivContentSecurityPolicy\n  , httpEquivXUaCompatible\n  , httpEquivSetCookie\n  , httpEquivRefresh\n  , httpEquivDefaultStyle\n  , httpEquivContentType\n  , httpEquivContentLanguage\n  , name\n  , name_\n  , nameColorScheme\n  , nameThemeColor\n  , nameReferrer\n  , nameKeywords\n  , nameGenerator\n  , nameDescription\n  , nameAuthor\n  , nameApplicationName\n  , content\n  , content_\n  , cite\n  , cite_\n  , compact\n  , compact_\n  , start\n  , start_\n  , reversed\n  , reversed_\n  , value\n  , value_\n  , datetime\n  , datetime_\n  , shape\n  , shape_\n  , shapeRectangleState\n  , shapePolygonState\n  , shapeDefaultState\n  , shapeCircleState\n  , coords\n  , coords_\n  , ping\n  , ping_\n  , download\n  , download_\n  , nohref\n  , nohref_\n  , alt\n  , alt_\n  , height\n  , height_\n  , width\n  , width_\n  , src\n  , src_\n  , srcset\n  , srcset_\n  , vspace\n  , vspace_\n  , hspace\n  , hspace_\n  , border\n  , border_\n  , align\n  , align_\n  , lowsrc\n  , lowsrc_\n  , longdesc\n  , longdesc_\n  , usemap\n  , usemap_\n  , ismap\n  , ismap_\n  , loading\n  , loading_\n  , loadingEager\n  , loadingLazy\n  , decoding\n  , decoding_\n  , decodingAuto\n  , decodingAsync\n  , decodingSync\n  , scrolling\n  , scrolling_\n  , marginwidth\n  , marginwidth_\n  , marginheight\n  , marginheight_\n  , framespacing\n  , framespacing_\n  , frameborder\n  , frameborder_\n  , allowtransparency\n  , allowtransparency_\n  , allowfullscreen\n  , allowfullscreen_\n  , allow\n  , allow_\n  , sandbox\n  , sandbox_\n  , sandboxAllowTopNavigationToCustomProtocols\n  , sandboxAllowDownloads\n  , sandboxAllowPresentation\n  , sandboxAllowOrientationLock\n  , sandboxAllowModals\n  , sandboxAllowPopupsToEscapeSandbox\n  , sandboxAllowScripts\n  , sandboxAllowPointerLock\n  , sandboxAllowForms\n  , sandboxAllowSameOrigin\n  , sandboxAllowTopNavigationByUserActivation\n  , sandboxAllowTopNavigation\n  , sandboxAllowPopups\n  , srcdoc\n  , srcdoc_\n  , typemustmatch\n  , typemustmatch_\n  , standby\n  , standby_\n  , declare\n  , declare_\n  , codetype\n  , codetype_\n  , codebase\n  , codebase_\n  , code\n  , code_\n  , classid\n  , classid_\n  , archive\n  , archive_\n  , autocomplete\n  , autocomplete_\n  , autocompleteImpp\n  , autocompleteEmail\n  , autocompleteTelExtension\n  , autocompleteTelLocalSuffix\n  , autocompleteTelLocalPrefix\n  , autocompleteTelLocal\n  , autocompleteTelAreaCode\n  , autocompleteTelNational\n  , autocompleteTelCountryCode\n  , autocompleteTel\n  , autocompletePhoto\n  , autocompleteUrl\n  , autocompleteSex\n  , autocompleteBdayYear\n  , autocompleteBdayMonth\n  , autocompleteBdayDay\n  , autocompleteBday\n  , autocompleteLanguage\n  , autocompleteTransactionAmount\n  , autocompleteTransactionCurrency\n  , autocompleteCcType\n  , autocompleteCcCsc\n  , autocompleteCcExpYear\n  , autocompleteCcExpMonth\n  , autocompleteCcExp\n  , autocompleteCcNumber\n  , autocompleteCcFamilyName\n  , autocompleteCcAdditionalName\n  , autocompleteCcGivenName\n  , autocompleteCcName\n  , autocompletePostalCode\n  , autocompleteCountryName\n  , autocompleteCountry\n  , autocompleteAddressLevel1\n  , autocompleteAddressLevel2\n  , autocompleteAddressLevel3\n  , autocompleteAddressLevel4\n  , autocompleteAddressLine3\n  , autocompleteAddressLine2\n  , autocompleteAddressLine1\n  , autocompleteStreetAddress\n  , autocompleteOrganization\n  , autocompleteOneTimeCode\n  , autocompleteCurrentPassword\n  , autocompleteNewPassword\n  , autocompleteUsername\n  , autocompleteOrganizationTitle\n  , autocompleteNickname\n  , autocompleteHonorificSuffix\n  , autocompleteFamilyName\n  , autocompleteAdditionalName\n  , autocompleteGivenName\n  , autocompleteHonorificPrefix\n  , autocompleteName\n  , autocompleteOn\n  , autocompleteOff\n  , autocompletePager\n  , autocompleteFax\n  , autocompleteMobile\n  , autocompleteWork\n  , autocompleteHome\n  , autocompleteBilling\n  , autocompleteShipping\n  , autocompleteSection\n  , form\n  , form_\n  , xdata\n  , xdata_\n  , muted\n  , muted_\n  , controls\n  , controls_\n  , autoplay\n  , autoplay_\n  , loop\n  , loop_\n  , preload\n  , preload_\n  , preloadMetadata\n  , preloadNone\n  , preloadAuto\n  , playsinline\n  , playsinline_\n  , poster\n  , poster_\n  , default\n  , default_\n  , label\n  , label_\n  , srclang\n  , srclang_\n  , kind\n  , kind_\n  , kindMetadata\n  , kindChapters\n  , kindDescriptions\n  , kindCaptions\n  , kindSubtitles\n  , valign\n  , valign_\n  , charoff\n  , charoff_\n  , char\n  , char_\n  , span\n  , span_\n  , nowrap\n  , nowrap_\n  , bgcolor\n  , bgcolor_\n  , scope\n  , scope_\n  , scopeAuto\n  , scopeColgroup\n  , scopeRowgroup\n  , scopeCol\n  , scopeRow\n  , axis\n  , axis_\n  , abbr\n  , abbr_\n  , headers\n  , headers_\n  , rowspan\n  , rowspan_\n  , colspan\n  , colspan_\n  , accept\n  , accept_\n  , formnovalidate\n  , formnovalidate_\n  , novalidate\n  , novalidate_\n  , formtarget\n  , formtarget_\n  , formenctype\n  , formenctype_\n  , enctype\n  , enctype_\n  , enctypeTextPlain\n  , enctypeMultipartFormData\n  , enctypeApplicationXWwwFormUrlencoded\n  , formmethod\n  , formmethod_\n  , formmethodDialog\n  , formmethodPost\n  , formmethodGet\n  , method\n  , method_\n  , methodDialog\n  , methodPost\n  , methodGet\n  , formaction\n  , formaction_\n  , action\n  , action_\n  , acceptCharset\n  , acceptCharset_\n  , for\n  , for_\n  , capture\n  , capture_\n  , minlength\n  , minlength_\n  , maxlength\n  , maxlength_\n  , dirname\n  , dirname_\n  , placeholder\n  , placeholder_\n  , list\n  , list_\n  , step\n  , step_\n  , max\n  , max_\n  , min\n  , min_\n  , pattern\n  , pattern_\n  , multiple\n  , multiple_\n  , required\n  , required_\n  , readonly\n  , readonly_\n  , size\n  , size_\n  , checked\n  , checked_\n  , selected\n  , selected_\n  , wrap\n  , wrap_\n  , wrapHard\n  , wrapSoft\n  , rows\n  , rows_\n  , cols\n  , cols_\n  , optimum\n  , optimum_\n  , high\n  , high_\n  , low\n  , low_\n  , open\n  , open_\n  , event\n  , event_\n  , language\n  , language_\n  , defer\n  , defer_\n  , async\n  , async_\n  , nomodule\n  , nomodule_\n  , shadowrootserializable\n  , shadowrootserializable_\n  , shadowrootclonable\n  , shadowrootclonable_\n  , shadowrootdelegatesfocus\n  , shadowrootdelegatesfocus_\n  , shadowrootmode\n  , shadowrootmode_\n  , shadowrootmodeClosed\n  , shadowrootmodeOpen\n  , profile\n  , profile_\n  , version\n  , version_\n  , manifest\n  , manifest_\n  , rules\n  , rules_\n  , frame\n  , frame_\n  , cellspacing\n  , cellspacing_\n  , cellpadding\n  , cellpadding_\n  , bordercolor\n  , bordercolor_\n  , summary\n  , summary_\n  , datapagesize\n  , datapagesize_\n  , vlink\n  , vlink_\n  , topmargin\n  , topmargin_\n  , text\n  , text_\n  , rightmargin\n  , rightmargin_\n  , link\n  , link_\n  , leftmargin\n  , leftmargin_\n  , bottommargin\n  , bottommargin_\n  , alink\n  , alink_\n  , clear\n  , clear_\n  , noshade\n  , noshade_\n  , truespeed\n  , truespeed_\n  , direction\n  , direction_\n  , behavior\n  , behavior_\n  , ariaValuetext\n  , ariaValuetext_\n  , ariaValuenow\n  , ariaValuenow_\n  , ariaValuemin\n  , ariaValuemin_\n  , ariaValuemax\n  , ariaValuemax_\n  , ariaSort\n  , ariaSort_\n  , ariaSetsize\n  , ariaSetsize_\n  , ariaSelected\n  , ariaSelected_\n  , ariaRowspan\n  , ariaRowspan_\n  , ariaRowindextext\n  , ariaRowindextext_\n  , ariaRowindex\n  , ariaRowindex_\n  , ariaRowcount\n  , ariaRowcount_\n  , ariaRoledescription\n  , ariaRoledescription_\n  , ariaRequired\n  , ariaRequired_\n  , ariaReadonly\n  , ariaReadonly_\n  , ariaPressed\n  , ariaPressed_\n  , ariaPosinset\n  , ariaPosinset_\n  , ariaPlaceholder\n  , ariaPlaceholder_\n  , ariaOwns\n  , ariaOwns_\n  , ariaOrientation\n  , ariaOrientation_\n  , ariaMultiselectable\n  , ariaMultiselectable_\n  , ariaMultiline\n  , ariaMultiline_\n  , ariaModal\n  , ariaModal_\n  , ariaLive\n  , ariaLive_\n  , ariaLevel\n  , ariaLevel_\n  , ariaLabelledby\n  , ariaLabelledby_\n  , ariaLabel\n  , ariaLabel_\n  , ariaKeyshortcuts\n  , ariaKeyshortcuts_\n  , ariaInvalid\n  , ariaInvalid_\n  , ariaHidden\n  , ariaHidden_\n  , ariaHaspopup\n  , ariaHaspopup_\n  , ariaFlowto\n  , ariaFlowto_\n  , ariaExpanded\n  , ariaExpanded_\n  , ariaErrormessage\n  , ariaErrormessage_\n  , ariaDisabled\n  , ariaDisabled_\n  , ariaDetails\n  , ariaDetails_\n  , ariaDescription\n  , ariaDescription_\n  , ariaDescribedby\n  , ariaDescribedby_\n  , ariaCurrent\n  , ariaCurrent_\n  , ariaControls\n  , ariaControls_\n  , ariaColspan\n  , ariaColspan_\n  , ariaColindextext\n  , ariaColindextext_\n  , ariaColindex\n  , ariaColindex_\n  , ariaColcount\n  , ariaColcount_\n  , ariaChecked\n  , ariaChecked_\n  , ariaBusy\n  , ariaBusy_\n  , ariaBrailleroledescription\n  , ariaBrailleroledescription_\n  , ariaBraillelabel\n  , ariaBraillelabel_\n  , ariaAutocomplete\n  , ariaAutocomplete_\n  , ariaAtomic\n  , ariaAtomic_\n  , ariaActivedescendant\n  , ariaActivedescendant_\n  , role\n  , role_\n  ) where\n\nimport Control.Applicative (pure, class Applicative) as Applicative\nimport Control.Category ((<<<))\nimport Data.Functor (map, class Functor) as Functor\nimport Deku.DOM.Combinators (unset) as Combinators\nimport Deku.Attribute as Deku.Attribute\n\ntabindex\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (tabindex :: String | r))\ntabindex = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"tabindex\")\n\ntabindex_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (tabindex :: String | r))\ntabindex_ = tabindex <<< Applicative.pure\n\nnonce\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (nonce :: String | r))\nnonce = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"nonce\")\n\nnonce_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (nonce :: String | r))\nnonce_ = nonce <<< Applicative.pure\n\nslot\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (slot :: String | r))\nslot = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"slot\")\n\nslot_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (slot :: String | r))\nslot_ = slot <<< Applicative.pure\n\nid :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (id :: String | r))\nid = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"id\")\n\nid_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (id :: String | r))\nid_ = id <<< Applicative.pure\n\nklass\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (klass :: String | r))\nklass = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"class\")\n\nklass_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (klass :: String | r))\nklass_ = klass <<< Applicative.pure\n\npopovertargetaction\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (popovertargetaction :: String | r))\npopovertargetaction = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"popovertargetaction\")\n\npopovertargetaction_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (popovertargetaction :: String | r))\npopovertargetaction_ = popovertargetaction <<< Applicative.pure\n\npopovertargetactionHide\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (popovertargetaction :: String | r))\npopovertargetactionHide = popovertargetaction_ \"hide\"\n\npopovertargetactionShow\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (popovertargetaction :: String | r))\npopovertargetactionShow = popovertargetaction_ \"show\"\n\npopovertargetactionToggle\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (popovertargetaction :: String | r))\npopovertargetactionToggle = popovertargetaction_ \"toggle\"\n\npopovertarget\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (popovertarget :: String | r))\npopovertarget = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"popovertarget\")\n\npopovertarget_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (popovertarget :: String | r))\npopovertarget_ = popovertarget <<< Applicative.pure\n\npopover\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (popover :: String | r))\npopover = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"popover\")\n\npopover_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (popover :: String | r))\npopover_ = popover <<< Applicative.pure\n\npopoverManual\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (popover :: String | r))\npopoverManual = popover_ \"manual\"\n\npopoverAuto\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (popover :: String | r))\npopoverAuto = popover_ \"auto\"\n\ndraggable\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (draggable :: String | r))\ndraggable = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"draggable\")\n\ndraggable_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (draggable :: String | r))\ndraggable_ = draggable <<< Applicative.pure\n\ndraggableFalse\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (draggable :: String | r))\ndraggableFalse = draggable_ \"false\"\n\ndraggableTrue\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (draggable :: String | r))\ndraggableTrue = draggable_ \"true\"\n\nenterkeyhint\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (enterkeyhint :: String | r))\nenterkeyhint = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"enterkeyhint\")\n\nenterkeyhint_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (enterkeyhint :: String | r))\nenterkeyhint_ = enterkeyhint <<< Applicative.pure\n\nenterkeyhintSend\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (enterkeyhint :: String | r))\nenterkeyhintSend = enterkeyhint_ \"send\"\n\nenterkeyhintSearch\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (enterkeyhint :: String | r))\nenterkeyhintSearch = enterkeyhint_ \"search\"\n\nenterkeyhintPrevious\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (enterkeyhint :: String | r))\nenterkeyhintPrevious = enterkeyhint_ \"previous\"\n\nenterkeyhintNext\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (enterkeyhint :: String | r))\nenterkeyhintNext = enterkeyhint_ \"next\"\n\nenterkeyhintGo\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (enterkeyhint :: String | r))\nenterkeyhintGo = enterkeyhint_ \"go\"\n\nenterkeyhintDone\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (enterkeyhint :: String | r))\nenterkeyhintDone = enterkeyhint_ \"done\"\n\nenterkeyhintEnter\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (enterkeyhint :: String | r))\nenterkeyhintEnter = enterkeyhint_ \"enter\"\n\ninputmode\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (inputmode :: String | r))\ninputmode = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"inputmode\")\n\ninputmode_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (inputmode :: String | r))\ninputmode_ = inputmode <<< Applicative.pure\n\ninputmodeSearch\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (inputmode :: String | r))\ninputmodeSearch = inputmode_ \"search\"\n\ninputmodeDecimal\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (inputmode :: String | r))\ninputmodeDecimal = inputmode_ \"decimal\"\n\ninputmodeNumeric\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (inputmode :: String | r))\ninputmodeNumeric = inputmode_ \"numeric\"\n\ninputmodeEmail\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (inputmode :: String | r))\ninputmodeEmail = inputmode_ \"email\"\n\ninputmodeUrl\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (inputmode :: String | r))\ninputmodeUrl = inputmode_ \"url\"\n\ninputmodeTel\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (inputmode :: String | r))\ninputmodeTel = inputmode_ \"tel\"\n\ninputmodeText\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (inputmode :: String | r))\ninputmodeText = inputmode_ \"text\"\n\ninputmodeNone\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (inputmode :: String | r))\ninputmodeNone = inputmode_ \"none\"\n\nautocapitalize\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (autocapitalize :: String | r))\nautocapitalize = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"autocapitalize\")\n\nautocapitalize_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (autocapitalize :: String | r))\nautocapitalize_ = autocapitalize <<< Applicative.pure\n\nautocapitalizeCharacters\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocapitalize :: String | r))\nautocapitalizeCharacters = autocapitalize_ \"characters\"\n\nautocapitalizeWords\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocapitalize :: String | r))\nautocapitalizeWords = autocapitalize_ \"words\"\n\nautocapitalizeSentences\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocapitalize :: String | r))\nautocapitalizeSentences = autocapitalize_ \"sentences\"\n\nautocapitalizeOn\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocapitalize :: String | r))\nautocapitalizeOn = autocapitalize_ \"on\"\n\nautocapitalizeNone\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocapitalize :: String | r))\nautocapitalizeNone = autocapitalize_ \"none\"\n\nautocapitalizeOff\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocapitalize :: String | r))\nautocapitalizeOff = autocapitalize_ \"off\"\n\nwritingsuggestions\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (writingsuggestions :: String | r))\nwritingsuggestions = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"writingsuggestions\")\n\nwritingsuggestions_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (writingsuggestions :: String | r))\nwritingsuggestions_ = writingsuggestions <<< Applicative.pure\n\nwritingsuggestionsFalse\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (writingsuggestions :: String | r))\nwritingsuggestionsFalse = writingsuggestions_ \"false\"\n\nwritingsuggestionsTrue\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (writingsuggestions :: String | r))\nwritingsuggestionsTrue = writingsuggestions_ \"true\"\n\nspellcheck\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (spellcheck :: String | r))\nspellcheck = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"spellcheck\")\n\nspellcheck_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (spellcheck :: String | r))\nspellcheck_ = spellcheck <<< Applicative.pure\n\nspellcheckFalse\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (spellcheck :: String | r))\nspellcheckFalse = spellcheck_ \"false\"\n\nspellcheckTrue\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (spellcheck :: String | r))\nspellcheckTrue = spellcheck_ \"true\"\n\ncontenteditable\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (contenteditable :: String | r))\ncontenteditable = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"contenteditable\")\n\ncontenteditable_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (contenteditable :: String | r))\ncontenteditable_ = contenteditable <<< Applicative.pure\n\ncontenteditablePlaintextOnly\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (contenteditable :: String | r))\ncontenteditablePlaintextOnly = contenteditable_ \"plaintext-only\"\n\ncontenteditableFalse\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (contenteditable :: String | r))\ncontenteditableFalse = contenteditable_ \"false\"\n\ncontenteditableTrue\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (contenteditable :: String | r))\ncontenteditableTrue = contenteditable_ \"true\"\n\naccesskey\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (accesskey :: String | r))\naccesskey = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"accesskey\")\n\naccesskey_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (accesskey :: String | r))\naccesskey_ = accesskey <<< Applicative.pure\n\nautofocus\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (autofocus :: String | r))\nautofocus = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"autofocus\")\n\nautofocus_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (autofocus :: String | r))\nautofocus_ = autofocus <<< Applicative.pure\n\nhidden\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (hidden :: String | r))\nhidden = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"hidden\")\n\nhidden_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (hidden :: String | r))\nhidden_ = hidden <<< Applicative.pure\n\nhiddenUntilFound\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (hidden :: String | r))\nhiddenUntilFound = hidden_ \"until-found\"\n\nhiddenHidden\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (hidden :: String | r))\nhiddenHidden = hidden_ \"hidden\"\n\nitemprop\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (itemprop :: String | r))\nitemprop = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"itemprop\")\n\nitemprop_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (itemprop :: String | r))\nitemprop_ = itemprop <<< Applicative.pure\n\nitemref\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (itemref :: String | r))\nitemref = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"itemref\")\n\nitemref_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (itemref :: String | r))\nitemref_ = itemref <<< Applicative.pure\n\nitemid\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (itemid :: String | r))\nitemid = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"itemid\")\n\nitemid_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (itemid :: String | r))\nitemid_ = itemid <<< Applicative.pure\n\nitemtype\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (itemtype :: String | r))\nitemtype = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"itemtype\")\n\nitemtype_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (itemtype :: String | r))\nitemtype_ = itemtype <<< Applicative.pure\n\nitemscope\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (itemscope :: String | r))\nitemscope = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"itemscope\")\n\nitemscope_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (itemscope :: String | r))\nitemscope_ = itemscope <<< Applicative.pure\n\nis :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (is :: String | r))\nis = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"is\")\n\nis_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (is :: String | r))\nis_ = is <<< Applicative.pure\n\ntitle\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (title :: String | r))\ntitle = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"title\")\n\ntitle_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (title :: String | r))\ntitle_ = title <<< Applicative.pure\n\nstyle\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (style :: String | r))\nstyle = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"style\")\n\nstyle_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (style :: String | r))\nstyle_ = style <<< Applicative.pure\n\ndir\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (dir :: String | r))\ndir = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"dir\")\n\ndir_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (dir :: String | r))\ndir_ = dir <<< Applicative.pure\n\ndirAuto\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (dir :: String | r))\ndirAuto = dir_ \"auto\"\n\ndirRtl :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (dir :: String | r))\ndirRtl = dir_ \"rtl\"\n\ndirLtr :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (dir :: String | r))\ndirLtr = dir_ \"ltr\"\n\ntranslate\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (translate :: String | r))\ntranslate = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"translate\")\n\ntranslate_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (translate :: String | r))\ntranslate_ = translate <<< Applicative.pure\n\ntranslateNo\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (translate :: String | r))\ntranslateNo = translate_ \"no\"\n\ntranslateYes\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (translate :: String | r))\ntranslateYes = translate_ \"yes\"\n\nlang\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (lang :: String | r))\nlang = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"lang\")\n\nlang_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (lang :: String | r))\nlang_ = lang <<< Applicative.pure\n\ntarget\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (target :: String | r))\ntarget = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"target\")\n\ntarget_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (target :: String | r))\ntarget_ = target <<< Applicative.pure\n\nhref\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (href :: String | r))\nhref = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"href\")\n\nhref_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (href :: String | r))\nhref_ = href <<< Applicative.pure\n\nurn\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (urn :: String | r))\nurn = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"urn\")\n\nurn_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (urn :: String | r))\nurn_ = urn <<< Applicative.pure\n\nrev\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (rev :: String | r))\nrev = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"rev\")\n\nrev_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (rev :: String | r))\nrev_ = rev <<< Applicative.pure\n\nmethods\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (methods :: String | r))\nmethods = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"methods\")\n\nmethods_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (methods :: String | r))\nmethods_ = methods <<< Applicative.pure\n\ncharset\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (charset :: String | r))\ncharset = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"charset\")\n\ncharset_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (charset :: String | r))\ncharset_ = charset <<< Applicative.pure\n\nfetchpriority\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (fetchpriority :: String | r))\nfetchpriority = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"fetchpriority\")\n\nfetchpriority_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (fetchpriority :: String | r))\nfetchpriority_ = fetchpriority <<< Applicative.pure\n\nfetchpriorityAuto\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (fetchpriority :: String | r))\nfetchpriorityAuto = fetchpriority_ \"auto\"\n\nfetchpriorityLow\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (fetchpriority :: String | r))\nfetchpriorityLow = fetchpriority_ \"low\"\n\nfetchpriorityHigh\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (fetchpriority :: String | r))\nfetchpriorityHigh = fetchpriority_ \"high\"\n\ndisabled\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (disabled :: String | r))\ndisabled = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"disabled\")\n\ndisabled_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (disabled :: String | r))\ndisabled_ = disabled <<< Applicative.pure\n\ncolor\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (color :: String | r))\ncolor = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"color\")\n\ncolor_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (color :: String | r))\ncolor_ = color <<< Applicative.pure\n\nblocking\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (blocking :: String | r))\nblocking = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"blocking\")\n\nblocking_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (blocking :: String | r))\nblocking_ = blocking <<< Applicative.pure\n\nas :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (as :: String | r))\nas = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"as\")\n\nas_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (as :: String | r))\nas_ = as <<< Applicative.pure\n\nsizes\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (sizes :: String | r))\nsizes = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"sizes\")\n\nsizes_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (sizes :: String | r))\nsizes_ = sizes <<< Applicative.pure\n\nimagesizes\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (imagesizes :: String | r))\nimagesizes = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"imagesizes\")\n\nimagesizes_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (imagesizes :: String | r))\nimagesizes_ = imagesizes <<< Applicative.pure\n\nimagesrcset\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (imagesrcset :: String | r))\nimagesrcset = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"imagesrcset\")\n\nimagesrcset_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (imagesrcset :: String | r))\nimagesrcset_ = imagesrcset <<< Applicative.pure\n\nreferrerpolicy\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (referrerpolicy :: String | r))\nreferrerpolicy = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"referrerpolicy\")\n\nreferrerpolicy_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (referrerpolicy :: String | r))\nreferrerpolicy_ = referrerpolicy <<< Applicative.pure\n\nxtype\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (xtype :: String | r))\nxtype = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"type\")\n\nxtype_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (xtype :: String | r))\nxtype_ = xtype <<< Applicative.pure\n\nxtypeButton\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeButton = xtype_ \"button\"\n\nxtypeReset\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeReset = xtype_ \"reset\"\n\nxtypeSubmit\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeSubmit = xtype_ \"submit\"\n\nxtypeImage\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeImage = xtype_ \"image\"\n\nxtypeFile\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeFile = xtype_ \"file\"\n\nxtypeRadio\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeRadio = xtype_ \"radio\"\n\nxtypeCheckbox\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeCheckbox = xtype_ \"checkbox\"\n\nxtypeColor\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeColor = xtype_ \"color\"\n\nxtypeRange\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeRange = xtype_ \"range\"\n\nxtypeNumber\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeNumber = xtype_ \"number\"\n\nxtypeDatetimeLocal\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeDatetimeLocal = xtype_ \"datetime-local\"\n\nxtypeTime\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeTime = xtype_ \"time\"\n\nxtypeWeek\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeWeek = xtype_ \"week\"\n\nxtypeMonth\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeMonth = xtype_ \"month\"\n\nxtypeDate\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeDate = xtype_ \"date\"\n\nxtypePassword\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypePassword = xtype_ \"password\"\n\nxtypeEmail\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeEmail = xtype_ \"email\"\n\nxtypeUrl\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeUrl = xtype_ \"url\"\n\nxtypeTel\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeTel = xtype_ \"tel\"\n\nxtypeSearch\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeSearch = xtype_ \"search\"\n\nxtypeText\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeText = xtype_ \"text\"\n\nxtypeHidden\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeHidden = xtype_ \"hidden\"\n\nxtypeUpperI\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeUpperI = xtype_ \"I\"\n\nxtypeLowerI\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeLowerI = xtype_ \"i\"\n\nxtypeUpperA\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeUpperA = xtype_ \"A\"\n\nxtypeLowerA\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtypeLowerA = xtype_ \"a\"\n\nxtype1\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (xtype :: String | r))\nxtype1 = xtype_ \"1\"\n\nhreflang\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (hreflang :: String | r))\nhreflang = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"hreflang\")\n\nhreflang_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (hreflang :: String | r))\nhreflang_ = hreflang <<< Applicative.pure\n\nintegrity\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (integrity :: String | r))\nintegrity = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"integrity\")\n\nintegrity_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (integrity :: String | r))\nintegrity_ = integrity <<< Applicative.pure\n\nmedia\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (media :: String | r))\nmedia = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"media\")\n\nmedia_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (media :: String | r))\nmedia_ = media <<< Applicative.pure\n\ncrossorigin\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (crossorigin :: String | r))\ncrossorigin = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"crossorigin\")\n\ncrossorigin_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (crossorigin :: String | r))\ncrossorigin_ = crossorigin <<< Applicative.pure\n\ncrossoriginUseCredentials\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (crossorigin :: String | r))\ncrossoriginUseCredentials = crossorigin_ \"use-credentials\"\n\ncrossoriginAnonymous\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (crossorigin :: String | r))\ncrossoriginAnonymous = crossorigin_ \"anonymous\"\n\nrel\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (rel :: String | r))\nrel = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"rel\")\n\nrel_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (rel :: String | r))\nrel_ = rel <<< Applicative.pure\n\nrelPrev\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelPrev = rel_ \"prev\"\n\nrelNext\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelNext = rel_ \"next\"\n\nrelTermsOfService\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelTermsOfService = rel_ \"terms-of-service\"\n\nrelTag :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelTag = rel_ \"tag\"\n\nrelStylesheet\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelStylesheet = rel_ \"stylesheet\"\n\nrelSearch\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelSearch = rel_ \"search\"\n\nrelPrivacyPolicy\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelPrivacyPolicy = rel_ \"privacy-policy\"\n\nrelPreload\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelPreload = rel_ \"preload\"\n\nrelPrefetch\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelPrefetch = rel_ \"prefetch\"\n\nrelPreconnect\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelPreconnect = rel_ \"preconnect\"\n\nrelPingback\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelPingback = rel_ \"pingback\"\n\nrelOpener\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelOpener = rel_ \"opener\"\n\nrelNoreferrer\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelNoreferrer = rel_ \"noreferrer\"\n\nrelNoopener\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelNoopener = rel_ \"noopener\"\n\nrelNofollow\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelNofollow = rel_ \"nofollow\"\n\nrelModulepreload\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelModulepreload = rel_ \"modulepreload\"\n\nrelManifest\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelManifest = rel_ \"manifest\"\n\nrelLicense\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelLicense = rel_ \"license\"\n\nrelIcon\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelIcon = rel_ \"icon\"\n\nrelHelp\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelHelp = rel_ \"help\"\n\nrelExternal\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelExternal = rel_ \"external\"\n\nrelExpect\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelExpect = rel_ \"expect\"\n\nrelDnsPrefetch\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelDnsPrefetch = rel_ \"dns-prefetch\"\n\nrelCanonical\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelCanonical = rel_ \"canonical\"\n\nrelBookmark\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelBookmark = rel_ \"bookmark\"\n\nrelAuthor\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelAuthor = rel_ \"author\"\n\nrelAlternate\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (rel :: String | r))\nrelAlternate = rel_ \"alternate\"\n\nscheme\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (scheme :: String | r))\nscheme = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"scheme\")\n\nscheme_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (scheme :: String | r))\nscheme_ = scheme <<< Applicative.pure\n\nhttpEquiv\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (httpEquiv :: String | r))\nhttpEquiv = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"http-equiv\")\n\nhttpEquiv_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (httpEquiv :: String | r))\nhttpEquiv_ = httpEquiv <<< Applicative.pure\n\nhttpEquivContentSecurityPolicy\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (httpEquiv :: String | r))\nhttpEquivContentSecurityPolicy = httpEquiv_ \"content-security-policy\"\n\nhttpEquivXUaCompatible\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (httpEquiv :: String | r))\nhttpEquivXUaCompatible = httpEquiv_ \"x-ua-compatible\"\n\nhttpEquivSetCookie\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (httpEquiv :: String | r))\nhttpEquivSetCookie = httpEquiv_ \"set-cookie\"\n\nhttpEquivRefresh\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (httpEquiv :: String | r))\nhttpEquivRefresh = httpEquiv_ \"refresh\"\n\nhttpEquivDefaultStyle\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (httpEquiv :: String | r))\nhttpEquivDefaultStyle = httpEquiv_ \"default-style\"\n\nhttpEquivContentType\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (httpEquiv :: String | r))\nhttpEquivContentType = httpEquiv_ \"content-type\"\n\nhttpEquivContentLanguage\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (httpEquiv :: String | r))\nhttpEquivContentLanguage = httpEquiv_ \"content-language\"\n\nname\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (name :: String | r))\nname = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"name\")\n\nname_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (name :: String | r))\nname_ = name <<< Applicative.pure\n\nnameColorScheme\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (name :: String | r))\nnameColorScheme = name_ \"color-scheme\"\n\nnameThemeColor\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (name :: String | r))\nnameThemeColor = name_ \"theme-color\"\n\nnameReferrer\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (name :: String | r))\nnameReferrer = name_ \"referrer\"\n\nnameKeywords\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (name :: String | r))\nnameKeywords = name_ \"keywords\"\n\nnameGenerator\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (name :: String | r))\nnameGenerator = name_ \"generator\"\n\nnameDescription\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (name :: String | r))\nnameDescription = name_ \"description\"\n\nnameAuthor\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (name :: String | r))\nnameAuthor = name_ \"author\"\n\nnameApplicationName\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (name :: String | r))\nnameApplicationName = name_ \"application-name\"\n\ncontent\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (content :: String | r))\ncontent = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"content\")\n\ncontent_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (content :: String | r))\ncontent_ = content <<< Applicative.pure\n\ncite\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (cite :: String | r))\ncite = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"cite\")\n\ncite_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (cite :: String | r))\ncite_ = cite <<< Applicative.pure\n\ncompact\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (compact :: String | r))\ncompact = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"compact\")\n\ncompact_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (compact :: String | r))\ncompact_ = compact <<< Applicative.pure\n\nstart\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (start :: String | r))\nstart = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"start\")\n\nstart_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (start :: String | r))\nstart_ = start <<< Applicative.pure\n\nreversed\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (reversed :: String | r))\nreversed = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"reversed\")\n\nreversed_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (reversed :: String | r))\nreversed_ = reversed <<< Applicative.pure\n\nvalue\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (value :: String | r))\nvalue = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"value\")\n\nvalue_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (value :: String | r))\nvalue_ = value <<< Applicative.pure\n\ndatetime\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (datetime :: String | r))\ndatetime = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"datetime\")\n\ndatetime_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (datetime :: String | r))\ndatetime_ = datetime <<< Applicative.pure\n\nshape\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (shape :: String | r))\nshape = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"shape\")\n\nshape_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (shape :: String | r))\nshape_ = shape <<< Applicative.pure\n\nshapeRectangleState\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (shape :: String | r))\nshapeRectangleState = shape_ \"rectangle state\"\n\nshapePolygonState\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (shape :: String | r))\nshapePolygonState = shape_ \"polygon state\"\n\nshapeDefaultState\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (shape :: String | r))\nshapeDefaultState = shape_ \"default state\"\n\nshapeCircleState\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (shape :: String | r))\nshapeCircleState = shape_ \"circle state\"\n\ncoords\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (coords :: String | r))\ncoords = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"coords\")\n\ncoords_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (coords :: String | r))\ncoords_ = coords <<< Applicative.pure\n\nping\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (ping :: String | r))\nping = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"ping\")\n\nping_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ping :: String | r))\nping_ = ping <<< Applicative.pure\n\ndownload\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (download :: String | r))\ndownload = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"download\")\n\ndownload_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (download :: String | r))\ndownload_ = download <<< Applicative.pure\n\nnohref\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (nohref :: String | r))\nnohref = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"nohref\")\n\nnohref_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (nohref :: String | r))\nnohref_ = nohref <<< Applicative.pure\n\nalt\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (alt :: String | r))\nalt = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"alt\")\n\nalt_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (alt :: String | r))\nalt_ = alt <<< Applicative.pure\n\nheight\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (height :: String | r))\nheight = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"height\")\n\nheight_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (height :: String | r))\nheight_ = height <<< Applicative.pure\n\nwidth\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (width :: String | r))\nwidth = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"width\")\n\nwidth_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (width :: String | r))\nwidth_ = width <<< Applicative.pure\n\nsrc\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (src :: String | r))\nsrc = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"src\")\n\nsrc_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (src :: String | r))\nsrc_ = src <<< Applicative.pure\n\nsrcset\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (srcset :: String | r))\nsrcset = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"srcset\")\n\nsrcset_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (srcset :: String | r))\nsrcset_ = srcset <<< Applicative.pure\n\nvspace\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (vspace :: String | r))\nvspace = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"vspace\")\n\nvspace_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (vspace :: String | r))\nvspace_ = vspace <<< Applicative.pure\n\nhspace\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (hspace :: String | r))\nhspace = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"hspace\")\n\nhspace_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (hspace :: String | r))\nhspace_ = hspace <<< Applicative.pure\n\nborder\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (border :: String | r))\nborder = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"border\")\n\nborder_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (border :: String | r))\nborder_ = border <<< Applicative.pure\n\nalign\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (align :: String | r))\nalign = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"align\")\n\nalign_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (align :: String | r))\nalign_ = align <<< Applicative.pure\n\nlowsrc\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (lowsrc :: String | r))\nlowsrc = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"lowsrc\")\n\nlowsrc_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (lowsrc :: String | r))\nlowsrc_ = lowsrc <<< Applicative.pure\n\nlongdesc\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (longdesc :: String | r))\nlongdesc = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"longdesc\")\n\nlongdesc_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (longdesc :: String | r))\nlongdesc_ = longdesc <<< Applicative.pure\n\nusemap\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (usemap :: String | r))\nusemap = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"usemap\")\n\nusemap_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (usemap :: String | r))\nusemap_ = usemap <<< Applicative.pure\n\nismap\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (ismap :: String | r))\nismap = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"ismap\")\n\nismap_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ismap :: String | r))\nismap_ = ismap <<< Applicative.pure\n\nloading\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (loading :: String | r))\nloading = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"loading\")\n\nloading_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (loading :: String | r))\nloading_ = loading <<< Applicative.pure\n\nloadingEager\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (loading :: String | r))\nloadingEager = loading_ \"eager\"\n\nloadingLazy\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (loading :: String | r))\nloadingLazy = loading_ \"lazy\"\n\ndecoding\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (decoding :: String | r))\ndecoding = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"decoding\")\n\ndecoding_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (decoding :: String | r))\ndecoding_ = decoding <<< Applicative.pure\n\ndecodingAuto\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (decoding :: String | r))\ndecodingAuto = decoding_ \"auto\"\n\ndecodingAsync\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (decoding :: String | r))\ndecodingAsync = decoding_ \"async\"\n\ndecodingSync\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (decoding :: String | r))\ndecodingSync = decoding_ \"sync\"\n\nscrolling\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (scrolling :: String | r))\nscrolling = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"scrolling\")\n\nscrolling_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (scrolling :: String | r))\nscrolling_ = scrolling <<< Applicative.pure\n\nmarginwidth\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (marginwidth :: String | r))\nmarginwidth = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"marginwidth\")\n\nmarginwidth_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (marginwidth :: String | r))\nmarginwidth_ = marginwidth <<< Applicative.pure\n\nmarginheight\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (marginheight :: String | r))\nmarginheight = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"marginheight\")\n\nmarginheight_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (marginheight :: String | r))\nmarginheight_ = marginheight <<< Applicative.pure\n\nframespacing\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (framespacing :: String | r))\nframespacing = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"framespacing\")\n\nframespacing_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (framespacing :: String | r))\nframespacing_ = framespacing <<< Applicative.pure\n\nframeborder\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (frameborder :: String | r))\nframeborder = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"frameborder\")\n\nframeborder_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (frameborder :: String | r))\nframeborder_ = frameborder <<< Applicative.pure\n\nallowtransparency\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (allowtransparency :: String | r))\nallowtransparency = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"allowtransparency\")\n\nallowtransparency_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (allowtransparency :: String | r))\nallowtransparency_ = allowtransparency <<< Applicative.pure\n\nallowfullscreen\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (allowfullscreen :: String | r))\nallowfullscreen = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"allowfullscreen\")\n\nallowfullscreen_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (allowfullscreen :: String | r))\nallowfullscreen_ = allowfullscreen <<< Applicative.pure\n\nallow\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (allow :: String | r))\nallow = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"allow\")\n\nallow_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (allow :: String | r))\nallow_ = allow <<< Applicative.pure\n\nsandbox\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (sandbox :: String | r))\nsandbox = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"sandbox\")\n\nsandbox_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (sandbox :: String | r))\nsandbox_ = sandbox <<< Applicative.pure\n\nsandboxAllowTopNavigationToCustomProtocols\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (sandbox :: String | r))\nsandboxAllowTopNavigationToCustomProtocols = sandbox_ \"allow-top-navigation-to-custom-protocols\"\n\nsandboxAllowDownloads\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (sandbox :: String | r))\nsandboxAllowDownloads = sandbox_ \"allow-downloads\"\n\nsandboxAllowPresentation\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (sandbox :: String | r))\nsandboxAllowPresentation = sandbox_ \"allow-presentation\"\n\nsandboxAllowOrientationLock\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (sandbox :: String | r))\nsandboxAllowOrientationLock = sandbox_ \"allow-orientation-lock\"\n\nsandboxAllowModals\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (sandbox :: String | r))\nsandboxAllowModals = sandbox_ \"allow-modals\"\n\nsandboxAllowPopupsToEscapeSandbox\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (sandbox :: String | r))\nsandboxAllowPopupsToEscapeSandbox = sandbox_ \"allow-popups-to-escape-sandbox\"\n\nsandboxAllowScripts\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (sandbox :: String | r))\nsandboxAllowScripts = sandbox_ \"allow-scripts\"\n\nsandboxAllowPointerLock\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (sandbox :: String | r))\nsandboxAllowPointerLock = sandbox_ \"allow-pointer-lock\"\n\nsandboxAllowForms\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (sandbox :: String | r))\nsandboxAllowForms = sandbox_ \"allow-forms\"\n\nsandboxAllowSameOrigin\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (sandbox :: String | r))\nsandboxAllowSameOrigin = sandbox_ \"allow-same-origin\"\n\nsandboxAllowTopNavigationByUserActivation\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (sandbox :: String | r))\nsandboxAllowTopNavigationByUserActivation = sandbox_ \"allow-top-navigation-by-user-activation\"\n\nsandboxAllowTopNavigation\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (sandbox :: String | r))\nsandboxAllowTopNavigation = sandbox_ \"allow-top-navigation\"\n\nsandboxAllowPopups\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (sandbox :: String | r))\nsandboxAllowPopups = sandbox_ \"allow-popups\"\n\nsrcdoc\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (srcdoc :: String | r))\nsrcdoc = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"srcdoc\")\n\nsrcdoc_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (srcdoc :: String | r))\nsrcdoc_ = srcdoc <<< Applicative.pure\n\ntypemustmatch\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (typemustmatch :: String | r))\ntypemustmatch = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"typemustmatch\")\n\ntypemustmatch_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (typemustmatch :: String | r))\ntypemustmatch_ = typemustmatch <<< Applicative.pure\n\nstandby\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (standby :: String | r))\nstandby = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"standby\")\n\nstandby_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (standby :: String | r))\nstandby_ = standby <<< Applicative.pure\n\ndeclare\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (declare :: String | r))\ndeclare = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"declare\")\n\ndeclare_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (declare :: String | r))\ndeclare_ = declare <<< Applicative.pure\n\ncodetype\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (codetype :: String | r))\ncodetype = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"codetype\")\n\ncodetype_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (codetype :: String | r))\ncodetype_ = codetype <<< Applicative.pure\n\ncodebase\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (codebase :: String | r))\ncodebase = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"codebase\")\n\ncodebase_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (codebase :: String | r))\ncodebase_ = codebase <<< Applicative.pure\n\ncode\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (code :: String | r))\ncode = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"code\")\n\ncode_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (code :: String | r))\ncode_ = code <<< Applicative.pure\n\nclassid\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (classid :: String | r))\nclassid = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"classid\")\n\nclassid_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (classid :: String | r))\nclassid_ = classid <<< Applicative.pure\n\narchive\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (archive :: String | r))\narchive = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"archive\")\n\narchive_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (archive :: String | r))\narchive_ = archive <<< Applicative.pure\n\nautocomplete\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocomplete = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"autocomplete\")\n\nautocomplete_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocomplete_ = autocomplete <<< Applicative.pure\n\nautocompleteImpp\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteImpp = autocomplete_ \"impp\"\n\nautocompleteEmail\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteEmail = autocomplete_ \"email\"\n\nautocompleteTelExtension\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteTelExtension = autocomplete_ \"tel-extension\"\n\nautocompleteTelLocalSuffix\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteTelLocalSuffix = autocomplete_ \"tel-local-suffix\"\n\nautocompleteTelLocalPrefix\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteTelLocalPrefix = autocomplete_ \"tel-local-prefix\"\n\nautocompleteTelLocal\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteTelLocal = autocomplete_ \"tel-local\"\n\nautocompleteTelAreaCode\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteTelAreaCode = autocomplete_ \"tel-area-code\"\n\nautocompleteTelNational\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteTelNational = autocomplete_ \"tel-national\"\n\nautocompleteTelCountryCode\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteTelCountryCode = autocomplete_ \"tel-country-code\"\n\nautocompleteTel\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteTel = autocomplete_ \"tel\"\n\nautocompletePhoto\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompletePhoto = autocomplete_ \"photo\"\n\nautocompleteUrl\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteUrl = autocomplete_ \"url\"\n\nautocompleteSex\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteSex = autocomplete_ \"sex\"\n\nautocompleteBdayYear\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteBdayYear = autocomplete_ \"bday-year\"\n\nautocompleteBdayMonth\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteBdayMonth = autocomplete_ \"bday-month\"\n\nautocompleteBdayDay\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteBdayDay = autocomplete_ \"bday-day\"\n\nautocompleteBday\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteBday = autocomplete_ \"bday\"\n\nautocompleteLanguage\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteLanguage = autocomplete_ \"language\"\n\nautocompleteTransactionAmount\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteTransactionAmount = autocomplete_ \"transaction-amount\"\n\nautocompleteTransactionCurrency\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteTransactionCurrency = autocomplete_ \"transaction-currency\"\n\nautocompleteCcType\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteCcType = autocomplete_ \"cc-type\"\n\nautocompleteCcCsc\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteCcCsc = autocomplete_ \"cc-csc\"\n\nautocompleteCcExpYear\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteCcExpYear = autocomplete_ \"cc-exp-year\"\n\nautocompleteCcExpMonth\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteCcExpMonth = autocomplete_ \"cc-exp-month\"\n\nautocompleteCcExp\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteCcExp = autocomplete_ \"cc-exp\"\n\nautocompleteCcNumber\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteCcNumber = autocomplete_ \"cc-number\"\n\nautocompleteCcFamilyName\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteCcFamilyName = autocomplete_ \"cc-family-name\"\n\nautocompleteCcAdditionalName\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteCcAdditionalName = autocomplete_ \"cc-additional-name\"\n\nautocompleteCcGivenName\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteCcGivenName = autocomplete_ \"cc-given-name\"\n\nautocompleteCcName\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteCcName = autocomplete_ \"cc-name\"\n\nautocompletePostalCode\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompletePostalCode = autocomplete_ \"postal-code\"\n\nautocompleteCountryName\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteCountryName = autocomplete_ \"country-name\"\n\nautocompleteCountry\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteCountry = autocomplete_ \"country\"\n\nautocompleteAddressLevel1\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteAddressLevel1 = autocomplete_ \"address-level1\"\n\nautocompleteAddressLevel2\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteAddressLevel2 = autocomplete_ \"address-level2\"\n\nautocompleteAddressLevel3\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteAddressLevel3 = autocomplete_ \"address-level3\"\n\nautocompleteAddressLevel4\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteAddressLevel4 = autocomplete_ \"address-level4\"\n\nautocompleteAddressLine3\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteAddressLine3 = autocomplete_ \"address-line3\"\n\nautocompleteAddressLine2\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteAddressLine2 = autocomplete_ \"address-line2\"\n\nautocompleteAddressLine1\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteAddressLine1 = autocomplete_ \"address-line1\"\n\nautocompleteStreetAddress\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteStreetAddress = autocomplete_ \"street-address\"\n\nautocompleteOrganization\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteOrganization = autocomplete_ \"organization\"\n\nautocompleteOneTimeCode\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteOneTimeCode = autocomplete_ \"one-time-code\"\n\nautocompleteCurrentPassword\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteCurrentPassword = autocomplete_ \"current-password\"\n\nautocompleteNewPassword\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteNewPassword = autocomplete_ \"new-password\"\n\nautocompleteUsername\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteUsername = autocomplete_ \"username\"\n\nautocompleteOrganizationTitle\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteOrganizationTitle = autocomplete_ \"organization-title\"\n\nautocompleteNickname\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteNickname = autocomplete_ \"nickname\"\n\nautocompleteHonorificSuffix\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteHonorificSuffix = autocomplete_ \"honorific-suffix\"\n\nautocompleteFamilyName\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteFamilyName = autocomplete_ \"family-name\"\n\nautocompleteAdditionalName\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteAdditionalName = autocomplete_ \"additional-name\"\n\nautocompleteGivenName\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteGivenName = autocomplete_ \"given-name\"\n\nautocompleteHonorificPrefix\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteHonorificPrefix = autocomplete_ \"honorific-prefix\"\n\nautocompleteName\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteName = autocomplete_ \"name\"\n\nautocompleteOn\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteOn = autocomplete_ \"on\"\n\nautocompleteOff\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteOff = autocomplete_ \"off\"\n\nautocompletePager\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompletePager = autocomplete_ \"pager\"\n\nautocompleteFax\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteFax = autocomplete_ \"fax\"\n\nautocompleteMobile\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteMobile = autocomplete_ \"mobile\"\n\nautocompleteWork\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteWork = autocomplete_ \"work\"\n\nautocompleteHome\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteHome = autocomplete_ \"home\"\n\nautocompleteBilling\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteBilling = autocomplete_ \"billing\"\n\nautocompleteShipping\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteShipping = autocomplete_ \"shipping\"\n\nautocompleteSection\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (autocomplete :: String | r))\nautocompleteSection = autocomplete_ \"section-\"\n\nform\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (form :: String | r))\nform = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"form\")\n\nform_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (form :: String | r))\nform_ = form <<< Applicative.pure\n\nxdata\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (xdata :: String | r))\nxdata = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"data\")\n\nxdata_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (xdata :: String | r))\nxdata_ = xdata <<< Applicative.pure\n\nmuted\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (muted :: String | r))\nmuted = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"muted\")\n\nmuted_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (muted :: String | r))\nmuted_ = muted <<< Applicative.pure\n\ncontrols\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (controls :: String | r))\ncontrols = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"controls\")\n\ncontrols_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (controls :: String | r))\ncontrols_ = controls <<< Applicative.pure\n\nautoplay\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (autoplay :: String | r))\nautoplay = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"autoplay\")\n\nautoplay_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (autoplay :: String | r))\nautoplay_ = autoplay <<< Applicative.pure\n\nloop\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (loop :: String | r))\nloop = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"loop\")\n\nloop_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (loop :: String | r))\nloop_ = loop <<< Applicative.pure\n\npreload\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (preload :: String | r))\npreload = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"preload\")\n\npreload_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (preload :: String | r))\npreload_ = preload <<< Applicative.pure\n\npreloadMetadata\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (preload :: String | r))\npreloadMetadata = preload_ \"metadata\"\n\npreloadNone\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (preload :: String | r))\npreloadNone = preload_ \"none\"\n\npreloadAuto\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (preload :: String | r))\npreloadAuto = preload_ \"auto\"\n\nplaysinline\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (playsinline :: String | r))\nplaysinline = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"playsinline\")\n\nplaysinline_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (playsinline :: String | r))\nplaysinline_ = playsinline <<< Applicative.pure\n\nposter\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (poster :: String | r))\nposter = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"poster\")\n\nposter_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (poster :: String | r))\nposter_ = poster <<< Applicative.pure\n\ndefault\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (default :: String | r))\ndefault = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"default\")\n\ndefault_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (default :: String | r))\ndefault_ = default <<< Applicative.pure\n\nlabel\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (label :: String | r))\nlabel = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"label\")\n\nlabel_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (label :: String | r))\nlabel_ = label <<< Applicative.pure\n\nsrclang\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (srclang :: String | r))\nsrclang = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"srclang\")\n\nsrclang_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (srclang :: String | r))\nsrclang_ = srclang <<< Applicative.pure\n\nkind\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (kind :: String | r))\nkind = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"kind\")\n\nkind_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (kind :: String | r))\nkind_ = kind <<< Applicative.pure\n\nkindMetadata\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (kind :: String | r))\nkindMetadata = kind_ \"metadata\"\n\nkindChapters\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (kind :: String | r))\nkindChapters = kind_ \"chapters\"\n\nkindDescriptions\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (kind :: String | r))\nkindDescriptions = kind_ \"descriptions\"\n\nkindCaptions\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (kind :: String | r))\nkindCaptions = kind_ \"captions\"\n\nkindSubtitles\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (kind :: String | r))\nkindSubtitles = kind_ \"subtitles\"\n\nvalign\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (valign :: String | r))\nvalign = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"valign\")\n\nvalign_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (valign :: String | r))\nvalign_ = valign <<< Applicative.pure\n\ncharoff\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (charoff :: String | r))\ncharoff = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"charoff\")\n\ncharoff_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (charoff :: String | r))\ncharoff_ = charoff <<< Applicative.pure\n\nchar\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (char :: String | r))\nchar = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"char\")\n\nchar_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (char :: String | r))\nchar_ = char <<< Applicative.pure\n\nspan\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (span :: String | r))\nspan = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"span\")\n\nspan_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (span :: String | r))\nspan_ = span <<< Applicative.pure\n\nnowrap\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (nowrap :: String | r))\nnowrap = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"nowrap\")\n\nnowrap_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (nowrap :: String | r))\nnowrap_ = nowrap <<< Applicative.pure\n\nbgcolor\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (bgcolor :: String | r))\nbgcolor = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"bgcolor\")\n\nbgcolor_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (bgcolor :: String | r))\nbgcolor_ = bgcolor <<< Applicative.pure\n\nscope\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (scope :: String | r))\nscope = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"scope\")\n\nscope_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (scope :: String | r))\nscope_ = scope <<< Applicative.pure\n\nscopeAuto\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (scope :: String | r))\nscopeAuto = scope_ \"auto\"\n\nscopeColgroup\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (scope :: String | r))\nscopeColgroup = scope_ \"colgroup\"\n\nscopeRowgroup\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (scope :: String | r))\nscopeRowgroup = scope_ \"rowgroup\"\n\nscopeCol\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (scope :: String | r))\nscopeCol = scope_ \"col\"\n\nscopeRow\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (scope :: String | r))\nscopeRow = scope_ \"row\"\n\naxis\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (axis :: String | r))\naxis = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"axis\")\n\naxis_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (axis :: String | r))\naxis_ = axis <<< Applicative.pure\n\nabbr\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (abbr :: String | r))\nabbr = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"abbr\")\n\nabbr_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (abbr :: String | r))\nabbr_ = abbr <<< Applicative.pure\n\nheaders\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (headers :: String | r))\nheaders = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"headers\")\n\nheaders_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (headers :: String | r))\nheaders_ = headers <<< Applicative.pure\n\nrowspan\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (rowspan :: String | r))\nrowspan = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"rowspan\")\n\nrowspan_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (rowspan :: String | r))\nrowspan_ = rowspan <<< Applicative.pure\n\ncolspan\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (colspan :: String | r))\ncolspan = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"colspan\")\n\ncolspan_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (colspan :: String | r))\ncolspan_ = colspan <<< Applicative.pure\n\naccept\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (accept :: String | r))\naccept = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"accept\")\n\naccept_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (accept :: String | r))\naccept_ = accept <<< Applicative.pure\n\nformnovalidate\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (formnovalidate :: String | r))\nformnovalidate = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"formnovalidate\")\n\nformnovalidate_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (formnovalidate :: String | r))\nformnovalidate_ = formnovalidate <<< Applicative.pure\n\nnovalidate\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (novalidate :: String | r))\nnovalidate = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"novalidate\")\n\nnovalidate_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (novalidate :: String | r))\nnovalidate_ = novalidate <<< Applicative.pure\n\nformtarget\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (formtarget :: String | r))\nformtarget = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"formtarget\")\n\nformtarget_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (formtarget :: String | r))\nformtarget_ = formtarget <<< Applicative.pure\n\nformenctype\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (formenctype :: String | r))\nformenctype = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"formenctype\")\n\nformenctype_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (formenctype :: String | r))\nformenctype_ = formenctype <<< Applicative.pure\n\nenctype\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (enctype :: String | r))\nenctype = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"enctype\")\n\nenctype_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (enctype :: String | r))\nenctype_ = enctype <<< Applicative.pure\n\nenctypeTextPlain\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (enctype :: String | r))\nenctypeTextPlain = enctype_ \"text/plain\"\n\nenctypeMultipartFormData\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (enctype :: String | r))\nenctypeMultipartFormData = enctype_ \"multipart/form-data\"\n\nenctypeApplicationXWwwFormUrlencoded\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (enctype :: String | r))\nenctypeApplicationXWwwFormUrlencoded = enctype_ \"application/x-www-form-urlencoded\"\n\nformmethod\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (formmethod :: String | r))\nformmethod = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"formmethod\")\n\nformmethod_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (formmethod :: String | r))\nformmethod_ = formmethod <<< Applicative.pure\n\nformmethodDialog\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (formmethod :: String | r))\nformmethodDialog = formmethod_ \"dialog\"\n\nformmethodPost\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (formmethod :: String | r))\nformmethodPost = formmethod_ \"post\"\n\nformmethodGet\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (formmethod :: String | r))\nformmethodGet = formmethod_ \"get\"\n\nmethod\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (method :: String | r))\nmethod = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"method\")\n\nmethod_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (method :: String | r))\nmethod_ = method <<< Applicative.pure\n\nmethodDialog\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (method :: String | r))\nmethodDialog = method_ \"dialog\"\n\nmethodPost\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (method :: String | r))\nmethodPost = method_ \"post\"\n\nmethodGet\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (method :: String | r))\nmethodGet = method_ \"get\"\n\nformaction\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (formaction :: String | r))\nformaction = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"formaction\")\n\nformaction_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (formaction :: String | r))\nformaction_ = formaction <<< Applicative.pure\n\naction\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (action :: String | r))\naction = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"action\")\n\naction_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (action :: String | r))\naction_ = action <<< Applicative.pure\n\nacceptCharset\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (acceptCharset :: String | r))\nacceptCharset = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"accept-charset\")\n\nacceptCharset_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (acceptCharset :: String | r))\nacceptCharset_ = acceptCharset <<< Applicative.pure\n\nfor\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (for :: String | r))\nfor = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"for\")\n\nfor_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (for :: String | r))\nfor_ = for <<< Applicative.pure\n\ncapture\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (capture :: String | r))\ncapture = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"capture\")\n\ncapture_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (capture :: String | r))\ncapture_ = capture <<< Applicative.pure\n\nminlength\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (minlength :: String | r))\nminlength = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"minlength\")\n\nminlength_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (minlength :: String | r))\nminlength_ = minlength <<< Applicative.pure\n\nmaxlength\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (maxlength :: String | r))\nmaxlength = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"maxlength\")\n\nmaxlength_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (maxlength :: String | r))\nmaxlength_ = maxlength <<< Applicative.pure\n\ndirname\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (dirname :: String | r))\ndirname = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"dirname\")\n\ndirname_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (dirname :: String | r))\ndirname_ = dirname <<< Applicative.pure\n\nplaceholder\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (placeholder :: String | r))\nplaceholder = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"placeholder\")\n\nplaceholder_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (placeholder :: String | r))\nplaceholder_ = placeholder <<< Applicative.pure\n\nlist\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (list :: String | r))\nlist = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"list\")\n\nlist_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (list :: String | r))\nlist_ = list <<< Applicative.pure\n\nstep\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (step :: String | r))\nstep = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"step\")\n\nstep_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (step :: String | r))\nstep_ = step <<< Applicative.pure\n\nmax\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (max :: String | r))\nmax = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"max\")\n\nmax_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (max :: String | r))\nmax_ = max <<< Applicative.pure\n\nmin\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (min :: String | r))\nmin = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"min\")\n\nmin_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (min :: String | r))\nmin_ = min <<< Applicative.pure\n\npattern\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (pattern :: String | r))\npattern = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"pattern\")\n\npattern_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (pattern :: String | r))\npattern_ = pattern <<< Applicative.pure\n\nmultiple\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (multiple :: String | r))\nmultiple = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"multiple\")\n\nmultiple_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (multiple :: String | r))\nmultiple_ = multiple <<< Applicative.pure\n\nrequired\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (required :: String | r))\nrequired = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"required\")\n\nrequired_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (required :: String | r))\nrequired_ = required <<< Applicative.pure\n\nreadonly\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (readonly :: String | r))\nreadonly = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"readonly\")\n\nreadonly_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (readonly :: String | r))\nreadonly_ = readonly <<< Applicative.pure\n\nsize\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (size :: String | r))\nsize = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"size\")\n\nsize_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (size :: String | r))\nsize_ = size <<< Applicative.pure\n\nchecked\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (checked :: String | r))\nchecked = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"checked\")\n\nchecked_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (checked :: String | r))\nchecked_ = checked <<< Applicative.pure\n\nselected\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (selected :: String | r))\nselected = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"selected\")\n\nselected_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (selected :: String | r))\nselected_ = selected <<< Applicative.pure\n\nwrap\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (wrap :: String | r))\nwrap = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"wrap\")\n\nwrap_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (wrap :: String | r))\nwrap_ = wrap <<< Applicative.pure\n\nwrapHard\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (wrap :: String | r))\nwrapHard = wrap_ \"hard\"\n\nwrapSoft\n  :: forall r f. Applicative.Applicative f => f (Deku.Attribute.Attribute (wrap :: String | r))\nwrapSoft = wrap_ \"soft\"\n\nrows\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (rows :: String | r))\nrows = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"rows\")\n\nrows_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (rows :: String | r))\nrows_ = rows <<< Applicative.pure\n\ncols\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (cols :: String | r))\ncols = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"cols\")\n\ncols_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (cols :: String | r))\ncols_ = cols <<< Applicative.pure\n\noptimum\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (optimum :: String | r))\noptimum = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"optimum\")\n\noptimum_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (optimum :: String | r))\noptimum_ = optimum <<< Applicative.pure\n\nhigh\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (high :: String | r))\nhigh = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"high\")\n\nhigh_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (high :: String | r))\nhigh_ = high <<< Applicative.pure\n\nlow\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (low :: String | r))\nlow = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"low\")\n\nlow_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (low :: String | r))\nlow_ = low <<< Applicative.pure\n\nopen\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (open :: String | r))\nopen = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"open\")\n\nopen_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (open :: String | r))\nopen_ = open <<< Applicative.pure\n\nevent\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (event :: String | r))\nevent = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"event\")\n\nevent_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (event :: String | r))\nevent_ = event <<< Applicative.pure\n\nlanguage\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (language :: String | r))\nlanguage = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"language\")\n\nlanguage_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (language :: String | r))\nlanguage_ = language <<< Applicative.pure\n\ndefer\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (defer :: String | r))\ndefer = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"defer\")\n\ndefer_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (defer :: String | r))\ndefer_ = defer <<< Applicative.pure\n\nasync\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (async :: String | r))\nasync = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"async\")\n\nasync_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (async :: String | r))\nasync_ = async <<< Applicative.pure\n\nnomodule\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (nomodule :: String | r))\nnomodule = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"nomodule\")\n\nnomodule_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (nomodule :: String | r))\nnomodule_ = nomodule <<< Applicative.pure\n\nshadowrootserializable\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (shadowrootserializable :: String | r))\nshadowrootserializable = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"shadowrootserializable\")\n\nshadowrootserializable_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (shadowrootserializable :: String | r))\nshadowrootserializable_ = shadowrootserializable <<< Applicative.pure\n\nshadowrootclonable\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (shadowrootclonable :: String | r))\nshadowrootclonable = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"shadowrootclonable\")\n\nshadowrootclonable_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (shadowrootclonable :: String | r))\nshadowrootclonable_ = shadowrootclonable <<< Applicative.pure\n\nshadowrootdelegatesfocus\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (shadowrootdelegatesfocus :: String | r))\nshadowrootdelegatesfocus = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"shadowrootdelegatesfocus\")\n\nshadowrootdelegatesfocus_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (shadowrootdelegatesfocus :: String | r))\nshadowrootdelegatesfocus_ = shadowrootdelegatesfocus <<< Applicative.pure\n\nshadowrootmode\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (shadowrootmode :: String | r))\nshadowrootmode = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"shadowrootmode\")\n\nshadowrootmode_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (shadowrootmode :: String | r))\nshadowrootmode_ = shadowrootmode <<< Applicative.pure\n\nshadowrootmodeClosed\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (shadowrootmode :: String | r))\nshadowrootmodeClosed = shadowrootmode_ \"closed\"\n\nshadowrootmodeOpen\n  :: forall r f\n   . Applicative.Applicative f\n  => f (Deku.Attribute.Attribute (shadowrootmode :: String | r))\nshadowrootmodeOpen = shadowrootmode_ \"open\"\n\nprofile\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (profile :: String | r))\nprofile = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"profile\")\n\nprofile_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (profile :: String | r))\nprofile_ = profile <<< Applicative.pure\n\nversion\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (version :: String | r))\nversion = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"version\")\n\nversion_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (version :: String | r))\nversion_ = version <<< Applicative.pure\n\nmanifest\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (manifest :: String | r))\nmanifest = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"manifest\")\n\nmanifest_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (manifest :: String | r))\nmanifest_ = manifest <<< Applicative.pure\n\nrules\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (rules :: String | r))\nrules = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"rules\")\n\nrules_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (rules :: String | r))\nrules_ = rules <<< Applicative.pure\n\nframe\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (frame :: String | r))\nframe = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"frame\")\n\nframe_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (frame :: String | r))\nframe_ = frame <<< Applicative.pure\n\ncellspacing\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (cellspacing :: String | r))\ncellspacing = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"cellspacing\")\n\ncellspacing_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (cellspacing :: String | r))\ncellspacing_ = cellspacing <<< Applicative.pure\n\ncellpadding\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (cellpadding :: String | r))\ncellpadding = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"cellpadding\")\n\ncellpadding_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (cellpadding :: String | r))\ncellpadding_ = cellpadding <<< Applicative.pure\n\nbordercolor\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (bordercolor :: String | r))\nbordercolor = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"bordercolor\")\n\nbordercolor_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (bordercolor :: String | r))\nbordercolor_ = bordercolor <<< Applicative.pure\n\nsummary\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (summary :: String | r))\nsummary = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"summary\")\n\nsummary_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (summary :: String | r))\nsummary_ = summary <<< Applicative.pure\n\ndatapagesize\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (datapagesize :: String | r))\ndatapagesize = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"datapagesize\")\n\ndatapagesize_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (datapagesize :: String | r))\ndatapagesize_ = datapagesize <<< Applicative.pure\n\nvlink\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (vlink :: String | r))\nvlink = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"vlink\")\n\nvlink_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (vlink :: String | r))\nvlink_ = vlink <<< Applicative.pure\n\ntopmargin\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (topmargin :: String | r))\ntopmargin = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"topmargin\")\n\ntopmargin_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (topmargin :: String | r))\ntopmargin_ = topmargin <<< Applicative.pure\n\ntext\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (text :: String | r))\ntext = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"text\")\n\ntext_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (text :: String | r))\ntext_ = text <<< Applicative.pure\n\nrightmargin\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (rightmargin :: String | r))\nrightmargin = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"rightmargin\")\n\nrightmargin_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (rightmargin :: String | r))\nrightmargin_ = rightmargin <<< Applicative.pure\n\nlink\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (link :: String | r))\nlink = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"link\")\n\nlink_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (link :: String | r))\nlink_ = link <<< Applicative.pure\n\nleftmargin\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (leftmargin :: String | r))\nleftmargin = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"leftmargin\")\n\nleftmargin_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (leftmargin :: String | r))\nleftmargin_ = leftmargin <<< Applicative.pure\n\nbottommargin\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (bottommargin :: String | r))\nbottommargin = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"bottommargin\")\n\nbottommargin_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (bottommargin :: String | r))\nbottommargin_ = bottommargin <<< Applicative.pure\n\nalink\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (alink :: String | r))\nalink = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"alink\")\n\nalink_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (alink :: String | r))\nalink_ = alink <<< Applicative.pure\n\nclear\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (clear :: String | r))\nclear = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"clear\")\n\nclear_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (clear :: String | r))\nclear_ = clear <<< Applicative.pure\n\nnoshade\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (noshade :: String | r))\nnoshade = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"noshade\")\n\nnoshade_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (noshade :: String | r))\nnoshade_ = noshade <<< Applicative.pure\n\ntruespeed\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (truespeed :: String | r))\ntruespeed = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"truespeed\")\n\ntruespeed_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (truespeed :: String | r))\ntruespeed_ = truespeed <<< Applicative.pure\n\ndirection\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (direction :: String | r))\ndirection = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"direction\")\n\ndirection_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (direction :: String | r))\ndirection_ = direction <<< Applicative.pure\n\nbehavior\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (behavior :: String | r))\nbehavior = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"behavior\")\n\nbehavior_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (behavior :: String | r))\nbehavior_ = behavior <<< Applicative.pure\n\nariaValuetext\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaValuetext :: String | r))\nariaValuetext = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-valuetext\")\n\nariaValuetext_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaValuetext :: String | r))\nariaValuetext_ = ariaValuetext <<< Applicative.pure\n\nariaValuenow\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaValuenow :: String | r))\nariaValuenow = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-valuenow\")\n\nariaValuenow_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaValuenow :: String | r))\nariaValuenow_ = ariaValuenow <<< Applicative.pure\n\nariaValuemin\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaValuemin :: String | r))\nariaValuemin = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-valuemin\")\n\nariaValuemin_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaValuemin :: String | r))\nariaValuemin_ = ariaValuemin <<< Applicative.pure\n\nariaValuemax\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaValuemax :: String | r))\nariaValuemax = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-valuemax\")\n\nariaValuemax_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaValuemax :: String | r))\nariaValuemax_ = ariaValuemax <<< Applicative.pure\n\nariaSort\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaSort :: String | r))\nariaSort = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-sort\")\n\nariaSort_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaSort :: String | r))\nariaSort_ = ariaSort <<< Applicative.pure\n\nariaSetsize\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaSetsize :: String | r))\nariaSetsize = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-setsize\")\n\nariaSetsize_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaSetsize :: String | r))\nariaSetsize_ = ariaSetsize <<< Applicative.pure\n\nariaSelected\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaSelected :: String | r))\nariaSelected = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-selected\")\n\nariaSelected_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaSelected :: String | r))\nariaSelected_ = ariaSelected <<< Applicative.pure\n\nariaRowspan\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaRowspan :: String | r))\nariaRowspan = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-rowspan\")\n\nariaRowspan_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaRowspan :: String | r))\nariaRowspan_ = ariaRowspan <<< Applicative.pure\n\nariaRowindextext\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaRowindextext :: String | r))\nariaRowindextext = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-rowindextext\")\n\nariaRowindextext_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaRowindextext :: String | r))\nariaRowindextext_ = ariaRowindextext <<< Applicative.pure\n\nariaRowindex\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaRowindex :: String | r))\nariaRowindex = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-rowindex\")\n\nariaRowindex_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaRowindex :: String | r))\nariaRowindex_ = ariaRowindex <<< Applicative.pure\n\nariaRowcount\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaRowcount :: String | r))\nariaRowcount = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-rowcount\")\n\nariaRowcount_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaRowcount :: String | r))\nariaRowcount_ = ariaRowcount <<< Applicative.pure\n\nariaRoledescription\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaRoledescription :: String | r))\nariaRoledescription = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-roledescription\")\n\nariaRoledescription_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaRoledescription :: String | r))\nariaRoledescription_ = ariaRoledescription <<< Applicative.pure\n\nariaRequired\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaRequired :: String | r))\nariaRequired = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-required\")\n\nariaRequired_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaRequired :: String | r))\nariaRequired_ = ariaRequired <<< Applicative.pure\n\nariaReadonly\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaReadonly :: String | r))\nariaReadonly = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-readonly\")\n\nariaReadonly_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaReadonly :: String | r))\nariaReadonly_ = ariaReadonly <<< Applicative.pure\n\nariaPressed\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaPressed :: String | r))\nariaPressed = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-pressed\")\n\nariaPressed_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaPressed :: String | r))\nariaPressed_ = ariaPressed <<< Applicative.pure\n\nariaPosinset\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaPosinset :: String | r))\nariaPosinset = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-posinset\")\n\nariaPosinset_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaPosinset :: String | r))\nariaPosinset_ = ariaPosinset <<< Applicative.pure\n\nariaPlaceholder\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaPlaceholder :: String | r))\nariaPlaceholder = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-placeholder\")\n\nariaPlaceholder_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaPlaceholder :: String | r))\nariaPlaceholder_ = ariaPlaceholder <<< Applicative.pure\n\nariaOwns\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaOwns :: String | r))\nariaOwns = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-owns\")\n\nariaOwns_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaOwns :: String | r))\nariaOwns_ = ariaOwns <<< Applicative.pure\n\nariaOrientation\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaOrientation :: String | r))\nariaOrientation = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-orientation\")\n\nariaOrientation_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaOrientation :: String | r))\nariaOrientation_ = ariaOrientation <<< Applicative.pure\n\nariaMultiselectable\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaMultiselectable :: String | r))\nariaMultiselectable = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-multiselectable\")\n\nariaMultiselectable_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaMultiselectable :: String | r))\nariaMultiselectable_ = ariaMultiselectable <<< Applicative.pure\n\nariaMultiline\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaMultiline :: String | r))\nariaMultiline = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-multiline\")\n\nariaMultiline_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaMultiline :: String | r))\nariaMultiline_ = ariaMultiline <<< Applicative.pure\n\nariaModal\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaModal :: String | r))\nariaModal = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-modal\")\n\nariaModal_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaModal :: String | r))\nariaModal_ = ariaModal <<< Applicative.pure\n\nariaLive\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaLive :: String | r))\nariaLive = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-live\")\n\nariaLive_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaLive :: String | r))\nariaLive_ = ariaLive <<< Applicative.pure\n\nariaLevel\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaLevel :: String | r))\nariaLevel = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-level\")\n\nariaLevel_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaLevel :: String | r))\nariaLevel_ = ariaLevel <<< Applicative.pure\n\nariaLabelledby\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaLabelledby :: String | r))\nariaLabelledby = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-labelledby\")\n\nariaLabelledby_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaLabelledby :: String | r))\nariaLabelledby_ = ariaLabelledby <<< Applicative.pure\n\nariaLabel\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaLabel :: String | r))\nariaLabel = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-label\")\n\nariaLabel_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaLabel :: String | r))\nariaLabel_ = ariaLabel <<< Applicative.pure\n\nariaKeyshortcuts\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaKeyshortcuts :: String | r))\nariaKeyshortcuts = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-keyshortcuts\")\n\nariaKeyshortcuts_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaKeyshortcuts :: String | r))\nariaKeyshortcuts_ = ariaKeyshortcuts <<< Applicative.pure\n\nariaInvalid\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaInvalid :: String | r))\nariaInvalid = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-invalid\")\n\nariaInvalid_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaInvalid :: String | r))\nariaInvalid_ = ariaInvalid <<< Applicative.pure\n\nariaHidden\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaHidden :: String | r))\nariaHidden = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-hidden\")\n\nariaHidden_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaHidden :: String | r))\nariaHidden_ = ariaHidden <<< Applicative.pure\n\nariaHaspopup\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaHaspopup :: String | r))\nariaHaspopup = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-haspopup\")\n\nariaHaspopup_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaHaspopup :: String | r))\nariaHaspopup_ = ariaHaspopup <<< Applicative.pure\n\nariaFlowto\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaFlowto :: String | r))\nariaFlowto = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-flowto\")\n\nariaFlowto_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaFlowto :: String | r))\nariaFlowto_ = ariaFlowto <<< Applicative.pure\n\nariaExpanded\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaExpanded :: String | r))\nariaExpanded = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-expanded\")\n\nariaExpanded_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaExpanded :: String | r))\nariaExpanded_ = ariaExpanded <<< Applicative.pure\n\nariaErrormessage\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaErrormessage :: String | r))\nariaErrormessage = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-errormessage\")\n\nariaErrormessage_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaErrormessage :: String | r))\nariaErrormessage_ = ariaErrormessage <<< Applicative.pure\n\nariaDisabled\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaDisabled :: String | r))\nariaDisabled = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-disabled\")\n\nariaDisabled_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaDisabled :: String | r))\nariaDisabled_ = ariaDisabled <<< Applicative.pure\n\nariaDetails\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaDetails :: String | r))\nariaDetails = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-details\")\n\nariaDetails_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaDetails :: String | r))\nariaDetails_ = ariaDetails <<< Applicative.pure\n\nariaDescription\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaDescription :: String | r))\nariaDescription = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-description\")\n\nariaDescription_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaDescription :: String | r))\nariaDescription_ = ariaDescription <<< Applicative.pure\n\nariaDescribedby\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaDescribedby :: String | r))\nariaDescribedby = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-describedby\")\n\nariaDescribedby_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaDescribedby :: String | r))\nariaDescribedby_ = ariaDescribedby <<< Applicative.pure\n\nariaCurrent\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaCurrent :: String | r))\nariaCurrent = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-current\")\n\nariaCurrent_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaCurrent :: String | r))\nariaCurrent_ = ariaCurrent <<< Applicative.pure\n\nariaControls\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaControls :: String | r))\nariaControls = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-controls\")\n\nariaControls_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaControls :: String | r))\nariaControls_ = ariaControls <<< Applicative.pure\n\nariaColspan\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaColspan :: String | r))\nariaColspan = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-colspan\")\n\nariaColspan_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaColspan :: String | r))\nariaColspan_ = ariaColspan <<< Applicative.pure\n\nariaColindextext\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaColindextext :: String | r))\nariaColindextext = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-colindextext\")\n\nariaColindextext_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaColindextext :: String | r))\nariaColindextext_ = ariaColindextext <<< Applicative.pure\n\nariaColindex\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaColindex :: String | r))\nariaColindex = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-colindex\")\n\nariaColindex_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaColindex :: String | r))\nariaColindex_ = ariaColindex <<< Applicative.pure\n\nariaColcount\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaColcount :: String | r))\nariaColcount = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-colcount\")\n\nariaColcount_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaColcount :: String | r))\nariaColcount_ = ariaColcount <<< Applicative.pure\n\nariaChecked\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaChecked :: String | r))\nariaChecked = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-checked\")\n\nariaChecked_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaChecked :: String | r))\nariaChecked_ = ariaChecked <<< Applicative.pure\n\nariaBusy\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaBusy :: String | r))\nariaBusy = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-busy\")\n\nariaBusy_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaBusy :: String | r))\nariaBusy_ = ariaBusy <<< Applicative.pure\n\nariaBrailleroledescription\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaBrailleroledescription :: String | r))\nariaBrailleroledescription = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-brailleroledescription\")\n\nariaBrailleroledescription_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaBrailleroledescription :: String | r))\nariaBrailleroledescription_ = ariaBrailleroledescription <<< Applicative.pure\n\nariaBraillelabel\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaBraillelabel :: String | r))\nariaBraillelabel = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-braillelabel\")\n\nariaBraillelabel_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaBraillelabel :: String | r))\nariaBraillelabel_ = ariaBraillelabel <<< Applicative.pure\n\nariaAutocomplete\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaAutocomplete :: String | r))\nariaAutocomplete = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-autocomplete\")\n\nariaAutocomplete_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaAutocomplete :: String | r))\nariaAutocomplete_ = ariaAutocomplete <<< Applicative.pure\n\nariaAtomic\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaAtomic :: String | r))\nariaAtomic = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-atomic\")\n\nariaAtomic_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaAtomic :: String | r))\nariaAtomic_ = ariaAtomic <<< Applicative.pure\n\nariaActivedescendant\n  :: forall r f\n   . Functor.Functor f\n  => f String\n  -> f (Deku.Attribute.Attribute (ariaActivedescendant :: String | r))\nariaActivedescendant = Functor.map\n  (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"aria-activedescendant\")\n\nariaActivedescendant_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (ariaActivedescendant :: String | r))\nariaActivedescendant_ = ariaActivedescendant <<< Applicative.pure\n\nrole\n  :: forall r f. Functor.Functor f => f String -> f (Deku.Attribute.Attribute (role :: String | r))\nrole = Functor.map (Deku.Attribute.unsafeAttribute <<< Deku.Attribute.prop' \"role\")\n\nrole_\n  :: forall r f\n   . Applicative.Applicative f\n  => String\n  -> f (Deku.Attribute.Attribute (role :: String | r))\nrole_ = role <<< Applicative.pure\n", "export const setInnerHtml = (html, element) => {\n  element.innerHTML = html;\n}", "module Data.Exists where\n\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | This type constructor can be used to existentially quantify over a type.\n-- |\n-- | Specifically, the type `Exists f` is isomorphic to the existential type `exists a. f a`.\n-- |\n-- | Existential types can be encoded using universal types (`forall`) for endofunctors in more general\n-- | categories. The benefit of this library is that, by using the FFI, we can create an efficient\n-- | representation of the existential by simply hiding type information.\n-- |\n-- | For example, consider the type `exists s. Tuple s (s -> Tuple s a)` which represents infinite streams\n-- | of elements of type `a`.\n-- |\n-- | This type can be constructed by creating a type constructor `StreamF` as follows:\n-- |\n-- | ```purescript\n-- | data StreamF a s = StreamF s (s -> Tuple s a)\n-- | ```\n-- |\n-- | We can then define the type of streams using `Exists`:\n-- |\n-- | ```purescript\n-- | type Stream a = Exists (StreamF a)\n-- | ```\nforeign import data Exists :: forall k. (k -> Type) -> Type\n\ntype role Exists representational\n\n-- | The `mkExists` function is used to introduce a value of type `Exists f`, by providing a value of\n-- | type `f a`, for some type `a` which will be hidden in the existentially-quantified type.\n-- |\n-- | For example, to create a value of type `Stream Number`, we might use `mkExists` as follows:\n-- |\n-- | ```purescript\n-- | nats :: Stream Number\n-- | nats = mkExists $ StreamF 0 (\\n -> Tuple (n + 1) n)\n-- | ```\nmkExists :: forall f a. f a -> Exists f\nmkExists = unsafeCoerce\n\n-- | The `runExists` function is used to eliminate a value of type `Exists f`. The rank 2 type ensures\n-- | that the existentially-quantified type does not escape its scope. Since the function is required\n-- | to work for _any_ type `a`, it will work for the existentially-quantified type.\n-- |\n-- | For example, we can write a function to obtain the head of a stream by using `runExists` as follows:\n-- |\n-- | ```purescript\n-- | head :: forall a. Stream a -> a\n-- | head = runExists head'\n-- |   where\n-- |   head' :: forall s. StreamF a s -> a\n-- |   head' (StreamF s f) = snd (f s)\n-- | ```\nrunExists :: forall f r. (forall a. f a -> r) -> Exists f -> r\nrunExists = unsafeCoerce\n", "const cbs = new WeakMap();\n\nexport const pushCb = ( name, cb, el ) =>\n{\n  var ns = cbs.get( el );\n  if( ns != null )\n    ns[ name ] = cb;\n  else\n    cbs.set( el, { [name] : cb } );\n};\n\nexport const popCb = ( name, el ) =>\n{\n  var ns = cbs.get( el );\n  if( ns == null )\n    return null;\n  else\n  {\n    var result = ns[ name ] ?? null;\n    ns[ name ] = undefined;\n    return result;\n  }\n};\n\nexport const createElement = (t) => document.createElement(t);\nexport const after = ( cs, t) => t.after.apply( t, cs );\nexport const prepend = ( cs, t ) => t.prepend.apply( t, cs );\n\nexport const createElementNS = (ns, t) => document.createElementNS(ns, t);\nexport const createText = ( t ) => document.createTextNode( t );\nexport const createDocumentFragment = () => document.createDocumentFragment();\n\nexport const setTextContent = (value, node) => (node.textContent = value);\n\nexport const addEventListener = (type, listener, useCapture, target) =>\n  target.addEventListener(type, listener, useCapture);\n\nexport const removeEventListener = (type, listener, useCapture, target) =>\n  target.removeEventListener(type, listener, useCapture);\n\nexport const eventListener = (fn) => fn;\n", "export function reallyUnsafeRefEq(a) {\n  return function (b) {\n    return a === b;\n  };\n}\n", "module Unsafe.Reference\n  ( unsafeRefEq\n  , reallyUnsafeRefEq\n  , UnsafeRefEq(..)\n  , UnsafeRefEqFallback(..)\n  ) where\n\nimport Prelude\n\n-- | Compares two values of the same type using strict (`===`) equality.\nunsafeRefEq :: forall a. a -> a -> Boolean\nunsafeRefEq = reallyUnsafeRefEq\n\n-- | Compares two values of different types using strict (`===`) equality.\nforeign import reallyUnsafeRefEq :: forall a b. a -> b -> Boolean\n\n-- | The `Eq` instance is defined by `unsafeRefEq`.\nnewtype UnsafeRefEq a = UnsafeRefEq a\n\ninstance eqUnsafeRefEq :: Eq (UnsafeRefEq a) where\n  eq (UnsafeRefEq l) (UnsafeRefEq r) = unsafeRefEq l r\n\n-- | The `Eq` instance first checks `unsafeRefEq`, if `false` falls back to\n-- | the underlying `Eq` instance.\nnewtype UnsafeRefEqFallback a = UnsafeRefEqFallback a\n\ninstance eqUnsafeRefEqFallback ::\n  Eq a =>\n  Eq (UnsafeRefEqFallback a) where\n  eq (UnsafeRefEqFallback l) (UnsafeRefEqFallback r) =\n    unsafeRefEq l r || l == r\n\n", "export function remove(node) {\n  return function () {\n    return node.remove();\n  };\n}\n", "var getProp = function (name) {\n  return function (doctype) {\n    return doctype[name];\n  };\n};\n\nexport const _namespaceURI = getProp(\"namespaceURI\");\nexport const _prefix = getProp(\"prefix\");\nexport const localName = getProp(\"localName\");\nexport const tagName = getProp(\"tagName\");\n\nexport function id(node) {\n  return function () {\n    return node.id;\n  };\n}\n\nexport function setId(id) {\n  return function (node) {\n    return function () {\n      node.id = id;\n    };\n  };\n}\n\nexport function className(node) {\n  return function () {\n    return node.className;\n  };\n}\n\nexport function classList(element) {\n  return function () {\n    return element.classList;\n  };\n}\n\nexport function setClassName(className) {\n  return function (node) {\n    return function () {\n      node.className = className;\n    };\n  };\n}\n\nexport function getElementsByTagName(localName) {\n  return function (doc) {\n    return function () {\n      return doc.getElementsByTagName(localName);\n    };\n  };\n}\n\nexport function _getElementsByTagNameNS(ns) {\n  return function (localName) {\n    return function (doc) {\n      return function () {\n        return doc.getElementsByTagNameNS(ns, localName);\n      };\n    };\n  };\n}\n\nexport function getElementsByClassName(classNames) {\n  return function (doc) {\n    return function () {\n      return doc.getElementsByClassName(classNames);\n    };\n  };\n}\n\nexport function setAttribute(name) {\n  return function (value) {\n    return function (element) {\n      return function () {\n        element.setAttribute(name, value);\n      };\n    };\n  };\n}\n\nexport function _getAttribute(name) {\n  return function (element) {\n    return function () {\n      return element.getAttribute(name);\n    };\n  };\n}\n\nexport function hasAttribute(name) {\n  return function (element) {\n    return function () {\n      return element.hasAttribute(name);\n    };\n  };\n}\n\nexport function removeAttribute(name) {\n  return function (element) {\n    return function () {\n      element.removeAttribute(name);\n    };\n  };\n}\n\nexport function matches(selector) {\n  return function(element) {\n    return function () {\n      return element.matches(selector);\n    };\n  };\n}\n\nexport function _closest(selector) {\n  return function(element) {\n    return function () {\n      return element.closest(selector);\n    };\n  };\n}\n\n// - CSSOM ---------------------------------------------------------------------\n\nexport function scrollTop(node) {\n  return function () {\n    return node.scrollTop;\n  };\n}\n\nexport function setScrollTop(scrollTop) {\n  return function (node) {\n    return function () {\n      node.scrollTop = scrollTop;\n    };\n  };\n}\n\nexport function scrollLeft(node) {\n  return function () {\n    return node.scrollLeft;\n  };\n}\n\nexport function setScrollLeft(scrollLeft) {\n  return function (node) {\n    return function () {\n      node.scrollLeft = scrollLeft;\n    };\n  };\n}\n\nexport function scrollWidth(el) {\n  return function () {\n    return el.scrollWidth;\n  };\n}\n\nexport function scrollHeight(el) {\n  return function () {\n    return el.scrollHeight;\n  };\n}\n\nexport function clientTop(el) {\n  return function () {\n    return el.clientTop;\n  };\n}\n\nexport function clientLeft(el) {\n  return function () {\n    return el.clientLeft;\n  };\n}\n\nexport function clientWidth(el) {\n  return function () {\n    return el.clientWidth;\n  };\n}\n\nexport function clientHeight(el) {\n  return function () {\n    return el.clientHeight;\n  };\n}\n\nexport function getBoundingClientRect(el) {\n  return function () {\n    var rect = el.getBoundingClientRect();\n    return {\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      width: rect.width,\n      height: rect.height,\n      x: rect.x,\n      y: rect.y\n    };\n  };\n}\n\nexport function _attachShadow(props) {\n  return function (el) {\n    return function() {\n      return el.attachShadow(props);\n    };\n  };\n}\n", "var getEffProp = function (name) {\n  return function (node) {\n    return function () {\n      return node[name];\n    };\n  };\n};\n\nexport const children = getEffProp(\"children\");\nexport const _firstElementChild = getEffProp(\"firstElementChild\");\nexport const _lastElementChild = getEffProp(\"lastElementChild\");\nexport const childElementCount = getEffProp(\"childElementCount\");\n\nexport function _querySelector(selector) {\n  return function (node) {\n    return function () {\n      return node.querySelector(selector);\n    };\n  };\n}\n\nexport function querySelectorAll(selector) {\n  return function (node) {\n    return function () {\n      return node.querySelectorAll(selector);\n    };\n  };\n}\n", "var getEffProp = function (name) {\n  return function (node) {\n    return function () {\n      return node[name];\n    };\n  };\n};\n\nexport function nodeTypeIndex(node) {\n  return node.nodeType;\n}\n\nexport function nodeName(node) {\n  return node.nodeName;\n}\n\nexport const baseURI = getEffProp(\"baseURI\");\nexport const _ownerDocument = getEffProp(\"ownerDocument\");\nexport const _parentNode = getEffProp(\"parentNode\");\nexport const _parentElement = getEffProp(\"parentElement\");\n\nexport function hasChildNodes(node) {\n  return function () {\n    return node.hasChildNodes();\n  };\n}\n\nexport const childNodes = getEffProp(\"childNodes\");\nexport const _firstChild = getEffProp(\"firstChild\");\nexport const _lastChild = getEffProp(\"lastChild\");\nexport const _previousSibling = getEffProp(\"previousSibling\");\nexport const _nextSibling = getEffProp(\"nextSibling\");\nexport const _nodeValue = getEffProp(\"nodeValue\");\n\nexport function setNodeValue(value) {\n  return function (node) {\n    return function () {\n      node.nodeValue = value;\n    };\n  };\n}\n\nexport const textContent = getEffProp(\"textContent\");\n\nexport function setTextContent(value) {\n  return function (node) {\n    return function () {\n      node.textContent = value;\n    };\n  };\n}\n\nexport function normalize(node) {\n  return function () {\n    node.normalize();\n  };\n}\n\nexport function clone(node) {\n  return function () {\n    return node.cloneNode(false);\n  };\n}\n\nexport function deepClone(node) {\n  return function () {\n    return node.cloneNode(true);\n  };\n}\n\nexport function isEqualNode(node1) {\n  return function (node2) {\n    return function () {\n      return node1.isEqualNode(node2);\n    };\n  };\n}\n\nexport function compareDocumentPositionBits(node1) {\n  return function (node2) {\n    return function () {\n      return node1.compareDocumentPosition(node2);\n    };\n  };\n}\n\nexport function contains(node1) {\n  return function (node2) {\n    return function () {\n      return node1.contains(node2);\n    };\n  };\n}\n\nexport function _lookupPrefix(prefix) {\n  return function (node) {\n    return function () {\n      return node.lookupPrefix(prefix);\n    };\n  };\n}\n\nexport function _lookupNamespaceURI(ns) {\n  return function (node) {\n    return function () {\n      return node.lookupNamespaceURI(ns);\n    };\n  };\n}\n\nexport function isDefaultNamespace(ns) {\n  return function (node) {\n    return function () {\n      return node.isDefaultNamespace(ns);\n    };\n  };\n}\n\nexport function insertBefore(node1) {\n  return function (node2) {\n    return function (parent) {\n      return function () {\n        parent.insertBefore(node1, node2);\n      };\n    };\n  };\n}\n\nexport function appendChild(node) {\n  return function (parent) {\n    return function () {\n      parent.appendChild(node);\n    };\n  };\n}\n\nexport function replaceChild(newChild) {\n  return function (oldChild) {\n    return function (parent) {\n      return function () {\n        parent.replaceChild(newChild, oldChild);\n      };\n    };\n  };\n}\n\nexport function removeChild(node) {\n  return function (parent) {\n    return function () {\n      parent.removeChild(node);\n    };\n  };\n}\n", "module Web.DOM.Node\n  ( module Exports\n  , fromEventTarget\n  , toEventTarget\n  , nodeType\n  , nodeTypeIndex\n  , nodeName\n  , baseURI\n  , ownerDocument\n  , parentNode\n  , parentElement\n  , hasChildNodes\n  , childNodes\n  , firstChild\n  , lastChild\n  , previousSibling\n  , nextSibling\n  , nodeValue\n  , setNodeValue\n  , textContent\n  , setTextContent\n  , normalize\n  , clone\n  , deepClone\n  , isEqualNode\n  , compareDocumentPositionBits\n  , contains\n  , lookupPrefix\n  , lookupNamespaceURI\n  , isDefaultNamespace\n  , insertBefore\n  , appendChild\n  , replaceChild\n  , removeChild\n  ) where\n\nimport Prelude\n\nimport Data.Enum (toEnum)\nimport Data.Maybe (Maybe, fromJust)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Document (Document)\nimport Web.DOM.Element (Element)\nimport Web.DOM.Internal.Types (Node) as Exports\nimport Web.DOM.Internal.Types (Node, NodeList)\nimport Web.DOM.NodeType (NodeType)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nfromEventTarget :: EventTarget -> Maybe Node\nfromEventTarget = unsafeReadProtoTagged \"Node\"\n\ntoEventTarget :: Node -> EventTarget\ntoEventTarget = unsafeCoerce\n\n-- | The type of a node.\nnodeType :: Partial => Node -> NodeType\nnodeType = fromJust <<< toEnum <<< nodeTypeIndex\n\n-- | The numeric value for the type of a node.\nforeign import nodeTypeIndex :: Node -> Int\n\n-- | For elements this is the tag name, for document types this is the doctype\n-- | name, for processing instructions this is the target, for all other nodes\n-- | it is a string like `\"#text\"`, `\"#comment\", etc. depending on the node\n-- | type.\nforeign import nodeName :: Node -> String\n\n-- | The node's base URL.\nforeign import baseURI :: Node -> Effect String\n\n-- | The document the node belongs to, unless the node is a document in which\n-- | case the value is Nothing.\nownerDocument :: Node -> Effect (Maybe Document)\nownerDocument = map toMaybe <<< _ownerDocument\n\nforeign import _ownerDocument :: Node -> Effect (Nullable Document)\n\n-- | The parent node of the node.\nparentNode :: Node -> Effect (Maybe Node)\nparentNode = map toMaybe <<< _parentNode\n\nforeign import _parentNode :: Node -> Effect (Nullable Node)\n\n-- | The parent element of the node.\nparentElement :: Node -> Effect (Maybe Element)\nparentElement = map toMaybe <<< _parentElement\n\nforeign import _parentElement :: Node -> Effect (Nullable Element)\n\n-- | Indicates whether the node has any child nodes.\nforeign import hasChildNodes :: Node -> Effect Boolean\n\n-- | The children of the node.\nforeign import childNodes :: Node -> Effect NodeList\n\n-- | The first child of the node, or Nothing if the node has no children.\nfirstChild :: Node -> Effect (Maybe Node)\nfirstChild = map toMaybe <<< _firstChild\n\nforeign import _firstChild :: Node -> Effect (Nullable Node)\n\n\n-- | The last child of the node, or Nothing if the node has no children.\nlastChild :: Node -> Effect (Maybe Node)\nlastChild = map toMaybe <<< _lastChild\n\nforeign import _lastChild :: Node -> Effect (Nullable Node)\n\n-- | The previous sibling node, or Nothing if there is no previous sibling.\npreviousSibling :: Node -> Effect (Maybe Node)\npreviousSibling = map toMaybe <<< _previousSibling\n\nforeign import _previousSibling :: Node -> Effect (Nullable Node)\n\n-- | The next sibling node, or Nothing if there is no next sibling.\nnextSibling :: Node -> Effect (Maybe Node)\nnextSibling = map toMaybe <<< _nextSibling\n\nforeign import _nextSibling :: Node -> Effect (Nullable Node)\n\n-- | If the node type is text, comment, or processing instruction this is\n-- | `Just` the node's data, or `Nothing` in all other cases.\nnodeValue :: Node -> Effect (Maybe String)\nnodeValue = map toMaybe <<< _nodeValue\n\nforeign import _nodeValue :: Node -> Effect (Nullable String)\n\n-- | If the node type is text, comment, or processing instruction this allows\n-- | the node's data to be changed, or has no effect in all other cases.\nforeign import setNodeValue :: String -> Node -> Effect Unit\n\n-- | If the node type is document fragment, element, text, processing\n-- | instruction, or comment this is the node's data, or null in all other\n-- | cases.\nforeign import textContent :: Node -> Effect String\n\n-- | If the node type is document fragment, element, text, processing\n-- | instruction, or comment this allows the node's data to be changed, or has\n-- | no effect in all other cases.\nforeign import setTextContent :: String -> Node -> Effect Unit\n\n-- | Removes empty text nodes and then combines any remaining text nodes that\n-- | are contiguous.\nforeign import normalize :: Node -> Effect Unit\n\n-- | Clones the node without cloning the node's descendants.\nforeign import clone :: Node -> Effect Node\n\n-- | Clones the node and its descendants.\nforeign import deepClone :: Node -> Effect Node\n\n-- | Checks whether two nodes are equivalent.\nforeign import isEqualNode :: Node -> Node -> Effect Boolean\n\n-- TODO: compareDocumentPosition that returns a semigroup or something instead of the bitmask value\n\n-- | Compares the position of two nodes in the document.\nforeign import compareDocumentPositionBits :: Node -> Node -> Effect Int\n\n-- | Checks whether the second node is contained within the first\nforeign import contains :: Node -> Node -> Effect Boolean\n\nlookupPrefix :: String -> Node -> Effect (Maybe String)\nlookupPrefix p = map toMaybe <<< _lookupPrefix p\n\nforeign import _lookupPrefix :: String -> Node -> Effect (Nullable String)\n\nlookupNamespaceURI :: String -> Node -> Effect (Maybe String)\nlookupNamespaceURI ns = map toMaybe <<< _lookupNamespaceURI ns\n\nforeign import _lookupNamespaceURI :: String -> Node -> Effect (Nullable String)\n\nforeign import isDefaultNamespace :: String -> Node -> Effect Boolean\n\n-- | Inserts the first node before the second as a child of the third node.\nforeign import insertBefore :: Node -> Node -> Node -> Effect Unit\n\n-- | Appends the first node to the child node list of the second node.\nforeign import appendChild :: Node -> Node -> Effect Unit\n\n-- | Uses the first node as a replacement for the second node in the children\n-- | of the third node.\nforeign import replaceChild :: Node -> Node -> Node -> Effect Unit\n\n-- | Removes the first node from the children of the second node.\nforeign import removeChild :: Node -> Node -> Effect Unit\n", "module Web.DOM.Text where\n\nimport Data.Maybe (Maybe)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.CharacterData (CharacterData)\nimport Web.DOM.ChildNode (ChildNode)\nimport Web.DOM.Internal.Types (Node)\nimport Web.DOM.NonDocumentTypeChildNode (NonDocumentTypeChildNode)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nforeign import data Text :: Type\n\nfromCharacterData :: CharacterData -> Maybe Text\nfromCharacterData = unsafeReadProtoTagged \"Text\"\n\nfromNode :: Node -> Maybe Text\nfromNode = unsafeReadProtoTagged \"Text\"\n\nfromChildNode :: ChildNode -> Maybe Text\nfromChildNode = unsafeReadProtoTagged \"Text\"\n\nfromNonDocumentTypeChildNode :: NonDocumentTypeChildNode -> Maybe Text\nfromNonDocumentTypeChildNode = unsafeReadProtoTagged \"Text\"\n\nfromEventTarget :: EventTarget -> Maybe Text\nfromEventTarget = unsafeReadProtoTagged \"Text\"\n\ntoNode :: Text -> Node\ntoNode = unsafeCoerce\n\ntoCharacterData :: Text -> CharacterData\ntoCharacterData = unsafeCoerce\n\ntoChildNode :: Text -> ChildNode\ntoChildNode = unsafeCoerce\n\ntoNonDocumentTypeChildNode :: Text -> NonDocumentTypeChildNode\ntoNonDocumentTypeChildNode = unsafeCoerce\n\ntoEventTarget :: Text -> EventTarget\ntoEventTarget = unsafeCoerce\n\nforeign import splitText :: Int -> Text -> Effect Text\n\nforeign import wholeText :: Text -> Effect String\n", "module Deku.Interpret where\n\nimport Prelude\n\nimport Control.Monad.ST.Class (liftST)\nimport Data.Array.ST as STArray\nimport Data.Exists (Exists, mkExists, runExists)\nimport Data.Foldable (for_, traverse_)\nimport Data.List (List(..), (:))\nimport Data.Maybe (Maybe(..), fromJust, fromMaybe, isJust)\nimport Data.Nullable (toMaybe)\nimport Data.Tuple (Tuple(..))\nimport Deku.Core (SetInnerHtml)\nimport Deku.Core as Core\nimport Deku.Internal.Entities (DekuChild(..), DekuElement, DekuParent(..), fromDekuElement, fromDekuText, toDekuElement, toDekuText)\nimport Deku.Internal.Region (Anchor(..))\nimport Deku.UnsafeDOM (addEventListener, after, createDocumentFragment, createElement, createElementNS, createText, eventListener, popCb, prepend, pushCb, removeEventListener, setTextContent)\nimport Effect (Effect, whileE)\nimport Effect.Exception (error, throwException)\nimport Effect.Ref as Ref\nimport Effect.Uncurried (EffectFn2, EffectFn3, mkEffectFn1, mkEffectFn2, mkEffectFn3, runEffectFn1, runEffectFn2, runEffectFn3, runEffectFn4)\nimport Partial.Unsafe (unsafePartial)\nimport Safe.Coerce (coerce)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Unsafe.Reference (unsafeRefEq)\nimport Web.DOM (ChildNode, Element, Node)\nimport Web.DOM.ChildNode (remove)\nimport Web.DOM.Element (removeAttribute, setAttribute)\nimport Web.DOM.Node (firstChild, nextSibling)\nimport Web.DOM.Text as Text\nimport Web.Event.Event (EventType(..))\nimport Web.Event.Event as Web\nimport Web.Event.Internal.Types (EventTarget)\nimport Web.HTML.HTMLButtonElement as HTMLButtonElement\nimport Web.HTML.HTMLFieldSetElement as HTMLFieldSetElement\nimport Web.HTML.HTMLInputElement as HTMLInputElement\nimport Web.HTML.HTMLKeygenElement as HTMLKeygenElement\nimport Web.HTML.HTMLLinkElement as HTMLLinkElement\nimport Web.HTML.HTMLOptGroupElement as HTMLOptGroupElement\nimport Web.HTML.HTMLOptionElement as HTMLOptionElement\nimport Web.HTML.HTMLSelectElement as HTMLSelectElement\nimport Web.HTML.HTMLTextAreaElement as HTMLTextAreaElement\n\nmakeElementEffect :: Core.MakeElement\nmakeElementEffect = mkEffectFn3 \\_ ns tag -> do\n  elt <- case coerce ns :: Maybe String of\n    Nothing -> runEffectFn1 createElement (coerce tag)\n    Just ns' -> runEffectFn2 createElementNS (coerce ns') (coerce tag)\n  pure $ toDekuElement elt\n\nattachElementEffect :: Core.AttachElement\nattachElementEffect =\n  mkEffectFn2 \\(DekuChild el) -> runEffectFn2 attachNodeEffect\n    [ fromDekuElement @Node el ]\n\nsetPropEffect :: Core.SetProp\nsetPropEffect = mkEffectFn3 \\(Core.Key k) (Core.Value v) elt' -> do\n  let elt = fromDekuElement elt'\n  let\n    o\n      | k == \"value\"\n      , Just ie <- HTMLInputElement.fromElement elt = HTMLInputElement.setValue\n          v\n          ie\n      | k == \"value\"\n      , Just tx <- HTMLTextAreaElement.fromElement elt =\n          HTMLTextAreaElement.setValue v tx\n      | k == \"checked\"\n      , Just ie <- HTMLInputElement.fromElement elt =\n          HTMLInputElement.setChecked (v == \"true\") ie\n      | k == \"disabled\"\n      , Just fe <-\n          getDisableable elt disableables = runExists\n          (\\(FeO { f, e }) -> f (v == \"true\") e)\n          fe\n      | otherwise = setAttribute k v elt\n  o\n\nsetCbEffect :: Core.SetCb\nsetCbEffect = mkEffectFn3 \\(Core.Key k) (Core.Cb v) elt' -> do\n  if k == \"@self@\" then do\n    void $ v ((unsafeCoerce :: DekuElement -> Web.Event) elt')\n  else do\n    let asElt = fromDekuElement @Element elt'\n    l <- runEffectFn2 popCb k asElt\n    let eventType = EventType k\n    let eventTarget = fromDekuElement @EventTarget elt'\n    for_ (toMaybe l) \\toRemove -> runEffectFn4 removeEventListener eventType\n      toRemove\n      false\n      eventTarget\n    nl <- runEffectFn1 eventListener $ mkEffectFn1 v\n    runEffectFn4 addEventListener eventType nl false eventTarget\n    runEffectFn3 pushCb k nl asElt\n\nunsetAttributeEffect :: Core.UnsetAttribute\nunsetAttributeEffect = mkEffectFn2 \\(Core.Key k) elt' -> do\n  let asElt = fromDekuElement @Element elt'\n  l <- runEffectFn2 popCb k asElt\n  let asEventTarget = fromDekuElement @EventTarget elt'\n  let eventType = EventType k\n  for_ (toMaybe l) \\toRemove -> do\n    runEffectFn4 removeEventListener eventType toRemove false asEventTarget\n  removeAttribute k asElt\n\nremoveElementEffect :: Core.RemoveElement\nremoveElementEffect = mkEffectFn1 \\e -> do\n  remove (fromDekuElement @ChildNode e)\n\nnewtype FeI e = FeI\n  { f :: Boolean -> e -> Effect Unit, e :: Element -> Maybe e }\n\nnewtype FeO e = FeO { f :: Boolean -> e -> Effect Unit, e :: e }\n\ndisableables \u2237 List (Exists FeI)\ndisableables =\n  mkExists\n    ( FeI\n        { e: HTMLButtonElement.fromElement\n        , f: HTMLButtonElement.setDisabled\n        }\n    )\n    : mkExists\n        ( FeI\n            { e: HTMLInputElement.fromElement\n            , f: HTMLInputElement.setDisabled\n            }\n        )\n    : mkExists\n        ( FeI\n            { e: HTMLFieldSetElement.fromElement\n            , f: HTMLFieldSetElement.setDisabled\n            }\n        )\n    : mkExists\n        ( FeI\n            { e: HTMLKeygenElement.fromElement\n            , f: HTMLKeygenElement.setDisabled\n            }\n        )\n    : mkExists\n        ( FeI\n            { e: HTMLLinkElement.fromElement\n            , f: HTMLLinkElement.setDisabled\n            }\n        )\n    : mkExists\n        ( FeI\n            { e: HTMLOptGroupElement.fromElement\n            , f: HTMLOptGroupElement.setDisabled\n            }\n        )\n    : mkExists\n        ( FeI\n            { e: HTMLOptionElement.fromElement\n            , f: HTMLOptionElement.setDisabled\n            }\n        )\n    : mkExists\n        ( FeI\n            { e: HTMLSelectElement.fromElement\n            , f: HTMLSelectElement.setDisabled\n            }\n        )\n    : mkExists\n        ( FeI\n            { e: HTMLTextAreaElement.fromElement\n            , f: HTMLTextAreaElement.setDisabled\n            }\n        )\n    : Nil\n\ngetDisableable :: Element -> List (Exists FeI) -> Maybe (Exists FeO)\ngetDisableable elt = go\n\n  where\n\n  go Nil = Nothing\n  go (x : _)\n    | Just o <-\n        runExists\n          (\\(FeI { f, e }) -> e elt <#> \\e' -> mkExists (FeO { f, e: e' }))\n          x = Just o\n  go (_ : y) = go y\n\nmakeTextEffect :: Core.MakeText\nmakeTextEffect = mkEffectFn2 \\_ mstr -> do\n  txt <- runEffectFn1 createText (fromMaybe \"\" mstr)\n  pure $ toDekuText txt\n\nattachTextEffect :: Core.AttachText\nattachTextEffect =\n  mkEffectFn2 \\txt -> do\n    runEffectFn2 attachNodeEffect [ fromDekuText @Node txt ]\n\nsetTextEffect :: Core.SetText\nsetTextEffect = mkEffectFn2 \\str txt' -> do\n  let txt = fromDekuText @Node txt'\n  runEffectFn2 setTextContent str txt\n\nremoveTextEffect :: Core.RemoveText\nremoveTextEffect = mkEffectFn1 \\t -> do\n  remove (Text.toChildNode (fromDekuText t))\n\nbufferPortal :: Core.BufferPortal\nbufferPortal = do\n  frag <- createDocumentFragment\n  pure $ Tuple 0 $ DekuParent $ toDekuElement frag\n\n-- | Uses [after](https://developer.mozilla.org/en-US/docs/Web/API/Element/after) and\n-- | [prepend](https://developer.mozilla.org/en-US/docs/Web/API/Element/prepend) to efficiently move the collected\n-- | nodes. To collect the `Node`s we simply iterate from the beginning(via\n-- | [firstChild](https://developer.mozilla.org/en-US/docs/Web/API/Node/firstChild) or\n-- | [nextSibling](https://developer.mozilla.org/en-US/docs/Web/API/Node/nextSibling)) until we find the end `Node` via\n-- | referential equality.\nbeamRegionEffect :: Core.BeamRegion\nbeamRegionEffect = mkEffectFn3 case _, _, _ of\n  _, ParentStart _, _ ->\n    pure unit\n\n  ParentStart (DekuParent parent), end, target -> do\n    firstChild (fromDekuElement @Node parent) >>= traverse_ \\first ->\n      runEffectFn3 beamNodes first (toNode end) target\n\n  fromBegin, fromEnd, target -> do\n    let\n      beginNode = toNode fromBegin\n      endNode = toNode fromEnd\n\n    -- if beginning equals the end, `nextSibling` would overshoot, so just check now and abort\n    if unsafeRefEq beginNode endNode then\n      pure unit\n    else\n      nextSibling beginNode >>= traverse_ \\first ->\n        runEffectFn3 beamNodes first endNode target\n\n  where\n\n  beamNodes :: EffectFn3 Node Node Anchor Unit\n  beamNodes = mkEffectFn3 \\first end target -> do\n    acc <- liftST $ STArray.new\n    next <- Ref.new $ Just first\n\n    whileE (isJust <$> Ref.read next) do\n      current <- unsafePartial $ fromJust <$> Ref.read next\n      void $ liftST $ STArray.push current acc\n\n      if unsafeRefEq current end then\n        void $ Ref.write Nothing next\n      else do\n        nextCandidate <- nextSibling current\n        void $ Ref.write nextCandidate next\n\n    nodes <- liftST $ STArray.unsafeFreeze acc\n    runEffectFn2 attachNodeEffect nodes target\n\n  toNode :: Anchor -> Node\n  toNode a = unsafePartial case a of\n    Element el -> fromDekuElement @Node el\n    Text txt -> fromDekuText @Node txt\n\nattachNodeEffect :: EffectFn2 (Array Node) Anchor Unit\nattachNodeEffect = mkEffectFn2 \\nodes anchor -> do\n  case anchor of\n    ParentStart (DekuParent parent) -> do\n      runEffectFn2 prepend nodes (fromDekuElement @Node parent)\n\n    Element el -> do\n      runEffectFn2 after nodes (fromDekuElement @Node el)\n\n    Text txt -> do\n      runEffectFn2 after nodes (fromDekuText @Node txt)\n\nforeign import setInnerHtml :: EffectFn2 String DekuElement Unit\n\nsetInnerHtmlEffect :: SetInnerHtml\nsetInnerHtmlEffect = mkEffectFn2 \\html anchor -> do\n  case anchor of\n    ParentStart (DekuParent parent) -> do\n      runEffectFn2 setInnerHtml html parent\n\n    Element _ -> do\n      throwException $ error \"setInnerHtmlEffect: Cannot set innerHTML on an Element\"\n\n    Text _ -> do\n      throwException $ error \"setInnerHtmlEffect: Cannot set innerHTML on an Element\"\n", "module Deku.FullDOMInterpret where\n\nimport Prelude\n\nimport Control.Monad.ST.Uncurried (mkSTFn1, mkSTFn2)\nimport Deku.Core as Core\nimport Deku.Interpret as I\n\nfullDOMInterpret :: Core.DOMInterpret\nfullDOMInterpret = Core.DOMInterpret\n  { dynamicDOMInterpret: \\_ -> fullDOMInterpret\n  , portalDOMInterpret: \\_ -> fullDOMInterpret\n  --\n  , isBoring: const false\n  , makeElement: I.makeElementEffect\n  , attachElement: I.attachElementEffect\n  , initializeElementRendering: mkSTFn2 \\_ _ -> pure unit\n  , initializeTextRendering: mkSTFn2 \\_ _ -> pure unit\n  , markElementAsImpure: mkSTFn1 \\_ -> pure unit\n  , setProp: I.setPropEffect\n  , setCb: I.setCbEffect\n  , unsetAttribute: I.unsetAttributeEffect\n  , removeElement: I.removeElementEffect\n  --\n  , makeText: I.makeTextEffect\n  , attachText: I.attachTextEffect\n  , setText: I.setTextEffect\n  , removeText: I.removeTextEffect\n  , markTextAsImpure: mkSTFn1 \\_ -> pure unit\n  --\n  , beamRegion: I.beamRegionEffect\n  , initializePortalRendering: mkSTFn1 \\_ -> pure unit\n  , markPortalAsRendered: mkSTFn1 \\_ -> pure unit\n  , bufferPortal: I.bufferPortal\n  --\n  , initializeDynRendering: mkSTFn1 \\_ -> pure unit\n  , initializeFixedRendering: mkSTFn1 \\_ -> pure unit\n  , setInnerHTML: I.setInnerHtmlEffect\n  }", "-- | These functions are used to run a Deku application.\nmodule Deku.Toplevel\n  ( runInElement\n  , runInBody\n  , ssrInElement\n  , ssrInBody\n  , hydrateInElement\n  , hydrateInBody\n  , SSROutput\n  ) where\n\nimport Prelude\n\nimport Control.Monad.ST.Class (liftST)\nimport Control.Monad.ST.Internal as ST\nimport Control.Monad.ST.Uncurried (runSTFn1, runSTFn3)\nimport Control.Monad.Writer (lift, runWriterT, tell)\nimport Data.Array as Array\nimport Data.Bifunctor (lmap)\nimport Data.Filterable (filterMap)\nimport Data.FoldableWithIndex (forWithIndex_)\nimport Data.Map as Map\nimport Data.Map.Internal (Map(..))\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Newtype (un)\nimport Data.Set as Set\nimport Data.String as String\nimport Data.Traversable (foldl, for_, sequence, traverse)\nimport Data.Tuple (Tuple(..), swap)\nimport Data.Tuple.Nested ((/\\))\nimport Deku.Core (Nut(..), newPSR)\nimport Deku.FullDOMInterpret (fullDOMInterpret)\nimport Deku.HydratingDOMInterpret (hydratingDOMInterpret)\nimport Deku.Internal.Ancestry (Ancestry, DekuAncestry(..), reconstructAncestry, unsafeCollectLineage)\nimport Deku.Internal.Ancestry as Ancestry\nimport Deku.Internal.Entities (DekuParent(..), fromDekuElement, fromDekuText, toDekuElement)\nimport Deku.Internal.Region as Region\nimport Deku.SSR.Optimize (hasPlainAncestry, truncateLineageBy1)\nimport Deku.SSRDOMInterpret (SSRElementRenderingInfo(..), SSRTextRenderingInfo(..), ssrDOMInterpret)\nimport Effect (Effect)\nimport Effect.Exception (error, throwException)\nimport Effect.Uncurried (runEffectFn2)\nimport FRP.Poll (create)\nimport Web.DOM as Web.DOM\nimport Web.DOM.Element (getAttribute, removeAttribute, setAttribute, toParentNode)\nimport Web.DOM.Element as Element\nimport Web.DOM.Node (nextSibling, parentNode, previousSibling, removeChild)\nimport Web.DOM.NodeList (toArray)\nimport Web.DOM.ParentNode (QuerySelector(..), querySelectorAll)\nimport Web.DOM.Text as Text\nimport Web.HTML (window)\nimport Web.HTML.HTMLDocument (body)\nimport Web.HTML.HTMLElement (toElement)\nimport Web.HTML.Window (document)\n\n-- | Runs a deku application in a DOM element, returning a canceler that can\n-- | be used to cancel the application.\nrunInElement\n  :: Web.DOM.Element\n  -> Nut\n  -> Effect (Effect Unit)\nrunInElement elt (Nut nut) = do\n  { poll: lifecycle, push: dispose } <- liftST create\n  region <- liftST $ runSTFn1 Region.fromParent (DekuParent $ toDekuElement elt)\n  scope <- liftST $ runSTFn3 newPSR Ancestry.root lifecycle region\n  void $ runEffectFn2 nut scope fullDOMInterpret\n  pure $ dispose unit\n\ndoInBody :: forall i o. (Web.DOM.Element -> i -> Effect o) -> i -> Effect o\ndoInBody f elt = do\n  b' <- window >>= document >>= body\n  maybe (throwException (error \"Could not find element\"))\n    (flip f elt)\n    (toElement <$> b')\n\n-- | Runs a deku application in the body of a document, returning a canceler that can\n-- | be used to cancel the application.\nrunInBody\n  :: Nut\n  -> Effect (Effect Unit)\nrunInBody = doInBody runInElement\n\nforeign import innerHTML :: Web.DOM.Element -> Effect String\n\nforeign import transformTextNode :: String -> Web.DOM.Text -> Effect Unit\n\nforeign import mapIdsToTextNodes\n  :: Web.DOM.Element -> Effect (Array { k :: String, v :: Web.DOM.Text })\n\ntype SSROutput =\n  { html :: String\n  , livePortals :: Array Ancestry\n  , boring :: Array Ancestry\n  }\n\n-- we run this over all of the entries that are _not_ super safe\n-- in order to be super-duper safe, something can't be an ancestor of\n-- something that's unsafe, even if _it_ is safe\n-- for example, there could be a D.div that is completely safe but\n-- deep down in the tree in contains a dyn\n-- this will mark it as unsafe\nancestryNotPresentIn :: DekuAncestry -> Set.Set DekuAncestry -> Boolean\nancestryNotPresentIn needle haystack = any (Set.toMap haystack)\n  where\n  ff (Element i a) (Element j b)\n    | i == j = ff a b\n    | otherwise = false\n  ff (Fixed i a) (Fixed j b)\n    | i == j = ff a b\n    | otherwise = false\n  ff (Portal i a) (Portal j b)\n    | i == j = ff a b\n    | otherwise = false\n  ff (Dyn i a) (Dyn j b)\n    | i == j = ff a b\n    | otherwise = false\n  ff Root Root = true\n  ff _ _ = false\n  -- f returns true if the ancestry is present and false otherwise\n  f a@(Element _ r) = ff needle a || f r\n  f a@(Fixed _ r) = ff needle a || f r\n  f a@(Dyn _ r) = ff needle a || f r\n  f a@(Portal _ r) = ff needle a || f r\n  f Root = ff needle Root\n  any = case _ of\n    Leaf -> true\n    -- f guarantees that the ancestry is not present\n    -- so if it is false, it terminates early\n    Node _ _ mk _ ml mr -> not f mk && any ml && any mr\n\nssrInElement\n  :: Web.DOM.Element\n  -> Nut\n  -> Effect SSROutput\nssrInElement elt (Nut nut) = do\n  { poll: lifecycle, push: dispose } <- liftST create\n  textCacheRef <- liftST $ ST.new Map.empty\n  elementCacheRef <- liftST $ ST.new Map.empty\n  purePortalsRef <- liftST $ ST.new Set.empty\n  portalCacheRef <- liftST $ ST.new Set.empty\n  dynCacheRef <- liftST $ ST.new Set.empty\n  fixedCacheRef <- liftST $ ST.new Set.empty\n  portalCtrRef <- liftST $ ST.new (-1)\n  let\n    di = ssrDOMInterpret portalCtrRef textCacheRef elementCacheRef\n      purePortalsRef\n      portalCacheRef\n      dynCacheRef\n      fixedCacheRef\n  region <- liftST $ runSTFn1 Region.fromParent (DekuParent $ toDekuElement elt)\n  scope <- liftST $ runSTFn3 newPSR\n    Ancestry.root\n    lifecycle\n    region\n\n  void $ runEffectFn2 nut scope di\n  elementCache <- liftST $ ST.read elementCacheRef\n  textCache <- liftST $ ST.read textCacheRef\n  forWithIndex_ elementCache \\tag value -> do\n    setAttribute \"data-deku-ssr\" (Ancestry.toStringRepresentationInDOM tag) $\n      fromDekuElement (un SSRElementRenderingInfo value).backingElement\n  forWithIndex_ textCache \\tag value -> do\n    transformTextNode (Ancestry.toStringRepresentationInDOM tag) $ fromDekuText\n      (un SSRTextRenderingInfo value).backingText\n  let\n    setMapOpPar = Set.fromFoldable\n      <<< filterMap (unsafeCollectLineage >=> truncateLineageBy1)\n      <<< (Set.toUnfoldable :: _ -> Array _)\n    setMapOp = Set.fromFoldable\n      <<< filterMap unsafeCollectLineage\n      <<< (Set.toUnfoldable :: _ -> Array _)\n  --\n  allParDynAncestry <- setMapOpPar <$> (liftST $ ST.read dynCacheRef)\n  allParPortalAncestry <- setMapOpPar <$> (liftST $ ST.read portalCacheRef)\n  allParFixedAncestry <- setMapOpPar <$> (liftST $ ST.read fixedCacheRef)\n  --\n  allDynAncestry <- setMapOp <$> (liftST $ ST.read dynCacheRef)\n  allPortalAncestry <- setMapOp <$> (liftST $ ST.read portalCacheRef)\n  allFixedAncestry <- setMapOp <$> (liftST $ ST.read fixedCacheRef)\n  --\n  let\n    allDynamicEntries = allDynAncestry <> allPortalAncestry <> allFixedAncestry\n    allDekuEltAndTextAncestries =\n      foldl (\\b a -> maybe b (flip Set.insert b) $ unsafeCollectLineage a)\n        Set.empty $ Map.keys textCache <> Map.keys elementCache\n    safeEntries = Set.filter\n      ( hasPlainAncestry\n          (allParDynAncestry <> allParPortalAncestry <> allParFixedAncestry)\n          allDynamicEntries\n      )\n      allDekuEltAndTextAncestries\n    elementCache' = Map.fromFoldable $ filterMap\n      (lmap unsafeCollectLineage >>> swap >>> sequence >>> map swap)\n      (Map.toUnfoldable elementCache :: Array _)\n    textCache' = Map.fromFoldable $ filterMap\n      (lmap unsafeCollectLineage >>> swap >>> sequence >>> map swap)\n      (Map.toUnfoldable textCache :: Array _)\n  Tuple _ superSafeEntries <- map (map Set.fromFoldable) $ runWriterT $ for_\n    safeEntries\n    \\se -> do\n      for_ (Map.lookup se elementCache')\n        \\(SSRElementRenderingInfo { isImpure, backingElement }) ->\n          when (not isImpure) do\n            tell [ se ]\n            lift do\n              removeAttribute \"data-deku-ssr\" $ fromDekuElement backingElement\n      for_ (Map.lookup se textCache')\n        \\(SSRTextRenderingInfo { backingText, isImpure }) ->\n          when (not isImpure) do\n            tell [ se ]\n            lift do\n              let tn = Text.toNode $ fromDekuText backingText\n              prevComment <- previousSibling tn\n              nextComment <- nextSibling tn\n              for_ prevComment \\pc ->\n                for_ nextComment \\nc -> do\n                  par <- parentNode pc\n                  for_ par \\p -> do\n                    removeChild pc p\n                    removeChild nc p\n  let\n    superDuperSafeEntries = Set.filter\n      ( flip ancestryNotPresentIn\n          ( Set.difference (allDekuEltAndTextAncestries <> allDynamicEntries)\n              superSafeEntries\n          )\n      )\n      superSafeEntries\n    boring = Set.filter\n      ( maybe true (not $ flip Set.member superDuperSafeEntries) <<<\n          truncateLineageBy1\n      )\n      superDuperSafeEntries\n  htmlString <- innerHTML elt\n  dispose unit\n  livePortals <- liftST $ ST.read purePortalsRef\n  pure $\n    { html: String.replace (String.Pattern \"data-deku-value\")\n        (String.Replacement \"value\")\n        htmlString\n    , livePortals: Array.fromFoldable livePortals\n    , boring:reconstructAncestry <$> Array.fromFoldable boring\n    }\n\nssrInBody\n  :: Nut\n  -> Effect SSROutput\nssrInBody = doInBody ssrInElement\n\nhydrateInElement\n  :: forall r\n   . { livePortals :: Array Ancestry\n     , boring :: Array Ancestry\n     | r\n     }\n  -> Web.DOM.Element\n  -> Nut\n  -> Effect (Effect Unit)\nhydrateInElement { livePortals, boring } ielt (Nut nut) = do\n  { poll: lifecycle, push: dispose } <- liftST create\n  portalCtrRef <- liftST $ ST.new (-1)\n  region <- liftST $ runSTFn1 Region.fromParent\n    (DekuParent $ toDekuElement ielt)\n  nodes <-\n    querySelectorAll (QuerySelector \"[data-deku-ssr]\") (toParentNode ielt)\n      >>= toArray\n  kv <- nodes # traverse \\node -> do\n    case Element.fromNode node of\n      Nothing -> throwException (error \"Could not convert node to element\")\n      Just elt -> do\n        attr <- getAttribute \"data-deku-ssr\" elt\n        case attr of\n          Nothing -> throwException (error \"Could not get ssr rep\")\n          Just k -> pure $ Tuple (Ancestry.unsafeFakeAncestry k) elt\n  textNodes <-\n    Map.fromFoldable <<< map (\\{ k, v } -> Ancestry.unsafeFakeAncestry k /\\ v)\n      <$>\n        mapIdsToTextNodes ielt\n  scope <- liftST $ runSTFn3 newPSR Ancestry.root lifecycle region\n  void $ runEffectFn2 nut scope\n    ( hydratingDOMInterpret (Set.fromFoldable boring) portalCtrRef (Map.fromFoldable kv) textNodes\n        (Set.fromFoldable livePortals)\n    )\n  pure $ dispose unit\n\nhydrateInBody\n  :: forall r\n   . { livePortals :: Array Ancestry\n     , boring :: Array Ancestry\n     | r\n     }\n  -> Nut\n  -> Effect (Effect Unit)\nhydrateInBody = doInBody <<< hydrateInElement\n", "export const log = function (s) {\n  return function () {\n    console.log(s);\n  };\n};\n\nexport const warn = function (s) {\n  return function () {\n    console.warn(s);\n  };\n};\n\nexport const error = function (s) {\n  return function () {\n    console.error(s);\n  };\n};\n\nexport const info = function (s) {\n  return function () {\n    console.info(s);\n  };\n};\n\nexport const debug = function (s) {\n  return function () {\n    console.debug(s);\n  };\n};\n\nexport const time = function (s) {\n  return function () {\n    console.time(s);\n  };\n};\n\nexport const timeLog = function (s) {\n  return function () {\n    console.timeLog(s);\n  };\n};\n\nexport const timeEnd = function (s) {\n  return function () {\n    console.timeEnd(s);\n  };\n};\n\nexport const clear = function () {\n  console.clear();\n};\n\nexport const group = function (s) {\n  return function () {\n    console.group(s);\n  };\n};\n\nexport const groupCollapsed = function (s) {\n  return function () {\n    console.groupCollapsed(s);\n  };\n};\n\nexport const groupEnd = function () {\n  console.groupEnd();\n};\n", "module Main where\n\nimport Prelude\n\nimport Deku.Toplevel (runInBody)\nimport Effect (Effect)\nimport Effect.Console (log)\nimport Deku.DOM as DD\nimport Deku.Control as DC\nimport Deku.Do as Deku\nimport Deku.DOM.Attributes as DA\nimport Deku.Core (Nut)\n\n\nmain :: Effect Unit\nmain = do\n  log \"Hello\"\n  _ <- runInBody dekuApp\n  pure unit\n\n\n\nheader :: Nut\nheader =\n  DD.header [ DA.klass_ \"pf-v5-c-masthead\"]\n  [ DD.div [DA.klass_ \"pf-v5-c-masthead__main\"] []\n  , DD.div [DA.klass_ \"pf-v5-c-masthead__content\"] [DC.text_ \"Content\"]\n  ]\n\npageBody :: Nut\npageBody =\n  DD.main [DA.klass_ \"pf-v5-c-page__main\"]\n  [ DD.section [DA.klass_ \"pf-v5-c-page__main-section pf-m-dark-100\"]\n    [DC.text_ \"Hello, world!\"\n                                                                      ]]\n\ndekuApp :: Nut\ndekuApp = Deku.do\n  DD.div [DA.klass_ \"pf-v5-c-page\"]\n    [ header\n    , pageBody ]\n"],
  "mappings": "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",
  "names": ["arrayMap", "f", "arr", "l", "result", "i", "semigroupoidFn", "f", "g", "x", "compose", "dict", "composeFlipped", "dictSemigroupoid", "identity", "dict", "categoryFn", "x", "otherwise", "flip", "f", "b", "a", "$$const", "v", "applyFlipped", "x", "f", "apply", "map", "dict", "mapFlipped", "dictFunctor", "fa", "f", "$$void", "$$const", "voidLeft", "x", "functorArray", "concatArray", "xs", "ys", "semigroupUnit", "v", "v1", "semigroupArray", "append", "dict", "alt", "dict", "arrayApply", "fs", "xs", "l", "k", "result", "n", "i", "f", "j", "applyArray", "apply", "dict", "applySecond", "dictApply", "apply", "a", "b", "lift2", "f", "pure", "dict", "when", "dictApplicative", "pure", "v", "v1", "pure1", "liftA1", "f", "arrayBind", "arr", "f", "result", "i", "l", "discard", "dict", "bindArray", "bind", "dict", "bindFlipped", "dictBind", "discardUnit", "dictBind", "bind", "join", "dictBind", "bind", "m", "identity", "whenM", "dictMonad", "mb", "m", "b", "ap", "dictMonad", "f", "f$prime", "a$prime", "unsafeCoerce", "x", "toEffect", "unsafeCoerce", "map_", "f", "a", "pure_", "bind_", "forST", "lo", "hi", "f", "i", "foreach", "as", "f", "i", "l", "newSTRef", "val", "read", "ref", "modifyImpl", "f", "write", "a", "topNumber", "bottomNumber", "unsafeCompareImpl", "lt", "eq", "gt", "x", "y", "ordIntImpl", "unsafeCompareImpl", "refEq", "r1", "r2", "eqBooleanImpl", "eqIntImpl", "eqInt", "eqBoolean", "eq", "dict", "eqBoolean", "notEq", "dictEq", "eq", "x", "y", "LT", "GT", "EQ", "intAdd", "x", "y", "intMul", "semiringInt", "add", "dict", "ordInt", "compare", "dict", "max", "dictOrd", "compare", "x", "y", "v", "compare3", "LT", "EQ", "GT", "min", "clamp", "dictOrd", "min", "max", "low", "hi", "x", "max1", "showIntImpl", "showInt", "show", "dict", "Nothing", "Just", "maybe", "v", "v1", "v2", "Nothing", "Just", "isJust", "maybe", "$$const", "functorMaybe", "v", "v1", "Just", "Nothing", "fromMaybe", "a", "maybe", "identity", "fromJust", "v", "Just", "altMaybe", "v", "v1", "Nothing", "plusMaybe", "Left", "Right", "either", "v", "v1", "v2", "Left", "Right", "hush", "$$const", "Nothing", "Just", "monoidUnit", "mempty", "dict", "pureE", "a", "bindE", "f", "forE", "lo", "hi", "f", "i", "monadEffect", "bindEffect", "applicativeEffect", "functorEffect", "$lazy_functorEffect", "applyEffect", "$lazy_applyEffect", "semigroupEffect", "dictSemigroup", "monoidEffect", "dictMonoid", "_new", "val", "read", "ref", "write", "val", "ref", "$$new", "_new", "Loop", "Done", "tailRecM", "dict", "monadRecEffect", "f", "a", "fromDone", "v", "Done", "r", "Loop", "e", "read", "modify$prime", "modifyImpl", "modify", "f", "s", "s$prime", "functorST", "monadST", "bindST", "applicativeST", "applyST", "$lazy_applyST", "monadSTST", "monadSTEffect", "liftST", "dict", "runSTFn1", "fn", "a", "runSTFn2", "b", "runSTFn4", "fn", "a", "b", "c", "d", "empty", "dict", "replicateFill", "count", "value", "result", "replicatePolyfill", "n", "i", "replicateImpl", "length", "xs", "indexImpl", "just", "nothing", "xs", "i", "filterImpl", "f", "xs", "partitionImpl", "yes", "no", "i", "x", "sliceImpl", "s", "e", "l", "unsafeIndexImpl", "xs", "n", "newSTArray", "lengthImpl", "xs", "spliceImpl", "i", "howMany", "bs", "xs", "unsafeFreezeThawImpl", "unsafeFreezeImpl", "copyImpl", "xs", "thawImpl", "copyImpl", "pushImpl", "a", "xs", "unsafeFreeze", "runSTFn1", "unsafeFreezeImpl", "thaw", "runSTFn1", "thawImpl", "withArray", "f", "xs", "result", "unsafeFreeze", "splice", "runSTFn4", "spliceImpl", "push", "runSTFn2", "pushImpl", "length", "runSTFn1", "lengthImpl", "boolConj", "b1", "b2", "boolDisj", "boolNot", "b", "not", "dict", "disj", "dict", "heytingAlgebraBoolean", "a", "b", "not", "Iterator", "next", "v", "v1", "i", "iterator", "f", "newSTRef", "iterate", "iter", "$$break", "next", "mx", "Just", "Nothing", "foldrArray", "f", "init", "xs", "acc", "len", "i", "foldlArray", "Tuple", "uncurry", "f", "v", "functorTuple", "fst", "v", "coerce", "unwrap", "un", "v", "foldr", "dict", "oneOf", "dictFoldable", "foldr", "dictPlus", "oneOfMap", "f", "$453", "traverse_", "dictApplicative", "$454", "for_", "foldl", "dict", "foldableMaybe", "v", "v1", "v2", "Nothing", "Just", "dictMonoid", "foldMapDefaultR", "dictFoldable", "foldr", "dictMonoid", "f", "x", "acc", "foldableArray", "runFn2", "fn", "a", "b", "runFn3", "c", "runFn4", "d", "functorCompose", "dictFunctor", "dictFunctor1", "f", "v", "map", "map1", "unsafeIndex", "snoc", "xs", "x", "slice", "runFn3", "sliceImpl", "singleton", "a", "partition", "runFn2", "partitionImpl", "index", "last", "xs", "length", "filter", "runFn2", "filterImpl", "drop", "xs", "$173", "slice", "length", "concatMap", "flip", "bind", "bindArray", "mapMaybe", "f", "$189", "maybe", "singleton", "$190", "Nil", "Cons", "reverse", "go", "$copy_v", "$copy_v1", "v1", "Nil", "v", "Cons", "$tco_var_v", "compactableArray", "xs", "v", "iter", "$108", "Nothing", "Just", "push", "result", "$109", "Left", "ls", "Right", "rs", "v1", "unsafeFreeze", "compact", "dict", "error", "msg", "throwException", "e", "_indexOf", "just", "nothing", "x", "s", "i", "indexOf", "contains", "pat", "$23", "indexOf", "$24", "isArray", "value", "CatQueue", "uncons", "$copy_v", "v", "Nil", "CatQueue", "reverse", "Cons", "$tco_done", "Just", "Tuple", "snoc", "a", "$$null", "v", "Nil", "empty", "CatNil", "CatCons", "link", "v", "v1", "CatNil", "CatCons", "snoc", "foldr", "k", "b", "q", "foldl", "$copy_v", "$copy_v1", "$copy_v2", "v2", "Nil", "Cons", "$tco_var_v", "$tco_var_v1", "go", "$copy_xs", "$copy_ys", "uncons", "xs", "Nothing", "x", "i", "ys", "Just", "$tco_var_xs", "Tuple", "$66", "empty", "append", "link", "semigroupCatList", "append", "snoc", "cat", "a", "append", "CatCons", "empty", "Free", "Return", "Bind", "toView", "$copy_v", "runExpF", "v2", "concatF", "r", "append", "v", "uncons", "Nothing", "Just", "$tco_done", "a", "resume$prime", "k", "j", "f", "v", "toView", "Return", "Bind", "resume", "dictFunctor", "g", "i", "fromView", "empty", "freeMonad", "freeFunctor", "k", "f", "$189", "pure", "freeApplicative", "$190", "freeBind", "v", "Free", "snoc", "$191", "fromView", "Return", "liftF", "f", "fromView", "Bind", "$192", "nullable", "a", "f", "toMaybe", "Nothing", "Just", "mkEffectFn1", "fn", "x", "mkEffectFn2", "a", "b", "mkEffectFn3", "c", "runEffectFn1", "fn", "a", "runEffectFn2", "b", "semigroupEffectFn1", "dictSemigroup", "f1", "f2", "runEffectFn1", "monoidEffectFn1", "dictMonoid", "v", "toArrayWithKey", "f", "m", "r", "k", "keys", "Element", "Root", "RealAncestry", "FakeAncestry", "root", "hasElementParent", "v", "RealAncestry", "FakeAncestry", "contains", "element", "v", "v1", "RealAncestry", "show", "FakeAncestry", "toDekuText", "unsafeCoerce", "toDekuElement", "unsafeCoerce", "fromDekuText", "fromDekuElement", "unsafeCoerce", "objHack", "tag", "insertObjHack", "k", "v", "o", "deleteObjHack", "m", "run", "M", "f", "i", "kv", "fastForeachOhE", "ff", "maybeBool", "p", "x", "$66", "Nothing", "filterableArray", "p", "go", "acc", "x", "v", "Left", "Right", "filterMap", "dict", "eitherBool", "p", "x", "$84", "Left", "sampleOnRight", "dict", "sampleOnRightOp", "dictIsEvent", "ef", "ea", "map1", "applyFlipped", "sampleOnLeft", "dict", "once", "dict", "keepLatest", "fix", "dict", "subscribeO", "v", "effectfulCallback", "subscribe", "liftST", "map", "mkEffectFn1", "sampleOnRight", "v1", "a", "latest", "f", "o", "c1", "c2", "sampleOnLeft", "once", "Nothing", "u", "Just", "c", "keepLatest", "v", "effectfulCallback", "v1", "cancelInner", "ci", "c", "cancelOuter", "justOneM", "a", "a$prime", "justOne", "justNone", "st", "st$prime", "justManyM", "justMany", "functorEvent", "f", "filter", "p", "Just", "Nothing", "filter$prime", "fastForeachST", "array", "fn", "x", "fastForeachE", "fastForeachST", "makeEventFromO", "event", "eventfulProgram", "effectfulCallback", "a", "go", "$170", "v", "Right", "pure1", "Done", "Left", "v1", "closeEvent", "makeEvent", "giveMe_eventb_btoEventfulProgram_iGive_StSt", "bToEventfulProgram", "create_", "tag", "effectfulCallback", "idx", "ix", "recordOfEffectfulCallbacks", "subscribers", "v", "createPure", "create_", "create", "fix", "f", "v", "v2", "v1", "mkEffectFn1", "c1", "c2", "memoize", "e", "create", "subscribe", "v", "unsubscribe", "compactableEvent", "filter", "identity", "xs", "Left", "Just", "Right", "Nothing", "filterableEvent", "filter$prime", "p", "$171", "f", "$172", "either", "$$const", "$173", "$174", "biSampleOn", "v1", "effectfulCallback", "a", "latest1", "latest2", "res", "c1", "c2", "applyEvent", "b", "map1", "applyFlipped", "altEvent", "v", "v1", "effectfulCallback", "v2", "v3", "plusEvent", "eventIsEvent", "keepLatest", "sampleOnRight", "sampleOnLeft", "fix", "once", "profunctorFn", "a2b", "c2d", "b2c", "$18", "dimap", "dict", "windowImpl", "_unsafeReadProtoTagged", "nothing", "just", "name", "value", "ty", "obj", "proto", "constructorName", "unsafeReadProtoTagged", "name", "value", "setDisabled", "disabled", "button", "fromElement", "unsafeReadProtoTagged", "_body", "doc", "body", "doc", "toElement", "unsafeCoerce", "setDisabled", "disabled", "fieldset", "fromElement", "unsafeReadProtoTagged", "setChecked", "checked", "input", "setDisabled", "disabled", "input", "setValue", "value", "input", "fromElement", "unsafeReadProtoTagged", "setDisabled", "disabled", "keygen", "fromElement", "unsafeReadProtoTagged", "setDisabled", "disabled", "link", "fromElement", "unsafeReadProtoTagged", "setDisabled", "disabled", "optgroup", "fromElement", "unsafeReadProtoTagged", "setDisabled", "disabled", "option", "fromElement", "unsafeReadProtoTagged", "setDisabled", "disabled", "select", "fromElement", "unsafeReadProtoTagged", "setDisabled", "disabled", "textarea", "setValue", "value", "textarea", "fromElement", "unsafeReadProtoTagged", "document", "window", "APoll", "x", "KeepLatestStart", "KeepLatestLast", "pollable", "dictIsEvent", "v", "ab", "sample", "dict", "poll", "APoll", "sham", "dictIsEvent", "i", "stRefToPoll", "r", "poll", "e", "s", "f", "i", "once", "dictPollable", "sample", "dictIsEvent", "poll", "e", "functorAPoll", "dictFunctor", "f", "v", "e", "map3", "v1", "$496", "sampleBy", "dictPollable", "sample", "dictFunctor1", "apollA", "pollableB", "map4", "applyFlipped", "keepLatest", "dictFilterable", "dictIsEvent", "dictPollable", "sampleBy", "Functor1", "a", "e", "v", "KeepLatestLast", "Just", "Nothing", "ie", "sampleBy1", "KeepLatestStart", "keepLatest1", "flip", "filterMap1", "bb", "v1", "empty", "sample_", "dictFunctor", "dictFunctor1", "pollable1", "functorEvent", "rant", "a", "maybeUnsubscribe", "v", "Nothing", "Just", "poll", "requesterEvent", "responseEventCallback", "sample_1", "once1", "v1", "justNone", "ep", "unsubscribe", "sampleOnRightOp", "justOne", "u3", "sampleOnLeft", "dictPollable", "sample_", "sampleBy", "dictIsEvent", "pollA", "pollAB", "e", "sampleBy2", "composeFlipped", "sampleOnRight", "altAPoll", "dictAlt", "plusAPoll", "dictPlus", "fix", "dictPollable", "sampleBy", "dictIsEvent", "sham", "f", "poll", "innerPoll", "e", "fixed", "fix1", "ee", "sham2", "map3", "fst", "v", "filterMap", "dictCompactable", "dictFunctor", "pollA", "a", "ff", "partitionMap", "fb", "compactableAPoll", "identity", "filterableAPoll", "$497", "p", "xs", "o", "partitionMap1", "eitherBool", "isEventAPoll", "keepLatest", "Filterable2", "dictPlus", "sampleOnRight", "sampleOnLeft", "once", "deflect", "pollA", "innerPoll", "e", "innerEvent", "s", "maybeUnsubscribe", "v", "Nothing", "sample_1", "once1", "i", "ep", "flip", "snoc", "unsubscribe", "Just", "f", "r", "u3", "poll", "applyAPoll", "dictApply", "v", "v1", "e", "ff", "v2", "voidLeft", "identity", "map3", "Tuple", "applicativeAPoll", "dictApply", "a", "e", "OnlyPure", "OnlyPoll", "OnlyEvent", "PureAndEvent", "PureAndPoll", "pollableEvent", "v", "v1", "e", "makeEvent", "s", "f", "sample1", "sampleOnLeft1", "toPoll", "alt1", "oneOfMap", "pure", "sham1", "sample", "dict", "pollableEvent", "pollFromPoll", "i", "sampleOnLeft", "v", "v1", "OnlyEvent", "sampleOnLeft1", "sampleOnLeft2", "toPoll", "sampleOnRight", "sampleOnRight1", "sampleOnRight2", "stRefToPoll", "r", "pollFromEvent", "sham", "once", "i", "pollFromPoll", "once1", "toPoll", "keepLatest$prime", "e", "s", "onPure", "p", "cancelInner", "onPoll", "sample1", "ep", "justOne", "identity", "c", "onEvent", "ev", "treatMe", "i", "OnlyPure", "OnlyEvent", "OnlyPoll", "PureAndEvent", "discard1", "PureAndPoll", "ci", "cancelOuter", "functorAPoll", "v", "v1", "PureAndPoll", "map", "map2", "PureAndEvent", "map3", "OnlyPure", "OnlyEvent", "OnlyPoll", "altPoll", "v", "v1", "OnlyPure", "append", "OnlyEvent", "PureAndEvent", "OnlyPoll", "PureAndPoll", "sham1", "alt", "alt1", "plusPoll", "rant", "$copy_v", "$tco_done", "pure1", "foldlArr", "bc", "arf", "bb", "arr", "go", "$copy_i", "$copy_b", "i", "length", "b", "otherwise", "unsafeIndex", "Left", "$tco_var_i", "Right", "cnt", "isLast", "pl", "x", "e", "sub", "deflect", "sample1", "dfl", "sample2", "$lazy_replayPollsForKeepLatest", "justOne", "a", "replayPollsForKeepLatest", "keepLatest", "keepLatest$prime", "poll", "sampleBy1", "ff", "filterMap", "v", "v1", "PureAndPoll", "filterMap1", "filterMap2", "PureAndEvent", "filterMap3", "OnlyPure", "OnlyEvent", "OnlyPoll", "partitionMap", "f", "b", "fb", "map5", "either", "Just", "$$const", "Nothing", "compactablePoll", "identity", "filterablePoll", "$449", "maybeBool", "p", "xs", "o", "eitherBool", "eventOrBust", "empty", "fix", "empty1", "pollFromEvent", "fix1", "dimap", "pollFromPoll", "fix2", "toPoll", "isEventPoll", "sampleOnRight", "sampleOnLeft", "keepLatest", "once", "create", "rant", "sham", "v", "v1", "applyAPoll", "OnlyEvent", "apply", "pollFromPoll", "apply1", "toPoll", "applicativeAPoll", "a", "ParentStart", "Element", "Text", "StaticRegion", "x", "updateShared", "shared", "v", "region", "updateIx", "i", "readSharedBound", "newSpan", "parent", "parentBump", "pushAnchor", "v", "owner", "extent", "parentRegion", "parentBound", "children", "isLastBound", "region", "end", "pos", "length", "isEmpty", "apply", "map", "notEq", "join", "read", "v1", "index", "ix", "arr", "unsafeFreeze", "lastRegion", "updateParent", "wasLast", "managed", "nowLast", "last", "ownerIx", "$66", "anchor", "shareBound", "posRef", "prev", "endFromPrev", "currentExtent", "$$void", "write", "fixManagedTo", "from", "to", "fn", "unsafeIndex", "elems", "fixManaged", "insertManaged", "givenPos", "clamp", "maybe", "add", "pushIx", "i", "ixRef", "posEvent", "position", "alt", "map1", "stRefToPoll", "pollFromEvent", "prevBegin", "updateIx", "clearBound", "cleared", "$95", "selfIx", "nextBound", "extentToEff", "prevBound", "ownerEff", "extentToIx", "$69", "updateShared", "bumpBound", "bumped", "empty1", "$70", "ownedBound", "prevExtent", "$71", "a", "ref", "bound", "newShared", "previousRegion", "beginBound", "sbound", "allocateRegion", "sendTo", "pos$prime", "v2", "lastAnchor", "lastIx", "sharedBound", "removed", "min", "newBegin", "traverse_", "readSharedBound", "bump", "Nothing", "Just", "remove", "finalIx", "begin", "newStaticRegion", "findOrCreateSpan", "spanState", "spanCounter", "staticEnd", "update", "spanIx", "spanEnd", "staticBegin", "pure", "span", "fromSpan", "fromStatic", "fromParent", "ParentStart", "PSR", "x", "Namespace", "DOMInterpret", "x", "Attribute", "unsafeAttribute", "Attribute", "pump$prime", "v", "p", "effF", "staticEff", "handlePoll", "whichF", "y", "i", "f", "uu", "dynamicEff", "handleEvent", "go", "v1", "OnlyEvent", "OnlyPure", "OnlyPoll", "sample", "bang", "identity", "PureAndEvent", "PureAndPoll", "pump", "psr", "poll", "fn", "$$const", "prop$prime", "k", "v2", "toDekuElement", "newPSR", "ancestry", "signalDisposalQueueShouldBeTriggered", "region", "triggerDisposalQueueEffects", "unsubs", "l", "length", "stack", "addEffectToDisposalQueue", "eff", "handleScope", "psr", "pump", "PSR", "v", "text", "texts", "di", "ancestry", "OnlyPure", "DOMInterpret", "last", "OnlyEvent", "Nothing", "OnlyPoll", "PureAndEvent", "PureAndPoll", "txt", "modifiedPoll", "liftST", "handleTextUpdate", "useOriginalDi", "x", "di2", "pump$prime", "regionEnd", "Text", "handleRemove", "when", "hasElementParent", "text_", "pure", "elementify", "ns", "tag", "arrAtts", "nuts", "psr", "di", "isBoring", "DOMInterpret", "PSR", "map3", "Namespace", "Element", "elt", "handleAtts", "atts", "OnlyPure", "liftST", "pump$prime", "useOriginalDi", "newDi", "v", "fromDekuElement", "handleNuts", "aref", "newPSR", "element", "a", "eltRegion", "scope", "handleRemove", "when", "hasElementParent", "regionEnd", "handleScope", "section", "main", "header", "div", "Aff", "EMPTY", "PURE", "THROW", "CATCH", "SYNC", "ASYNC", "BIND", "BRACKET", "FORK", "SEQ", "MAP", "APPLY", "ALT", "CONS", "RESUME", "RELEASE", "FINALIZER", "FINALIZED", "FORKED", "FIBER", "THUNK", "tag", "_1", "_2", "_3", "AffCtr", "fn", "nonCanceler", "error", "runEff", "eff", "runSync", "left", "right", "runAsync", "k", "Scheduler", "limit", "size", "ix", "queue", "draining", "drain", "thunk", "cb", "i", "tmp", "Supervisor", "util", "fibers", "fiberId", "count", "fiber", "fid", "result", "killError", "killCount", "kills", "kill", "SUSPENDED", "CONTINUE", "STEP_BIND", "STEP_RESULT", "PENDING", "RETURN", "COMPLETED", "Fiber", "supervisor", "aff", "runTick", "status", "step", "fail", "interrupt", "bhead", "btail", "attempts", "bracketCount", "joinId", "joins", "rethrow", "run", "localRunTick", "attempt", "e", "sequential", "onComplete", "join", "jid", "canceler", "runPar", "par", "killId", "early", "root", "head", "tail", "kid", "loop", "lhs", "rhs", "resolve", "cancel", "innerKills", "newKills", "killCb", "_pure", "_throwError", "_liftEffect", "Aff", "makeAff", "Aff", "_sequential", "Aff", "klass", "dictFunctor", "$2636", "prop$prime", "$2637", "klass_", "dictApplicative", "$2638", "$2639", "pure", "$2640", "setInnerHtml", "html", "element", "runExists", "unsafeCoerce", "mkExists", "cbs", "pushCb", "name", "cb", "el", "ns", "popCb", "result", "createElement", "t", "after", "cs", "prepend", "createElementNS", "createText", "createDocumentFragment", "setTextContent", "value", "node", "addEventListener", "type", "listener", "useCapture", "target", "removeEventListener", "eventListener", "fn", "reallyUnsafeRefEq", "a", "b", "unsafeRefEq", "reallyUnsafeRefEq", "remove", "node", "getProp", "name", "doctype", "_namespaceURI", "_prefix", "localName", "tagName", "setAttribute", "name", "value", "element", "removeAttribute", "name", "element", "getEffProp", "name", "node", "children", "_firstElementChild", "_lastElementChild", "childElementCount", "getEffProp", "name", "node", "baseURI", "getEffProp", "_ownerDocument", "_parentNode", "_parentElement", "childNodes", "getEffProp", "_firstChild", "_lastChild", "_previousSibling", "_nextSibling", "_nodeValue", "textContent", "getEffProp", "nextSibling", "$15", "map", "toMaybe", "$16", "_nextSibling", "firstChild", "$25", "map", "toMaybe", "$26", "_firstChild", "toChildNode", "unsafeCoerce", "unsetAttributeEffect", "mkEffectFn2", "v", "elt$prime", "asElt", "fromDekuElement", "asEventTarget", "l", "toRemove", "setTextEffect", "str", "txt$prime", "txt", "fromDekuText", "setInnerHtmlEffect", "html", "anchor", "ParentStart", "setInnerHtml", "Element", "throwException", "error", "Text", "setCbEffect", "mkEffectFn3", "v1", "$47", "eventTarget", "nl", "removeTextEffect", "t", "removeElementEffect", "e", "makeTextEffect", "mstr", "makeElementEffect", "ns", "tag", "coerce", "Nothing", "Just", "createElementNS", "elt", "getDisableable", "go", "$copy_v", "Nil", "v2", "Cons", "mapFlipped", "e$prime", "$58", "$tco_done", "disableables", "setPropEffect", "o", "v3", "v4", "v5", "v6", "v7", "v8", "v9", "v10", "$64", "$65", "runExists", "$70", "$71", "setChecked", "$73", "$74", "setValue", "$76", "$77", "bufferPortal", "toDekuElement", "frag", "attachNodeEffect", "nodes", "prepend", "after", "attachTextEffect", "beamRegionEffect", "toNode", "a", "beamNodes", "first", "end", "target", "next", "current", "acc", "$86", "nextCandidate", "bind", "firstChild", "traverse_", "endNode", "beginNode", "$92", "nextSibling", "attachElementEffect", "runEffectFn2", "fullDOMInterpret", "v", "v1", "runInElement", "elt", "v", "v1", "region", "scope", "fullDOMInterpret", "doInBody", "f", "elt", "flip", "map2", "toElement", "b$prime", "runInBody", "doInBody", "runInElement", "log", "s", "pageBody", "main", "klass_", "section", "text_", "header", "div", "dekuApp"]
}
